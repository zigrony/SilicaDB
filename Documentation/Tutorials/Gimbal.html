<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Silica Gimbal Wireframe Sphere — Fixed</title>
<style>
  :root{
    --bg:#071226; --panel:#071226cc; --accent:#58a6ff; --muted:#9aa7bd;
    --ok:#2ecc71; --warn:#f39c12; --err:#e74c3c;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071226,#041020);color:#e6eef8}
  .wrap{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center}
  h3{margin:0;font-weight:600}
  .layout{display:flex;gap:14px;width:100%;max-width:1200px}
  .stage{flex:1;min-width:320px;background:linear-gradient(180deg,#061326,#041022);border-radius:10px;padding:18px;display:flex;align-items:center;justify-content:center;box-shadow:0 8px 30px rgba(2,6,23,.6)}
  svg{width:min(80vw,640px);height:min(60vh,640px)}
  .panel{width:380px;background:var(--panel);border-radius:10px;padding:12px;box-sizing:border-box;color:var(--muted);display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:8px;align-items:center}
  label{width:120px;color:#cfe3ff;font-size:13px}
  input[type="range"]{flex:1}
  input[type="number"]{width:72px;padding:6px;border-radius:6px;border:none;background:#071022;color:#dbeefe}
  select,input[type="color"]{background:#071022;color:#dbeefe;border-radius:6px;padding:6px;border:none}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe3ff;padding:8px 10px;border-radius:7px;cursor:pointer}
  button.primary{background:var(--accent);color:#071022;border:none}
  .hint{font-size:12px;color:var(--muted)}
  .metrics{display:flex;gap:8px;flex-wrap:wrap}
  .metric{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-size:13px}
  .legend{display:flex;gap:8px;align-items:center}
  .dot{width:12px;height:12px;border-radius:50%}
  footer{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <h3>Silica Gimbal Wireframe Sphere — Fixed</h3>
    <div class="layout">
      <div class="stage">
        <svg id="svg" viewBox="-250 -250 500 500" preserveAspectRatio="xMidYMid meet" aria-label="Gimbal wireframe sphere">
          <g id="sphereGroup"></g>
        </svg>
      </div>

      <div class="panel" aria-label="Controls">
        <div class="row">
          <label>Telemetry source</label>
          <select id="mode"><option value="sim">Simulated</option><option value="manual">Manual inputs</option></select>
        </div>

        <div id="manualControls" style="display:none">
          <div class="row"><label for="pitch">Pitch °</label><input id="pitch" type="range" min="-45" max="45" value="-10"/><input id="pitchn" type="number" value="-10" step="0.1"/></div>
          <div class="row"><label for="roll">Roll °</label><input id="roll" type="range" min="-45" max="45" value="6"/><input id="rolln" type="number" value="6" step="0.1"/></div>
          <div class="row"><label for="heading">Heading °</label><input id="heading" type="range" min="0" max="360" value="45"/><input id="headingn" type="number" value="45" step="0.1"/></div>
          <div class="row"><label for="active">Active queries</label><input id="active" type="range" min="0" max="120" value="12"/><input id="activen" type="number" value="12"/></div>
          <div class="row"><label for="rps">RPS</label><input id="rps" type="range" min="0" max="500" value="24"/><input id="rpsn" type="number" value="24"/></div>
        </div>

        <div class="row">
          <label>Auto-sim</label>
          <button id="toggleSim">Pause sim</button>
          <div class="hint">Click sphere to inspect a meridian (sample)</div>
        </div>

        <div class="row">
          <label>Mapping</label>
          <div style="display:flex;flex-direction:column;gap:6px">
            <div class="hint">Density ← active queries (quantized)</div>
            <div class="hint">Speed ← rps (time-based rotation)</div>
            <div class="hint">Pitch/Roll/Heading ← mapped angles</div>
          </div>
        </div>

        <div class="row metrics" id="metricReadout">
          <div class="metric">pitch: <span id="mPitch">-10</span>°</div>
          <div class="metric">roll: <span id="mRoll">6</span>°</div>
          <div class="metric">heading: <span id="mHead">45</span>°</div>
          <div class="metric">active: <span id="mActive">12</span></div>
          <div class="metric">rps: <span id="mRps">24</span></div>
        </div>

        <div style="height:6px"></div>
        <div class="legend">
          <div style="display:flex;gap:8px;align-items:center">
            <div class="dot" style="background:var(--ok)"></div><div class="hint">ok</div>
            <div class="dot" style="background:var(--warn)"></div><div class="hint">warn</div>
            <div class="dot" style="background:var(--err)"></div><div class="hint">err</div>
          </div>
        </div>

        <div style="flex:1"></div>
        <footer>Fixed: smoothing and deterministic node-pooling eliminate jitter and duplicates.</footer>
      </div>
    </div>
  </div>

<script>
/* Fixed Gimbal wireframe demo
   - Separates display smoothing from target telemetry
   - Keeps stable node pool synchronized with topology
   - Removes overlays deterministically
*/

(() => {
  // DOM references
  const svg = document.getElementById('svg');
  const group = document.getElementById('sphereGroup');

  const mode = document.getElementById('mode');
  const manualControls = document.getElementById('manualControls');
  const pitchR = document.getElementById('pitch'), pitchn = document.getElementById('pitchn');
  const rollR = document.getElementById('roll'), rolln = document.getElementById('rolln');
  const headR = document.getElementById('heading'), headn = document.getElementById('headingn');
  const activeR = document.getElementById('active'), activen = document.getElementById('activen');
  const rpsR = document.getElementById('rps'), rpsn = document.getElementById('rpsn');
  const toggleSim = document.getElementById('toggleSim');

  const mPitch = document.getElementById('mPitch'), mRoll = document.getElementById('mRoll'), mHead = document.getElementById('mHead');
  const mActive = document.getElementById('mActive'), mRps = document.getElementById('mRps');

  // math helpers
  const deg = Math.PI/180;
  function rotX(a){ const c=Math.cos(a), s=Math.sin(a); return [1,0,0, 0,c,-s, 0,s,c]; }
  function rotY(a){ const c=Math.cos(a), s=Math.sin(a); return [c,0,s, 0,1,0, -s,0,c]; }
  function rotZ(a){ const c=Math.cos(a), s=Math.sin(a); return [c,-s,0, s,c,0, 0,0,1]; }
  function matMul(a,b){
    return [
      a[0]*b[0]+a[1]*b[3]+a[2]*b[6], a[0]*b[1]+a[1]*b[4]+a[2]*b[7], a[0]*b[2]+a[1]*b[5]+a[2]*b[8],
      a[3]*b[0]+a[4]*b[3]+a[5]*b[6], a[3]*b[1]+a[4]*b[4]+a[5]*b[7], a[3]*b[2]+a[4]*b[5]+a[5]*b[8],
      a[6]*b[0]+a[7]*b[3]+a[8]*b[6], a[6]*b[1]+a[7]*b[4]+a[8]*b[7], a[6]*b[2]+a[7]*b[5]+a[8]*b[8]
    ];
  }
  function matMulVec(m,v){ return [m[0]*v[0]+m[1]*v[1]+m[2]*v[2], m[3]*v[0]+m[4]*v[1]+m[5]*v[2], m[6]*v[0]+m[7]*v[1]+m[8]*v[2]]; }

  // topology cache
  const densityBuckets = [6,12,18,24,32,40,48];
  const topologyCache = new Map();
  function buildTopology(d){
    if(topologyCache.has(d)) return topologyCache.get(d);
    const meridians = d;
    const parallels = Math.max(4, Math.floor(d/2));
    const samples = {meridians:[],parallels:[]};
    for(let i=0;i<meridians;i++){
      const theta = (i/meridians) * Math.PI*2;
      const pts=[];
      for(let j=0;j<=parallels;j++){
        const phi = -Math.PI/2 + (j/parallels)*Math.PI;
        const x = Math.cos(phi)*Math.cos(theta);
        const y = Math.cos(phi)*Math.sin(theta);
        const z = Math.sin(phi);
        pts.push([x,y,z]);
      }
      samples.meridians.push(pts);
    }
    for(let p=1;p<parallels;p++){
      const phi = -Math.PI/2 + (p/parallels)*Math.PI;
      const r = Math.cos(phi), z=Math.sin(phi);
      const pts=[];
      const segs = meridians*2;
      for(let i=0;i<=segs;i++){
        const theta = (i/segs)*Math.PI*2;
        pts.push([r*Math.cos(theta), r*Math.sin(theta), z]);
      }
      samples.parallels.push(pts);
    }
    topologyCache.set(d,samples);
    return samples;
  }

  // authoritative telemetry targets (state) and separate smoothed display copy
  const state = {
    pitch: -10, roll: 6, heading: 45,
    active: 12, rps: 24,
    density: 18,
    zoom: 1,
    frontColor: '#dbeefe', backColor: '#2a6b9e',
    autoRotateAxis: 'y', autoRotateSpeed: 0,
    animRunning: true,
    expandedMeridian: null
  };
  const display = { pitch: state.pitch, roll: state.roll, heading: state.heading };

  // node pool
  let createdNodes = false;
  let nodeList = {back:[], front:[], rim:null};

  // ensure deterministic node pool that exactly matches topology
  function ensureNodesForTopology(samples){
    // remove any transient overlay to avoid duplicates
    const oldOverlay = document.getElementById('overlayQueries');
    if(oldOverlay && oldOverlay.parentNode) oldOverlay.parentNode.removeChild(oldOverlay);

    const total = samples.meridians.length + samples.parallels.length;
    if(createdNodes && nodeList.front.length === total) return; // good

    // otherwise rebuild deterministically
    while(group.firstChild) group.removeChild(group.firstChild);
    nodeList = {back:[], front:[], rim:null};
    for(let i=0;i<total;i++){
      const back = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      back.setAttribute('fill','none'); back.setAttribute('stroke-width','0.9'); back.setAttribute('stroke-linecap','round'); back.setAttribute('stroke-linejoin','round'); back.setAttribute('opacity','0.85');
      const front = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      front.setAttribute('fill','none'); front.setAttribute('stroke-width','0.9'); front.setAttribute('stroke-linecap','round'); front.setAttribute('stroke-linejoin','round'); front.setAttribute('opacity','1');
      group.appendChild(back); group.appendChild(front);
      nodeList.back.push(back); nodeList.front.push(front);
    }
    const rim = document.createElementNS('http://www.w3.org/2000/svg','circle');
    rim.setAttribute('cx','0'); rim.setAttribute('cy','0'); rim.setAttribute('r',201); rim.setAttribute('fill','none'); rim.setAttribute('stroke','rgba(255,255,255,0.02)'); rim.setAttribute('stroke-width','6'); rim.setAttribute('pointer-events','none');
    group.appendChild(rim);
    nodeList.rim = rim;
    createdNodes = true;
  }

  // projection
  function project(pt, scale=200){
    const [x,y,z]=pt;
    const perspective = 1 + (z * 0.06);
    return {x: x*scale*perspective*state.zoom, y: -y*scale*perspective*state.zoom, z};
  }

  // stroke computation
  function computeStroke(){
    const base = 0.9 * (18 / state.density);
    return Math.max(0.4, base).toFixed(2);
  }

  // render sphere using display (smoothed) values
  function drawSphere(){
    const topo = buildTopology(state.density);
    ensureNodesForTopology(topo);

    // rotation matrix built from display (smoothed) values
    const mx = rotX(display.pitch*deg);
    const my = rotY(display.roll*deg);
    const mz = rotZ(display.heading*deg);
    const m = matMul(mz, matMul(my, mx));

    let idx = 0;
    function renderArc(pts){
      const pts3 = pts.map(p=>matMulVec(m,p));
      const proj = pts3.map(p=>project(p));
      const avgZ = pts3.reduce((s,p)=>s+p[2],0)/pts3.length;
      const str = proj.map(p=>`${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
      const backNode = nodeList.back[idx];
      const frontNode = nodeList.front[idx];
      // classification: use avgZ to determine relative visual emphasis
      backNode.setAttribute('points', str);
      backNode.setAttribute('stroke', state.backColor);
      backNode.setAttribute('stroke-width', computeStroke());
      frontNode.setAttribute('points', str);
      frontNode.setAttribute('stroke', state.frontColor);
      frontNode.setAttribute('stroke-width', computeStroke());
      if(avgZ >= 0){
        frontNode.setAttribute('opacity','1'); backNode.setAttribute('opacity','0.25');
      } else {
        frontNode.setAttribute('opacity','0.6'); backNode.setAttribute('opacity','0.95');
      }
      idx++;
    }

    for(const arc of topo.meridians) renderArc(arc);
    for(const arc of topo.parallels) renderArc(arc);

    nodeList.rim.setAttribute('r', String(201*state.zoom));
    nodeList.rim.setAttribute('stroke-width', String(6*state.zoom));
  }

  // smoothing: copy targets -> display without mutating targets
  function smoothCopyTargets(alpha = 0.16){
    display.pitch += (state.pitch - display.pitch) * Math.min(1, alpha);
    display.roll  += (state.roll  - display.roll)  * Math.min(1, alpha);
    // heading wrap-safe smoothing
    const diff = (((state.heading - display.heading + 540) % 360) - 180);
    display.heading = (display.heading + diff * Math.min(1, alpha) + 360) % 360;
  }

  // mapping helpers
  function densityFromActive(active){
    const thresholds = [0,5,12,24,48,80,120];
    for(let i=thresholds.length-1;i>=0;i--){
      if(active >= thresholds[i]) return densityBuckets[i];
    }
    return densityBuckets[0];
  }
  function compositeHealth(raw){
    if(raw.active > 80 || raw.rps > 300) return 'err';
    if(raw.active > 40 || raw.rps > 120) return 'warn';
    return 'ok';
  }
  function mapTelemetryToVisuals(raw){
    const dens = densityFromActive(raw.active);
    if(state.density !== dens){
      state.density = dens;
      createdNodes = false; // force pool rebuild on next draw
    }
    state.autoRotateSpeed = Math.min(90, raw.rps * 0.75);
    state.pitch = raw.pitch;
    state.roll = raw.roll;
    state.heading = ((raw.heading % 360) + 360) % 360;
    const health = compositeHealth(raw);
    if(health === 'ok'){ state.frontColor = '#dbeefe'; state.backColor = '#2a6b9e'; }
    else if(health === 'warn'){ state.frontColor = '#ffcc66'; state.backColor = '#5a3f1a'; }
    else { state.frontColor = '#ffd7d0'; state.backColor = '#78302b'; }
  }

  // simulator
  let simPhase = 0;
  function simulateTelemetry(dt){
    simPhase += dt * 0.6;
    const pitch = -10 + Math.sin(simPhase*0.7)*8 + (Math.sin(simPhase*1.3)*2);
    const roll  = 6 + Math.cos(simPhase*0.5)*10;
    const heading = (simPhase*18) % 360;
    const active = Math.max(0, Math.round(12 + Math.sin(simPhase*0.4)*10 + Math.sin(simPhase*1.7)*5 + (Math.random()*6 -3)));
    const rps = Math.max(0, Math.round(20 + Math.cos(simPhase*0.8)*30 + (Math.random()*12-6)));
    return {pitch, roll, heading, active, rps};
  }

  // overlay expansion: render per-query arcs, but remove old overlay first
  function applyExpansion(){
    // remove old overlay
    const oldOverlay = document.getElementById('overlayQueries');
    if(oldOverlay && oldOverlay.parentNode) oldOverlay.parentNode.removeChild(oldOverlay);

    if(state.expandedMeridian === null) return;

    const topo = buildTopology(state.density);
    const k = Math.min(16, Math.max(3, Math.round(state.active / Math.max(1, Math.floor(state.density/6)))));
    const baseTheta = state.expandedMeridian * (2*Math.PI/topo.meridians.length);
    const perQueryArcs = [];
    for(let i=0;i<k;i++){
      const offset = (i - (k-1)/2) * 0.02;
      const theta = baseTheta + offset;
      const pts=[];
      const parallels = topo.meridians[0].length - 1;
      for(let j=0;j<=parallels;j++){
        const phi = -Math.PI/2 + (j/parallels)*Math.PI;
        pts.push([Math.cos(phi)*Math.cos(theta), Math.cos(phi)*Math.sin(theta), Math.sin(phi)]);
      }
      perQueryArcs.push({pts, id:i, color: queryColor(i,k)});
    }

    const overlayGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    overlayGroup.setAttribute('id','overlayQueries');
    group.appendChild(overlayGroup);

    // compute rotation matrix using display values
    const mx = rotX(display.pitch*deg), my = rotY(display.roll*deg), mz = rotZ(display.heading*deg);
    const m = matMul(mz, matMul(my,mx));
    for(const q of perQueryArcs){
      const pts3 = q.pts.map(p=>matMulVec(m,p));
      const proj = pts3.map(p=>project(p));
      const d = proj.map(p=>`${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      poly.setAttribute('points', d);
      poly.setAttribute('fill','none');
      poly.setAttribute('stroke', q.color);
      poly.setAttribute('stroke-width', (0.9 * (18/state.density)).toFixed(2));
      poly.setAttribute('stroke-linecap','round');
      poly.setAttribute('stroke-linejoin','round');
      poly.setAttribute('opacity','1');
      overlayGroup.appendChild(poly);
    }
  }

  function queryColor(i,k){
    const t = i/(Math.max(1,k-1));
    if(t < 0.6) return '#9fe6b6';
    if(t < 0.85) return '#ffd98a';
    return '#ffb6b6';
  }

  // UI bindings
  function bindManualSync(range, num){
    range.addEventListener('input', ()=>{ num.value = range.value; manualInputsToState(); });
    num.addEventListener('input', ()=>{ range.value = num.value; manualInputsToState(); });
  }
  bindManualSync(pitchR,pitchn); bindManualSync(rollR,rolln); bindManualSync(headR,headn);
  bindManualSync(activeR,activen); bindManualSync(rpsR,rpsn);

  function manualInputsToState(){
    if(mode.value !== 'manual') return;
    const raw = {
      pitch: parseFloat(pitchR.value),
      roll: parseFloat(rollR.value),
      heading: parseFloat(headR.value),
      active: parseInt(activeR.value,10),
      rps: parseFloat(rpsR.value)
    };
    mPitch.textContent = raw.pitch.toFixed(1);
    mRoll.textContent = raw.roll.toFixed(1);
    mHead.textContent = raw.heading.toFixed(1);
    mActive.textContent = raw.active;
    mRps.textContent = raw.rps;
    mapTelemetryToVisuals(raw);
  }

  mode.addEventListener('change', ()=>{
    if(mode.value === 'manual'){ manualControls.style.display='block'; simRunning = false; toggleSim.textContent='Sim paused'; }
    else { manualControls.style.display='none'; simRunning = true; toggleSim.textContent='Pause sim'; }
  });

  toggleSim.addEventListener('click', ()=>{
    simRunning = !simRunning;
    toggleSim.textContent = simRunning ? 'Pause sim' : 'Resume sim';
  });

  // find nearest meridian and toggle expansion
  svg.addEventListener('click', (ev)=>{
    const pt = svg.createSVGPoint(); pt.x = ev.clientX; pt.y = ev.clientY;
    const ctm = svg.getScreenCTM().inverse();
    const local = pt.matrixTransform(ctm);
    const angle = Math.atan2(-local.y, local.x) * 180/Math.PI;
    let ang = (angle + 360) % 360;
    const topo = buildTopology(state.density);
    const mcount = topo.meridians.length;
    const idx = Math.round((ang/360)*(mcount)) % mcount;
    state.expandedMeridian = (state.expandedMeridian === idx) ? null : idx;
    applyExpansion();
  });

  // animation loop
  let lastTs = performance.now();
  let simRunning = true;

  function loop(ts){
    const dt = Math.min(0.1, (ts - lastTs)/1000);
    lastTs = ts;

    if(mode.value === 'sim' && simRunning){
      const raw = simulateTelemetry(dt);
      mPitch.textContent = raw.pitch.toFixed(1);
      mRoll.textContent = raw.roll.toFixed(1);
      mHead.textContent = raw.heading.toFixed(1);
      mActive.textContent = raw.active;
      mRps.textContent = raw.rps;
      mapTelemetryToVisuals(raw);
    }

    // smooth targets into display and draw
    smoothCopyTargets(0.18);
    drawSphere();
    // refresh overlay if expanded (overlay is removed/added by ensureNodesForTopology)
    if(state.expandedMeridian !== null) applyExpansion();

    requestAnimationFrame(loop);
  }

  // initial UI state
  function initUI(){
    pitchR.value = state.pitch; pitchn.value = state.pitch;
    rollR.value = state.roll; rolln.value = state.roll;
    headR.value = state.heading; headn.value = state.heading;
    activeR.value = state.active; activen.value = state.active;
    rpsR.value = state.rps; rpsn.value = state.rps;
  }

  initUI();
  requestAnimationFrame(loop);

  // expose for debug
  window.__silicaGimbal = {state, display, buildTopology, topologyCache};

})();
</script>
</body>
</html>
