<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>three.js Pressure Gauge — Transparent center (hub 10%)</title>
<style>
:root{--bg:#071226;--panel:#0b1b2bcc;--muted:#9aa7bd;--accent:#58a6ff}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#061425,#031022);color:#e6eef8}
.wrap{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center}
h3{margin:0;font-weight:600}
.layout{display:flex;gap:16px;width:100%;max-width:1200px}
.stage{flex:1;min-width:320px;background:linear-gradient(180deg,#071726,#041322);border-radius:12px;padding:18px;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 40px rgba(0,0,0,.6)}
canvas{width:min(72vw,560px);height:min(60vh,560px);display:block;border-radius:8px;background:transparent}
.panel{width:420px;background:var(--panel);border-radius:12px;padding:14px;box-sizing:border-box;color:var(--muted);display:flex;flex-direction:column;gap:10px}
.row{display:flex;gap:8px;align-items:center}
label{width:140px;color:#cfe3ff;font-size:13px}
input[type="range"]{flex:1}
input[type="number"]{width:86px;padding:6px;border-radius:6px;border:none;background:#071022;color:#dbeefe}
select,button{background:#071022;color:#dbeefe;border-radius:6px;padding:6px;border:none}
button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe3ff;padding:8px 10px;border-radius:8px;cursor:pointer}
button.primary{background:var(--accent);color:#071022;border:none}
.hint{font-size:12px;color:var(--muted)}
.metric{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-size:13px}
hr{border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0}
.readout{color:#e6eef8;font-weight:600;text-align:center;margin-top:8px}
@media (max-width:880px){.layout{flex-direction:column}.panel{width:100%}}
.small{width:72px}
</style>
</head>

<script type="importmap">
{
  "imports": {
    "three": "../build/three.module.js",
    "three/addons/": "./jsm/"
  }
}
</script>

<body>
  <div class="wrap">
    <h3>three.js Pressure Gauge — Transparent center</h3>
    <div class="layout">
      <div class="stage"><canvas id="gl" aria-label="3D pressure gauge"></canvas></div>
      <div class="panel" aria-label="Controls">
        <div class="row"><label>Source</label><select id="mode"><option value="sim">Sim</option><option value="manual">Manual</option></select></div>
        <div id="manualControls" style="display:none" class="row"><label for="value">Value</label><input id="value" type="range" min="-200" max="400" value="34"/><input id="valuen" type="number" value="34" /></div>
        <div class="row"><label for="min">Min</label><input id="min" type="number" value="-20" /><label style="width:64px;text-align:right">Max</label><input id="max" type="number" value="100" /></div>
        <div class="row"><label for="greenEnd">Green end</label><input id="greenEnd" type="number" value="60" /><label style="width:90px;text-align:right">Yellow end</label><input id="yellowEnd" type="number" value="80" /></div>
        <div class="row"><label for="smoothing">Smoothing</label><input id="smoothing" type="range" min="0" max="1" step="0.02" value="0.18"/><input id="smoothingn" type="number" step="0.02" value="0.18"/></div>
        <div class="row"><label style="width:140px">Tube thickness</label><input id="band" type="range" min="6" max="36" value="18"/><input id="bandn" type="number" style="width:56px" value="18"/></div>
        <div class="row"><label style="width:140px">Torus depth</label><input id="depth" type="range" min="2" max="80" value="12"/><input id="depthn" type="number" style="width:56px" value="12"/></div>
        <div class="row"><label style="width:140px">Tube segs</label><input id="segs" type="range" min="4" max="256" value="120"/><input id="segsn" type="number" style="width:56px" value="120"/></div>
        <div class="row" style="margin-top:8px"><label style="width:140px">Auto-sim</label><button id="toggleSim">Pause sim</button><div class="hint">Click canvas to pulse; arrow keys nudge value</div></div>
        <hr>
        <div style="display:flex;gap:8px"><button id="copy">Copy state</button><button id="export">Export PNG</button><button id="reset" class="primary">Reset</button></div>
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap"><div class="metric">value: <span id="mValue">34</span></div><div class="metric">min: <span id="mMin">-20</span></div><div class="metric">max: <span id="mMax">100</span></div><div class="metric">zone: <span id="mZone">GREEN</span></div></div>
        <div class="readout" id="readout">range -20..100</div>
        <div class="hint" style="margin-top:8px">Press "B" to toggle raw vertex colors (basic) vs lit material (standard)</div>
      </div>
    </div>
  </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// renderer + scene
const canvas = document.getElementById('gl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.physicallyCorrectLights = true;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45,1,0.1,2000);
camera.position.set(0,0,520);

// groups
const root = new THREE.Group(); scene.add(root);
const gaugeGroup = new THREE.Group(); root.add(gaugeGroup);
const ringGroup = new THREE.Group(); gaugeGroup.add(ringGroup);
const ticksGroup = new THREE.Group(); ringGroup.add(ticksGroup);
const needleGroup = new THREE.Group(); gaugeGroup.add(needleGroup);

// lights — tuned to preserve color saturation
scene.add(new THREE.AmbientLight(0x222222, 0.25));
scene.add(new THREE.HemisphereLight(0x99aacc, 0x060712, 0.3));
const d1 = new THREE.DirectionalLight(0xffffff, 1.6); d1.position.set(300, 260, 240); scene.add(d1);
const d2 = new THREE.DirectionalLight(0x77aaff, 0.22); d2.position.set(-200, -160, -120); scene.add(d2);

// dom refs
const mode = document.getElementById('mode'), manualControls = document.getElementById('manualControls');
const vRange = document.getElementById('value'), vNum = document.getElementById('valuen');
const minIn = document.getElementById('min'), maxIn = document.getElementById('max');
const gEnd = document.getElementById('greenEnd'), yEnd = document.getElementById('yellowEnd');
const smoothing = document.getElementById('smoothing'), smoothingN = document.getElementById('smoothingn');
const band = document.getElementById('band'), bandn = document.getElementById('bandn');
const depth = document.getElementById('depth'), depthn = document.getElementById('depthn');
const segs = document.getElementById('segs'), segsn = document.getElementById('segsn');
const toggleSim = document.getElementById('toggleSim');
const copyBtn = document.getElementById('copy'), exportBtn = document.getElementById('export'), resetBtn = document.getElementById('reset');
const mValue = document.getElementById('mValue'), mMin = document.getElementById('mMin'), mMax = document.getElementById('mMax'), mZone = document.getElementById('mZone');
const readout = document.getElementById('readout');

// utilities
const START = 135, END = 45;
function normArc(a0,a1){ let A=a0%360; if(A<0)A+=360; let B=a1%360; if(B<0)B+=360; if(B<=A) B+=360; return {a0:A,a1:B,span:B-A}; }
const ARC = normArc(START, END);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const toRad = d=>d*Math.PI/180;
const toDeg = r=>r*180/Math.PI;
function valueToAngle(v,minVal,maxVal){ if(maxVal===minVal) return ARC.a0 + ARC.span*0.5; const t = clamp((v - minVal)/(maxVal - minVal),0,1); return ARC.a0 + ARC.span * t; }

// material factory & cache
const matCache = new Map();
function mkMat(opts){ const key = JSON.stringify(opts); if(matCache.has(key)) return matCache.get(key); const m = new THREE.MeshStandardMaterial(Object.assign({side:THREE.DoubleSide}, opts)); m.needsUpdate = true; matCache.set(key,m); return m; }

// Arc path for TubeGeometry
class ArcPath extends THREE.Curve {
  constructor(radius, a0deg, a1deg){ super(); this.radius = radius; this.a0 = toRad(a0deg); this.a1 = toRad(a1deg); }
  getPoint(t){ const a = this.a0 + (this.a1 - this.a0) * t; return new THREE.Vector3(Math.cos(a)*this.radius, -Math.sin(a)*this.radius, 0); }
}

// smoothstep helper
function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a),0,1); return t*t*(3-2*t); }

// ring holders
let ringMesh = null;
let capStart = null, capEnd = null;
let innerCore = null;
let useBasicDebug = false;

// PRECONVERTED COLORS (sRGB -> linear) and stronger yellow
const cG_srgb = new THREE.Color(0x2ecc71);
const cY_srgb = new THREE.Color(0xffd12a); // richer, warmer yellow
const cR_srgb = new THREE.Color(0xe74c3c);
const cG = cG_srgb.clone().convertSRGBToLinear();
const cY = cY_srgb.clone().convertSRGBToLinear();
const cR = cR_srgb.clone().convertSRGBToLinear();

// compute color at an angle (returns THREE.Color in linear space)
function colorAtAngleDeg(angleDeg, a0 = ARC.a0, a1 = ARC.a1){
  let ang = angleDeg;
  if(ang < 0) ang += 360;
  let A = a0, B = a1;
  if(B <= A) B += 360;
  if(ang < A) ang += 360;
  const t = clamp((ang - A) / (B - A), 0, 1);
  const minV = Number(minIn.value), maxV = Number(maxIn.value);
  const val = minV + t * (maxV - minV);
  const soft = (maxV - minV) * 0.015;
  const wG = smoothstep(minV - soft, Number(gEnd.value) + soft, val);
  const wY = smoothstep(Number(gEnd.value) - soft, Number(yEnd.value) + soft, val);
  const wR = smoothstep(Number(yEnd.value) - soft, maxV + soft, val);
  const sum = wG + wY + wR + 1e-9;
  const r = (wG*cG.r + wY*cY.r + wR*cR.r) / sum;
  const g = (wG*cG.g + wY*cY.g + wR*cR.g) / sum;
  const b = (wG*cG.b + wY*cY.b + wR*cR.b) / sum;
  return new THREE.Color(r,g,b);
}

// build torus arc with endcaps colored to match ring at the endpoint
function buildTorusArc(outerR, tubeRadius, arcA0, arcA1, tubularSegments, radialSegments){
  // dispose previous
  if(ringMesh){ ringMesh.geometry.dispose(); ringMesh.material.dispose && ringMesh.material.dispose(); ringGroup.remove(ringMesh); ringMesh = null; }
  if(capStart){ capStart.geometry.dispose(); capStart.material.dispose && capStart.material.dispose(); ringGroup.remove(capStart); capStart = null; }
  if(capEnd){ capEnd.geometry.dispose(); capEnd.material.dispose && capEnd.material.dispose(); ringGroup.remove(capEnd); capEnd = null; }
  if(innerCore){ innerCore.geometry.dispose(); innerCore.material.dispose && innerCore.material.dispose(); ringGroup.remove(innerCore); innerCore = null; }

  const path = new ArcPath(outerR, arcA0, arcA1);
  const tubularSegs = Math.max(4, Math.round(tubularSegments));
  const radialSegs = Math.max(24, Math.round(radialSegments)); // increase radial segments to reduce cross-section averaging
  const geom = new THREE.TubeGeometry(path, tubularSegs, tubeRadius, radialSegs, false);

  // vertex colors by angle (linear)
  const pos = geom.attributes.position.array;
  const count = geom.attributes.position.count;
  const colors = new Float32Array(count * 3);
  const minV = Number(minIn.value), maxV = Number(maxIn.value);

  for(let i=0;i<count;i++){
    const x = pos[i*3+0], y = pos[i*3+1];
    let ang = toDeg(Math.atan2(-y, x));
    if(ang < 0) ang += 360;
    let a0 = arcA0, a1 = arcA1;
    if(a1 <= a0) a1 += 360;
    let angAdj = ang;
    if(angAdj < a0) angAdj += 360;
    const t = clamp((angAdj - a0)/(a1-a0), 0, 1);
    const val = minV + t * (maxV - minV);

    // Strict banding with a small soft blend region to avoid three-way bleed
    const gT = Number(gEnd.value);
    const yT = Number(yEnd.value);
    const edge = Math.max((maxV - minV) * 0.0025, 0.4);

    let wG = 0, wY = 0, wR = 0;

    if (val <= gT - edge) {
      wG = 1;
    } else if (val >= yT + edge) {
      wR = 1;
    } else if (val >= gT + edge && val <= yT - edge) {
      wY = 1;
    } else if (val > gT - edge && val < gT + edge) {
      const tt = (val - (gT - edge)) / (2 * edge);
      wG = 1 - tt;
      wY = tt;
    } else if (val > yT - edge && val < yT + edge) {
      const tt = (val - (yT - edge)) / (2 * edge);
      wY = 1 - tt;
      wR = tt;
    } else {
      // fallback to softstep mix
      const soft = (maxV - minV) * 0.015;
      const swG = smoothstep(minV - soft, gT + soft, val);
      const swY = smoothstep(gT - soft, yT + soft, val);
      const swR = smoothstep(yT - soft, maxV + soft, val);
      const ssum = swG + swY + swR + 1e-9;
      wG = swG/ssum; wY = swY/ssum; wR = swR/ssum;
    }

    // base linear color
    let rr = wG*cG.r + wY*cY.r + wR*cR.r;
    let gg = wG*cG.g + wY*cY.g + wR*cR.g;
    let bb = wG*cG.b + wY*cY.b + wR*cR.b;

    // perceptual boost for yellow: small additive push when wY present
    if (wY > 0) {
      const boost = 0.16 * wY; // tweakable
      rr = Math.min(1, rr + cY.r * boost);
      gg = Math.min(1, gg + cY.g * boost);
      bb = Math.min(1, bb + cY.b * boost);
    }

    colors[i*3+0] = rr;
    colors[i*3+1] = gg;
    colors[i*3+2] = bb;
  }

  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geom.computeVertexNormals();

  // Ring material: tuned to be less rough so vertex color shows through
  const ringStd = mkMat({ vertexColors: true, metalness: 0.02, roughness: 0.12, clearcoat: 0.06 });
  ringStd.needsUpdate = true;

  const ringBasic = new THREE.MeshBasicMaterial({ vertexColors: true });

  ringMesh = new THREE.Mesh(geom, useBasicDebug ? ringBasic : ringStd);
  ringMesh.material.polygonOffset = true;
  ringMesh.material.polygonOffsetFactor = -1;
  ringMesh.material.polygonOffsetUnits = 1;
  ringGroup.add(ringMesh);

  // compute endcap colors by sampling at arc endpoints (use provided arc angles)
  const startColor = colorAtAngleDeg(arcA0, arcA0, arcA1);
  const endColor   = colorAtAngleDeg(arcA1, arcA0, arcA1);

  // endcaps oriented to match tube frame
  const capSegments = Math.max(16, radialSegs);
  const capGeom = new THREE.CircleGeometry(tubeRadius*1.02, capSegments);

  // give caps a small emissive tint to make mid-band read brighter
  const capStartMat = new THREE.MeshStandardMaterial({
    color: startColor,
    metalness: 0.02,
    roughness: 0.12,
    emissive: startColor.clone().multiplyScalar(0.12),
    side: THREE.DoubleSide
  });
  const capEndMat = new THREE.MeshStandardMaterial({
    color: endColor,
    metalness: 0.02,
    roughness: 0.12,
    emissive: endColor.clone().multiplyScalar(0.12),
    side: THREE.DoubleSide
  });

  capStart = new THREE.Mesh(capGeom.clone(), capStartMat);
  capEnd   = new THREE.Mesh(capGeom.clone(), capEndMat);

  const a0rad = toRad(arcA0), a1rad = toRad(arcA1);
  const startCenter = new THREE.Vector3(Math.cos(a0rad)*outerR, -Math.sin(a0rad)*outerR, 0);
  const endCenter   = new THREE.Vector3(Math.cos(a1rad)*outerR, -Math.sin(a1rad)*outerR, 0);

  capStart.position.copy(startCenter); capEnd.position.copy(endCenter);

  // Align cap normal to face outward along radial direction.
  const dirStart = new THREE.Vector3().copy(startCenter).normalize();
  const dirEnd   = new THREE.Vector3().copy(endCenter).normalize();
  const qStart = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dirStart);
  const qEnd   = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dirEnd);
  capStart.quaternion.copy(qStart);
  capEnd.quaternion.copy(qEnd);

  // Nudge caps outward slightly so they sit flush with the tube opening and avoid z-fighting.
  const offsetStart = dirStart.clone().multiplyScalar(tubeRadius * 0.5);
  const offsetEnd   = dirEnd.clone().multiplyScalar(tubeRadius * 0.5);
  capStart.position.add(offsetStart);
  capEnd.position.add(offsetEnd);

  // Optional: rotate the cap around its normal to align seam with tube tangent.
  try {
    const eps = 1e-4;
    const a0r = toRad(arcA0), a1r = toRad(arcA1);
    // tangent near start
    const p0 = new THREE.Vector3(Math.cos(a0r)*outerR, -Math.sin(a0r)*outerR, 0);
    const p0b = new THREE.Vector3(Math.cos(a0r + eps)*outerR, -Math.sin(a0r + eps)*outerR, 0);
    const tan0 = p0b.clone().sub(p0).normalize();
    // tangent near end
    const p1 = new THREE.Vector3(Math.cos(a1r)*outerR, -Math.sin(a1r)*outerR, 0);
    const p1b = new THREE.Vector3(Math.cos(a1r - eps)*outerR, -Math.sin(a1r - eps)*outerR, 0);
    const tan1 = p1b.clone().sub(p1).normalize();
    // compute local X after quaternion
    const localX0 = new THREE.Vector3(1,0,0).applyQuaternion(qStart);
    const cross0 = new THREE.Vector3().crossVectors(dirStart, localX0);
    const angle0 = Math.atan2(tan0.dot(cross0), tan0.dot(localX0));
    capStart.rotateOnAxis(dirStart, angle0);
    const localX1 = new THREE.Vector3(1,0,0).applyQuaternion(qEnd);
    const cross1 = new THREE.Vector3().crossVectors(dirEnd, localX1);
    const angle1 = Math.atan2(tan1.dot(cross1), tan1.dot(localX1));
    capEnd.rotateOnAxis(dirEnd, angle1);
  } catch (err) {
    // non-fatal: caps remain correctly oriented and positioned
  }

  ringGroup.add(capStart, capEnd);

  // innerCore: soft glass
  const innerRadius = outerR - tubeRadius - 2;
  const coreRadius = Math.max(2, innerRadius - 6);
  const coreHeight = Math.max(1, Number(depth.value) * 0.9);
  const coreGeo = new THREE.CylinderGeometry(coreRadius, coreRadius, coreHeight, 64);
  const coreMat = new THREE.MeshStandardMaterial({ color: 0x0b1220, metalness: 0.02, roughness: 0.28, transparent: true, opacity: 0.06, depthWrite: false });
  innerCore = new THREE.Mesh(coreGeo, coreMat);
  innerCore.rotation.x = Math.PI/2;
  innerCore.position.z = -coreHeight/2 - 0.8;
  ringGroup.add(innerCore);

  needleGroup.renderOrder = 2;

  return ringMesh;
}

// ticks & needle
function buildTicks(minVal, maxVal, outerR, tubeRadius, tickCount=20){
  while(ticksGroup.children.length){ const c = ticksGroup.children.pop(); c.geometry?.dispose(); c.material?.dispose && c.material.dispose(); }
  for(let i=0;i<=tickCount;i++){
    const v = minVal + (maxVal - minVal) * i / tickCount;
    const deg = valueToAngle(v, minVal, maxVal);
    const a = toRad(deg);
    const major = (i%5===0);
    const extra = major ? 10 : 3;
    const rIn = outerR - tubeRadius - 2;
    const rOut = outerR + tubeRadius + extra;
    const x1 = Math.cos(a) * rIn, y1 = -Math.sin(a) * rIn;
    const x2 = Math.cos(a) * rOut, y2 = -Math.sin(a) * rOut;
    const len = Math.hypot(x2-x1, y2-y1);
    const depthPx = Math.max(1, Number(depth.value) * 0.14);
    const geom = new THREE.BoxGeometry(len, major ? 2.4 : 1.6, depthPx);
    geom.computeVertexNormals();
    const mat = mkMat({ color: 0xe6eef8, metalness: 0.06, roughness: 0.44 });
    const m = new THREE.Mesh(geom, mat);
    m.position.set((x1+x2)/2, (y1+y2)/2, (tubeRadius) + depthPx/2 + 0.8);
    m.rotation.z = Math.atan2(y2-y1, x2-x1);
    ticksGroup.add(m);
  }
}

function buildNeedle(len, halfW, depthPx){
  while(needleGroup.children.length){ const c = needleGroup.children.pop(); c.geometry?.dispose(); c.material?.dispose && c.material.dispose(); }
  const throat = halfW * 0.7;
  const shape = new THREE.Shape();
  shape.moveTo(-throat, -throat*0.08);
  shape.lineTo(len, 0);
  shape.lineTo(-throat, throat*0.08);
  shape.closePath();

  const needleDepth = Math.max(1, depthPx * 0.9);
  const geo = new THREE.ExtrudeGeometry(shape, { depth: needleDepth, bevelEnabled:false, curveSegments:12 });
  geo.computeVertexNormals();
  geo.translate(0,0,-needleDepth/2);

  const main = new THREE.Mesh(geo, mkMat({ color: 0xffdf6b, roughness: 0.18, metalness: 0.12, clearcoat: 0.5 }));
  main.renderOrder = 3;
  needleGroup.add(main);

  const spineShape = new THREE.Shape();
  spineShape.moveTo(-throat*0.6, -throat*0.03);
  spineShape.lineTo(len*0.98, 0);
  spineShape.lineTo(-throat*0.6, throat*0.03);
  spineShape.closePath();
  const geo2 = new THREE.ExtrudeGeometry(spineShape, { depth: needleDepth*0.6, bevelEnabled:false });
  geo2.computeVertexNormals();
  geo2.translate(0,0,-(needleDepth*0.6)/2 - 0.6);
  const spine = new THREE.Mesh(geo2, mkMat({ color: 0x8f5d00, roughness:0.38, metalness:0.05 }));
  spine.renderOrder = 3;
  needleGroup.add(spine);

  const capBack = new THREE.Mesh(new THREE.CircleGeometry(10,32), mkMat({ color: 0x111111 }));
  capBack.rotation.x = -Math.PI/2; capBack.position.set(0, 0, needleDepth/2 + 6); capBack.renderOrder = 3;
  const capFront = new THREE.Mesh(new THREE.CircleGeometry(6,32), mkMat({ color: 0xdddddd }));
  capFront.rotation.x = -Math.PI/2; capFront.position.set(0, 0, needleDepth/2 + 8); capFront.renderOrder = 3;
  needleGroup.add(capBack, capFront);

  const shadow = new THREE.Mesh(new THREE.CircleGeometry(12, 32), new THREE.MeshBasicMaterial({ color: 0x000000, transparent:true, opacity:0.14 }));
  shadow.rotation.x = -Math.PI/2; shadow.position.z = -needleDepth/2 - 1.0; shadow.renderOrder = 1;
  needleGroup.add(shadow);
  needleGroup.position.z = 0;
}

// rebuild whole gauge
let outerR = 150, tubeRadius = 18;
const HUB_SCALE = 0.10; // shrink the hub "plate" radius to 10%

function rebuildAll(){
  // clear ringGroup safely
  while(ringGroup.children.length){
    const c = ringGroup.children.pop();
    c.traverse?.(n=>{ if(n.geometry) n.geometry.dispose(); if(n.material && n.material.dispose) n.material.dispose(); });
  }

  outerR = 150;
  tubeRadius = Math.max(3, Number(band.value)/2);
  const tubularSegments = Math.max(8, Number(segs.value));
  const radialSegments = Math.max(24, 24);

  buildTorusArc(outerR, tubeRadius, ARC.a0, ARC.a1, tubularSegments, radialSegments);

  // This cylinder was the large "plate" behind the needle. Shrink its radius.
  const originalHubR = Math.max(2, outerR - tubeRadius - 16);
  const hubRadius = Math.max(1.5, originalHubR * HUB_SCALE);
  const hubHeight = Math.max(1, Number(depth.value) * 0.25);
  const hubGeo = new THREE.CylinderGeometry(hubRadius, hubRadius, hubHeight, 64);
  const hubMat = mkMat({ color: 0x091016, metalness:0.12, roughness:0.45 });
  const hub = new THREE.Mesh(hubGeo, hubMat);
  hub.rotation.x = Math.PI/2;
  hub.position.z = -hubHeight/2 - 0.5;
  ringGroup.add(hub);

  buildTicks(Number(minIn.value), Number(maxIn.value), outerR, tubeRadius, 20);

  const needleLen = outerR - (tubeRadius + 8);
  buildNeedle(needleLen, 8, Number(depth.value));
  needleGroup.position.z = Number(depth.value)/2 + 6;
  gaugeGroup.add(needleGroup);
}

// needle placement
function setNeedleValue(v, useSmooth=true, alpha=0.4){
  const minV = Number(minIn.value), maxV = Number(maxIn.value);
  const clamped = clamp(v, minV, maxV);
  const deg = valueToAngle(clamped, minV, maxV);
  if(useSmooth){
    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,-toRad(deg)));
    needleGroup.quaternion.slerp(q, alpha);
  } else {
    needleGroup.quaternion.setFromEuler(new THREE.Euler(0,0,-toRad(deg)));
  }
}

// runtime init
let simRunning = true, simT = 0, last = performance.now();
let targetValue = Number(document.getElementById('value').value);
let display = { value: targetValue };

rebuildAll();
setNeedleValue(display.value, false);

// UI wiring
function sync(a,b){ a.addEventListener('input', ()=>{ b.value = a.value; }); b.addEventListener('input', ()=>{ a.value = b.value; }); }
sync(band, bandn); sync(depth, depthn); sync(segs, segsn);
smoothing.addEventListener('input', ()=> smoothingN.value = smoothing.value); smoothingN.addEventListener('input', ()=> smoothing.value = smoothingN.value);
vRange.addEventListener('input', ()=>{ vNum.value = vRange.value; targetValue = Number(vRange.value); });
vNum.addEventListener('input', ()=>{ vRange.value = vNum.value; targetValue = Number(vNum.value); });
mode.addEventListener('change', ()=>{ if(mode.value === 'manual'){ manualControls.style.display='flex'; simRunning=false; toggleSim.textContent='Sim paused'; } else { manualControls.style.display='none'; simRunning=true; toggleSim.textContent='Pause sim'; }});
toggleSim.addEventListener('click', ()=>{ simRunning = !simRunning; toggleSim.textContent = simRunning ? 'Pause sim' : 'Resume sim'; });

[ band, depth, segs, minIn, maxIn, gEnd, yEnd ].forEach(el => el.addEventListener('change', ()=>{ rebuildAll(); display.value = clamp(display.value, Number(minIn.value), Number(maxIn.value)); targetValue = clamp(targetValue, Number(minIn.value), Number(maxIn.value)); setNeedleValue(display.value, false); }));
[ band, depth, segs ].forEach(el => el.addEventListener('input', ()=>{/* live preview ok */}));

// interactivity & export
window.addEventListener('keydown', (e)=>{ 
  // debug toggle: B = toggle raw/basic vertex colors
  if(e.key === 'b' || e.key === 'B'){ useBasicDebug = !useBasicDebug; rebuildAll(); return; }
  const nudge = e.shiftKey ? (Number(maxIn.value)-Number(minIn.value))*0.02 : (Number(maxIn.value)-Number(minIn.value))*0.005;
  const minV = Number(minIn.value), maxV = Number(maxIn.value);
  if(e.key === 'ArrowUp'){ targetValue = clamp(targetValue + nudge, minV, maxV); vRange.value = targetValue; vNum.value = targetValue; }
  if(e.key === 'ArrowDown'){ targetValue = clamp(targetValue - nudge, minV, maxV); vRange.value = targetValue; vNum.value = targetValue; }
});
canvas.addEventListener('click', (ev)=>{ const rect = canvas.getBoundingClientRect(); const x = ev.clientX - (rect.left + rect.width/2); const impulse = clamp(Math.abs(x)/160 * (Number(maxIn.value)-Number(minIn.value)) * 0.06, 1, (Number(maxIn.value)-Number(minIn.value))*0.4); targetValue = clamp(Number(targetValue) + impulse, Number(minIn.value), Number(maxIn.value)); vRange.value = targetValue; vNum.value = targetValue; });
copyBtn.addEventListener('click', ()=>{ const snap = { value: Number(vRange.value), min: Number(minIn.value), max: Number(maxIn.value), band: Number(band.value), depth: Number(depth.value), segs: Number(segs.value) }; navigator.clipboard?.writeText(JSON.stringify(snap,null,2)); });
exportBtn.addEventListener('click', ()=>{ renderer.domElement.toBlob(blob=>{ if(!blob) return; const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'gauge.png'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }); });
resetBtn.addEventListener('click', ()=>{
  minIn.value=-20; maxIn.value=100; vRange.value=vNum.value=34; gEnd.value=60; yEnd.value=80;
  band.value=bandn.value=18; depth.value=depthn.value=12; segs.value=segsn.value=120; smoothing.value=smoothingN.value=0.18;
  useBasicDebug = false;
  rebuildAll();
  display.value = clamp(display.value, Number(minIn.value), Number(maxIn.value));
  targetValue = clamp(targetValue, Number(minIn.value), Number(maxIn.value));
  setNeedleValue(display.value, false);
});

// orbit + resize
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableZoom = true; controls.enablePan = false; controls.target.set(0,0,0);
controls.addEventListener('change', ()=>{/* ticks are in same local space as ring */});
function resize(){ const r = canvas.getBoundingClientRect(); const w = Math.max(160, Math.round(r.width)); const h = Math.max(160, Math.round(r.height)); renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix(); }
window.addEventListener('resize', resize); resize();

// animation loop
function frame(ts){
  const dt = Math.min(0.1, (ts - last)/1000); last = ts;
  if(mode.value === 'sim' && simRunning){
    simT += dt;
    const minV = Number(minIn.value), maxV = Number(maxIn.value);
    const center = (minV + maxV)/2; const span = (maxV - minV)/2;
    const base = center + Math.sin(simT * 0.6) * span * 0.35;
    const spike = (Math.sin(simT*2.7) > 0.98) ? (Math.random()*0.3*span) : 0;
    targetValue = clamp(base + spike, minV, maxV);
    vRange.value = targetValue; vNum.value = targetValue;
  }

  const alpha = Number(smoothing.value);
  display.value = display.value + (targetValue - display.value) * alpha;
  display.value = clamp(display.value, Number(minIn.value), Number(maxIn.value));
  setNeedleValue(display.value, true, Math.min(0.9, Math.max(0.06, alpha * 1.6)));

  mValue.textContent = Number.isInteger(display.value) ? String(Math.round(display.value)) : display.value.toFixed(1);
  mMin.textContent = String(minIn.value); mMax.textContent = String(maxIn.value);
  mZone.textContent = (display.value <= Number(gEnd.value)) ? 'GREEN' : (display.value <= Number(yEnd.value) ? 'YELLOW' : 'RED');
  readout.textContent = `range ${minIn.value}..${maxIn.value}`;

  renderer.render(scene, camera);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
