<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sphere Slideshow with Toggleable Masking</title>
<style>
  body {
    margin: 0;
    background: radial-gradient(circle at center,
      #00e6b8 0%,
      #00997a 60%,
      #003d33 100%
    );
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    font-family: Arial, sans-serif;
    color: white;
  }
  .stage {
    position: relative;
    width: 200px;
    height: 200px;
    perspective: 1000px;
  }
  .layer {
    position: absolute;
    inset: 0;
  }
  svg { width: 100%; height: 100%; }
  .front { stroke: white; stroke-opacity: 0.6; fill: none; }
  .back { stroke: #66cccc; stroke-opacity: 0.25; stroke-dasharray: 4 4; fill: none; }

  /* Orbiting Silica letters */
  .orbit-container {
    position: absolute;
    top: 50%; left: 50%;
    transform-style: preserve-3d;
    transform: translate(-50%, -50%);
    animation: fullOrbit 10s linear infinite;
    z-index: 2;
  }
  .orbit-arm {
    transform: translateZ(100px); /* sphere radius (95) + 5px padding */
    transform-style: preserve-3d;
  }
  .arc3d {
    display: flex;
    justify-content: center;
    align-items: baseline;
    transform-style: preserve-3d;
    transition: opacity 0.3s ease;
  }
  .arc3d span {
    display: inline-block;
    font-size: 40px;
    font-weight: bold;
    color: #cc5500;
    text-shadow: 2px 2px 0px black;
    margin: 0 1px;
    transform-origin: center bottom;
  }

  @keyframes fullOrbit {
    0%   { transform: translate(-50%, -50%) rotateY(0deg); }
    100% { transform: translate(-50%, -50%) rotateY(360deg); }
  }

  /* Controls */
  .controls {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 6px;
    font-size: 12px;
  }
  .controls label { display: block; margin: 4px 0; }
  .controls input { width: 100px; }
  .controls button { margin-top: 6px; width: 100%; }
</style>
</head>
<body>
  <div class="stage">
    <!-- Back hemisphere -->
    <div class="layer" id="backLayer"></div>

    <!-- Orbiting curved letters clipped to sphere -->
    <div class="orbit-container" id="orbitContainer">
      <div class="orbit-arm">
        <svg viewBox="0 0 200 200" width="200" height="200">
          <defs>
            <clipPath id="sphereClip">
              <circle cx="100" cy="100" r="95"/>
            </clipPath>
          </defs>
          <foreignObject x="0" y="0" width="200" height="200" clip-path="url(#sphereClip)">
            <div class="arc3d" id="arc3d"
                 xmlns="http://www.w3.org/1999/xhtml"
                 style="width:200px;height:200px;display:flex;justify-content:center;align-items:center;">
              <span>S</span><span>i</span><span>l</span><span>i</span><span>c</span><span>a</span>
            </div>
          </foreignObject>
        </svg>
      </div>
    </div>

    <!-- Front hemisphere -->
    <div class="layer" id="frontLayer"></div>
  </div>

  <div class="controls">
    <label>Max Density: <input type="number" id="maxDensity" value="10" min="2" max="20"></label>
    <label>Bins: <input type="number" id="bins" value="8" min="2" max="20"></label>
    <label>Crossfade (ms): <input type="number" id="fade" value="900"></label>
    <label>Dwell (ms): <input type="number" id="dwell" value="1200"></label>
    <label>Arc Depth (px): <input type="number" id="arcDepth" value="20" min="0" max="100"></label>
    <label><input type="checkbox" id="maskToggle" checked> Mask when behind</label>
    <button id="restart">Restart</button>
  </div>

<script>
const backLayer = document.getElementById('backLayer');
const frontLayer = document.getElementById('frontLayer');
const arc3d = document.getElementById('arc3d');
const orbitContainer = document.getElementById('orbitContainer');
const maskToggle = document.getElementById('maskToggle');
const svgNS = "http://www.w3.org/2000/svg";
let intervalId = null;

function buildSphere(density) {
  const backSVG = document.createElementNS(svgNS, "svg");
  backSVG.setAttribute("viewBox", "0 0 200 200");
  const frontSVG = document.createElementNS(svgNS, "svg");
  frontSVG.setAttribute("viewBox", "0 0 200 200");

  // outer circle
  const circle = document.createElementNS(svgNS, "circle");
  circle.setAttribute("cx", 100);
  circle.setAttribute("cy", 100);
  circle.setAttribute("r", 95);
  circle.setAttribute("class", "front");
  frontSVG.appendChild(circle);

  for (let i = 1; i < density; i++) {
    const ry = (95 / density) * i;
    const latBack = document.createElementNS(svgNS, "ellipse");
    latBack.setAttribute("cx", 100);
    latBack.setAttribute("cy", 100);
    latBack.setAttribute("rx", 95);
    latBack.setAttribute("ry", ry);
    latBack.setAttribute("class", "back");
    backSVG.appendChild(latBack);

    const latFront = latBack.cloneNode();
    latFront.setAttribute("class", "front");
    frontSVG.appendChild(latFront);
  }

  for (let i = 1; i < density; i++) {
    const rx = (95 / density) * i;
    const lonBack = document.createElementNS(svgNS, "ellipse");
    lonBack.setAttribute("cx", 100);
    lonBack.setAttribute("cy", 100);
    lonBack.setAttribute("rx", rx);
    lonBack.setAttribute("ry", 95);
    lonBack.setAttribute("class", "back");
    backSVG.appendChild(lonBack);

    const lonFront = lonBack.cloneNode();
    lonFront.setAttribute("class", "front");
    frontSVG.appendChild(lonFront);
  }

  return { backSVG, frontSVG };
}

function applyArcDepth(depth) {
  const letters = arc3d.querySelectorAll('span');
  const mid = (letters.length - 1) / 2;
  letters.forEach((span, idx) => {
    const rel = idx - mid;
    const z = depth - Math.abs(rel) * (depth / mid);
    span.style.transform = `translateZ(${z}px)`;
  });
}

// Hide text when behind if toggle is on
function updateVisibility() {
  if (maskToggle.checked) {
    const style = getComputedStyle(orbitContainer);
    const matrix = new WebKitCSSMatrix(style.transform);
    const angle = Math.atan2(matrix.m13, matrix.m11) * (180/Math.PI);
    const deg = (angle + 360) % 360;
    if (deg > 90 && deg < 270) {
      arc3d.style.opacity = 0;
    } else {
      arc3d.style.opacity = 1;
    }
  } else {
    arc3d.style.opacity = 1;
  }
  requestAnimationFrame(updateVisibility);
}

function startShow() {
  backLayer.innerHTML = '';
  frontLayer.innerHTML = '';
  if (intervalId) clearInterval(intervalId);

  const maxDensity = parseInt(document.getElementById('maxDensity').value, 10);
  const bins = parseInt(document.getElementById('bins').value, 10);
  const fade = parseInt(document.getElementById('fade').value, 10);
  const dwell = parseInt(document.getElementById('dwell').value, 10);
  const arcDepth = parseInt(document.getElementById('arcDepth').value, 10);

  // Apply current arc depth to letters
  applyArcDepth(arcDepth);

  // Build and de-duplicate density sequence
  const densities = [];
  for (let i = 0; i < bins; i++) {
    const t = (bins === 1) ? 0 : i / (bins - 1);
    const d = Math.round(2 + (maxDensity - 2) * t);
    densities.push(d);
  }
  const unique = [...new Set(densities)];

  // Render current density into back/front layers
  let index = 0;
  function showDensity(idx) {
    backLayer.innerHTML = '';
    frontLayer.innerHTML = '';
    const { backSVG, frontSVG } = buildSphere(unique[idx]);
    backLayer.appendChild(backSVG);
    frontLayer.appendChild(frontSVG);
  }

  showDensity(index);

  // Cycle densities with configured pacing
  intervalId = setInterval(() => {
    index = (index + 1) % unique.length;
    showDensity(index);
  }, fade + dwell);
}

document.getElementById('restart').addEventListener('click', startShow);
document.getElementById('arcDepth').addEventListener('input', e => {
  applyArcDepth(parseInt(e.target.value, 10));
});

// Start the masking loop and initial render
requestAnimationFrame(updateVisibility);
startShow();
</script>
</body>
</html>
