<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pressure Gauge — Configurable Min/Max</title>
<style>
  :root{
    --bg:#071226; --panel:#0b1b2bcc; --muted:#9aa7bd; --accent:#58a6ff;
    --ok:#2ecc71; --warn:#f39c12; --err:#e74c3c; --glass:rgba(255,255,255,0.06);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#061425,#031022);color:#e6eef8}
  .wrap{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center}
  h3{margin:0;font-weight:600}
  .layout{display:flex;gap:16px;width:100%;max-width:1200px}
  .stage{flex:1;min-width:320px;background:linear-gradient(180deg,#071726,#041322);border-radius:12px;padding:18px;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 40px rgba(0,0,0,.6)}
  svg{width:min(72vw,560px);height:min(60vh,560px);display:block}
  .panel{width:380px;background:var(--panel);border-radius:12px;padding:14px;box-sizing:border-box;color:var(--muted);display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:8px;align-items:center}
  label{width:130px;color:#cfe3ff;font-size:13px}
  input[type="range"]{flex:1}
  input[type="number"]{width:86px;padding:6px;border-radius:6px;border:none;background:#071022;color:#dbeefe}
  select,button,input[type="color"]{background:#071022;color:#dbeefe;border-radius:6px;padding:6px;border:none}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe3ff;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.primary{background:var(--accent);color:#071022;border:none}
  .hint{font-size:12px;color:var(--muted)}
  .metrics{display:flex;gap:8px;flex-wrap:wrap}
  .metric{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-size:13px}
  footer{font-size:12px;color:var(--muted)}
  @media (max-width:880px){.layout{flex-direction:column}.panel{width:100%}}
</style>
</head>
<body>
  <div class="wrap">
    <h3>Pressure Gauge — Configurable Min/Max</h3>
    <div class="layout">
      <div class="stage" id="stage">
        <svg id="gauge" viewBox="-220 -120 440 260" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Pressure gauge">
          <defs>
            <filter id="soft" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="2"/></filter>
            <linearGradient id="glass" x1="0" x2="0" y1="0" y2="1"><stop offset="0%" stop-color="#ffffff" stop-opacity="0.06"/><stop offset="100%" stop-color="#000000" stop-opacity="0.02"/></linearGradient>
          </defs>

          <rect x="-210" y="-120" width="420" height="240" rx="18" ry="18" fill="url(#glass)" stroke="rgba(255,255,255,0.03)" />

          <g id="zones"></g>
          <g id="ticks"></g>

          <g id="needleGroup">
            <circle cx="0" cy="40" r="6" fill="#222" stroke="rgba(255,255,255,0.08)"/>
            <path id="needle" d="" fill="#ffdf6b" stroke="#c57c00" stroke-width="0.8"/>
          </g>

          <g id="readout" transform="translate(0,105)">
            <rect x="-100" y="-26" width="200" height="34" rx="8" fill="rgba(0,0,0,0.36)"/>
            <text id="valueText" x="0" y="0" fill="#e6eef8" font-size="20" text-anchor="middle" font-weight="600">0</text>
            <text id="unitText" x="0" y="18" fill="#9aa7bd" font-size="11" text-anchor="middle">units</text>
          </g>

          <text id="minLabel" x="-180" y="140" fill="#9aa7bd" font-size="12" text-anchor="middle">min</text>
          <text id="maxLabel" x="180" y="140" fill="#9aa7bd" font-size="12" text-anchor="middle">max</text>
        </svg>
      </div>

      <div class="panel" aria-label="Controls">
        <div class="row"><label>Source</label><select id="mode"><option value="sim">Simulated</option><option value="manual">Manual</option></select></div>

        <div id="manualControls" style="display:none">
          <div class="row"><label for="value">Value</label><input id="value" type="range" min="-100" max="100" value="34"/><input id="valuen" type="number" value="34" /></div>
        </div>

        <div class="row"><label for="min">Min scale</label><input id="min" type="number" value="-20" /></div>
        <div class="row"><label for="max">Max scale</label><input id="max" type="number" value="100" /></div>

        <div class="row"><label for="greenEnd">Green end</label><input id="greenEnd" type="number" value="60" /></div>
        <div class="row"><label for="yellowEnd">Yellow end</label><input id="yellowEnd" type="number" value="80" /></div>

        <div class="row"><label for="smoothing">Smoothing</label><input id="smoothing" type="range" min="0" max="1" step="0.02" value="0.18"/><input id="smoothingn" type="number" step="0.02" value="0.18"/></div>

        <div class="row"><label>Auto-sim</label><button id="toggleSim">Pause sim</button><div class="hint">Click gauge to give a brief pulse. Arrow keys nudge value</div></div>

        <div class="row metrics">
          <div class="metric">value: <span id="mValue">34</span></div>
          <div class="metric">min: <span id="mMin">-20</span></div>
          <div class="metric">max: <span id="mMax">100</span></div>
          <div class="metric">zone: <span id="mZone">GREEN</span></div>
        </div>

        <div class="row" style="gap:8px">
          <button id="copySvg">Copy SVG</button>
          <button id="exportPng">Export PNG</button>
          <button id="reset" class="primary">Reset</button>
        </div>

        <div style="flex:1"></div>
        <footer>Gauge supports negative min. API: window.applyPressure({ value, min, max, ts, source })</footer>
      </div>
    </div>
  </div>

<script>
(function(){
  // DOM
  const svg = document.getElementById('gauge');
  const zonesG = document.getElementById('zones');
  const ticksG = document.getElementById('ticks');
  const needlePath = document.getElementById('needle');
  const valueText = document.getElementById('valueText');
  const unitText = document.getElementById('unitText');
  const minLabel = document.getElementById('minLabel');
  const maxLabel = document.getElementById('maxLabel');

  const mode = document.getElementById('mode');
  const manualControls = document.getElementById('manualControls');
  const valueRange = document.getElementById('value'), valueNum = document.getElementById('valuen');
  const minInput = document.getElementById('min'), maxInput = document.getElementById('max');
  const greenEndInput = document.getElementById('greenEnd'), yellowEndInput = document.getElementById('yellowEnd');
  const smoothingRange = document.getElementById('smoothing'), smoothingNum = document.getElementById('smoothingn');
  const toggleSim = document.getElementById('toggleSim');
  const mValue = document.getElementById('mValue'), mMin = document.getElementById('mMin'), mMax = document.getElementById('mMax'), mZone = document.getElementById('mZone');
  const copySvgBtn = document.getElementById('copySvg'), exportPngBtn = document.getElementById('exportPng'), resetBtn = document.getElementById('reset');

  // geometry: arc across bottom (0 at left-bottom, max at right-bottom)
  const startAngle = 135;
  const endAngle = 45;
  const radius = 150;

  // targets and display (min allowed negative)
  let target = { value: 34, min: -20, max: 100, ts: Date.now(), source: 'sim' };
  let display = { value: target.value };

  // sim
  let simT = 0, simRunning = true;

  const toRad = d => d * Math.PI / 180;
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  // angle helpers with wrap-awareness
  function angleSpan(a0deg, a1deg){
    let a0 = a0deg % 360; if(a0 < 0) a0 += 360;
    let a1 = a1deg % 360; if(a1 < 0) a1 += 360;
    if(a1 <= a0) a1 += 360;
    return { a0, a1 };
  }

  // map value in [min,max] to angle
  function valueToAngleDeg(v, minVal, maxVal){
    // prevent divide by zero
    if(maxVal === minVal) return (startAngle + ((endAngle - startAngle)/2));
    const t = clamp((v - minVal) / (maxVal - minVal), 0, 1);
    let a0 = startAngle, a1 = endAngle;
    if(a1 <= a0) a1 += 360;
    const angle = a0 + (a1 - a0) * t;
    return angle;
  }

  // draw zones (stroke-linecap butt for hard edges)
  function buildZonesAndTicks(){
    while(zonesG.firstChild) zonesG.removeChild(zonesG.firstChild);
    while(ticksG.firstChild) ticksG.removeChild(ticksG.firstChild);

    const minVal = Number(minInput.value);
    const maxVal = Number(maxInput.value);
    // zone ends are absolute values in the same units as min/max
    const gEnd = clamp(Number(greenEndInput.value), minVal, maxVal);
    const yEnd = clamp(Number(yellowEndInput.value), minVal, maxVal);

    function arcForRange(v0, v1, color){
      const a0 = toRad(valueToAngleDeg(v0, minVal, maxVal));
      const a1 = toRad(valueToAngleDeg(v1, minVal, maxVal));
      let delta = a1 - a0;
      if(delta < 0) delta += Math.PI*2;
      const large = Math.abs(delta) > Math.PI ? 1 : 0;
      const x0 = Math.cos(a0)*radius, y0 = Math.sin(a0)*radius;
      const x1 = Math.cos(a1)*radius, y1 = Math.sin(a1)*radius;
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x0.toFixed(2)} ${y0.toFixed(2)} A ${radius} ${radius} 0 ${large} 1 ${x1.toFixed(2)} ${y1.toFixed(2)}`);
      p.setAttribute('stroke', color);
      p.setAttribute('stroke-width', 20);
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke-linecap', 'butt');
      zonesG.appendChild(p);
    }

    // ensure zone order min->gEnd->yEnd->max
    arcForRange(minVal, gEnd, '#2ecc71');
    arcForRange(gEnd, yEnd, '#f39c12');
    arcForRange(yEnd, maxVal, '#e74c3c');

    // ticks on top
    const ticks = 20;
    for(let i=0;i<=ticks;i++){
      const v = minVal + (maxVal - minVal) * i / ticks;
      const deg = valueToAngleDeg(v, minVal, maxVal);
      const a = toRad(deg);
      const rOut = radius + (i%5===0 ? 12 : 6);
      const rIn = radius - 12;
      const x1 = Math.cos(a) * rIn, y1 = Math.sin(a) * rIn;
      const x2 = Math.cos(a) * rOut, y2 = Math.sin(a) * rOut;
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
      line.setAttribute('stroke', '#e6eef8');
      line.setAttribute('stroke-width', i%5===0 ? 2.2 : 1.2);
      line.setAttribute('stroke-linecap', 'square');
      ticksG.appendChild(line);
      if(i%5===0){
        const tx = Math.cos(a) * (radius - 30), ty = Math.sin(a) * (radius - 30);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x', String(tx)); lbl.setAttribute('y', String(ty + 4));
        lbl.setAttribute('fill', '#cfe3ff'); lbl.setAttribute('font-size', '12'); lbl.setAttribute('text-anchor', 'middle');
        // format tick label using compact formatting
        lbl.textContent = Number.isInteger(v) ? String(Math.round(v)) : v.toFixed(1);
        ticksG.appendChild(lbl);
      }
    }

    minLabel.textContent = String(minVal);
    maxLabel.textContent = String(maxVal);
  }

  // draw needle clamped to visible angular span
  function drawNeedleClamped(angleDeg){
    // compute angular span
    let a0 = startAngle % 360; if(a0 < 0) a0 += 360;
    let a1 = endAngle % 360; if(a1 < 0) a1 += 360;
    if(a1 <= a0) a1 += 360;
    // normalize angleDeg to be near span
    let a = angleDeg;
    // bring a into [a0-360, a1+360] range
    while(a < a0 - 360) a += 360;
    while(a > a1 + 360) a -= 360;
    // bring a near the span window
    while(a < a0) a += 360;
    while(a > a1) a -= 360;
    // clamp
    if(a < a0) a = a0;
    if(a > a1) a = a1;

    const rad = toRad(a);
    const len = radius - 28;
    const tx = Math.cos(rad) * len;
    const ty = Math.sin(rad) * len;

    const halfWidth = 8;
    const perp = Math.PI / 2;
    const lx = Math.cos(rad + perp) * halfWidth;
    const ly = Math.sin(rad + perp) * halfWidth;
    const rx = Math.cos(rad - perp) * halfWidth;
    const ry = Math.sin(rad - perp) * halfWidth;

    const baseInset = 12;
    const bx = Math.cos(rad) * baseInset;
    const by = Math.sin(rad) * baseInset;

    const leftX = bx + lx, leftY = by + ly;
    const rightX = bx + rx, rightY = by + ry;

    needlePath.setAttribute('d', `M ${leftX.toFixed(2)} ${leftY.toFixed(2)} L ${tx.toFixed(2)} ${ty.toFixed(2)} L ${rightX.toFixed(2)} ${rightY.toFixed(2)} Z`);
  }

  function zoneForValue(v){
    const minVal = Number(minInput.value), maxVal = Number(maxInput.value);
    const gEnd = clamp(Number(greenEndInput.value), minVal, maxVal);
    const yEnd = clamp(Number(yellowEndInput.value), minVal, maxVal);
    if(v <= gEnd) return 'GREEN';
    if(v <= yEnd) return 'YELLOW';
    return 'RED';
  }

  function smoothStep(displayVal, targetVal, alpha){
    return displayVal + (targetVal - displayVal) * alpha;
  }

  // render loop with clamping to [min,max]
  function renderLoop(ts){
    if(!renderLoop.last) renderLoop.last = ts;
    const dt = Math.min(0.1, (ts - renderLoop.last) / 1000);
    renderLoop.last = ts;

    if(mode.value === 'sim' && simRunning){
      simT += dt;
      const minVal = Number(minInput.value), maxVal = Number(maxInput.value);
      // generate a sinusoid centered in range, allow negative min
      const center = (minVal + maxVal) / 2;
      const span = (maxVal - minVal) / 2;
      const base = center + Math.sin(simT * 0.6) * span * 0.35;
      const spike = (Math.sin(simT*2.7) > 0.98) ? (Math.random()*0.3*span) : 0;
      target.value = clamp(base + spike, minVal, maxVal);
      target.ts = Date.now();
    }

    const minVal = Number(minInput.value), maxVal = Number(maxInput.value);
    // ensure target respects new min/max
    target.value = clamp(Number(target.value), minVal, maxVal);

    const alpha = Number(smoothingRange.value);
    display.value = smoothStep(display.value, target.value, alpha);
    display.value = clamp(display.value, minVal, maxVal);

    const rawAngle = valueToAngleDeg(display.value, minVal, maxVal);
    drawNeedleClamped(rawAngle);

    valueText.textContent = (display.value).toFixed(1);
    unitText.textContent = `range ${minVal}..${maxVal}`;
    mValue.textContent = Number.isInteger(display.value) ? String(Math.round(display.value)) : display.value.toFixed(1);
    mMin.textContent = String(minVal);
    mMax.textContent = String(maxVal);
    mZone.textContent = zoneForValue(display.value);

    requestAnimationFrame(renderLoop);
  }

  // UI bindings
  valueRange.addEventListener('input', ()=>{ valueNum.value = valueRange.value; target.value = Number(valueRange.value); target.ts = Date.now(); });
  valueNum.addEventListener('input', ()=>{ valueRange.value = valueNum.value; target.value = Number(valueNum.value); target.ts = Date.now(); });

  minInput.addEventListener('change', ()=>{ buildZonesAndTicks(); target.value = clamp(target.value, Number(minInput.value), Number(maxInput.value)); display.value = clamp(display.value, Number(minInput.value), Number(maxInput.value)); });
  maxInput.addEventListener('change', ()=>{ buildZonesAndTicks(); target.value = clamp(target.value, Number(minInput.value), Number(maxInput.value)); display.value = clamp(display.value, Number(minInput.value), Number(maxInput.value)); });

  greenEndInput.addEventListener('change', buildZonesAndTicks);
  yellowEndInput.addEventListener('change', buildZonesAndTicks);

  smoothingRange.addEventListener('input', ()=>{ smoothingNum.value = smoothingRange.value; });
  smoothingNum.addEventListener('input', ()=>{ smoothingRange.value = smoothingNum.value; });

  mode.addEventListener('change', ()=>{
    if(mode.value === 'manual'){ manualControls.style.display = 'block'; simRunning = false; toggleSim.textContent='Sim paused'; }
    else { manualControls.style.display = 'none'; simRunning = true; toggleSim.textContent='Pause sim'; }
  });

  toggleSim.addEventListener('click', ()=>{ simRunning = !simRunning; toggleSim.textContent = simRunning ? 'Pause sim' : 'Resume sim'; });

  // keyboard nudges and click impulse (clamped)
  window.addEventListener('keydown', (e)=>{
    const nudge = e.shiftKey ? (Number(maxInput.value)-Number(minInput.value))*0.02 : (Number(maxInput.value)-Number(minInput.value))*0.005;
    const minVal = Number(minInput.value), maxVal = Number(maxInput.value);
    if(e.key === 'ArrowUp'){ target.value = clamp(Number(target.value) + nudge, minVal, maxVal); valueRange.value = target.value; valueNum.value = target.value; }
    if(e.key === 'ArrowDown'){ target.value = clamp(Number(target.value) - nudge, minVal, maxVal); valueRange.value = target.value; valueNum.value = target.value; }
  });

  svg.addEventListener('click', (ev)=>{
    const rect = svg.getBoundingClientRect();
    const x = ev.clientX - (rect.left + rect.width/2);
    const impulse = clamp(Math.abs(x)/160 * (Number(maxInput.value)-Number(minInput.value)) * 0.06, 1, (Number(maxInput.value)-Number(minInput.value))*0.4);
    target.value = clamp(Number(target.value) + impulse, Number(minInput.value), Number(maxInput.value));
    valueRange.value = target.value; valueNum.value = target.value;
  });

  // copy svg
  copySvgBtn.addEventListener('click', ()=>{
    const s = new XMLSerializer();
    const clone = svg.cloneNode(true);
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    const out = s.serializeToString(clone);
    navigator.clipboard?.writeText(out).then(()=>{ copySvgBtn.textContent='Copied'; setTimeout(()=>copySvgBtn.textContent='Copy SVG',900); }, ()=>{ copySvgBtn.textContent='Fail'; setTimeout(()=>copySvgBtn.textContent='Copy SVG',900); });
  });

  // export png
  exportPngBtn.addEventListener('click', ()=>{
    const s = new XMLSerializer();
    const clone = svg.cloneNode(true);
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    const out = s.serializeToString(clone);
    const img = new Image();
    const svg64 = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(out);
    img.onload = function(){
      const canvas = document.createElement('canvas');
      const w = img.width || 1200, h = img.height || 700;
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#031022';
      ctx.fillRect(0,0,w,h);
      ctx.drawImage(img,0,0,w,h);
      canvas.toBlob(function(blob){
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'gauge.png'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      });
    };
    img.src = svg64;
  });

  // reset
  resetBtn.addEventListener('click', ()=>{
    target.min = -20; minInput.value = -20;
    target.max = 100; maxInput.value = 100;
    target.value = 34; valueRange.value = 34; valueNum.value = 34;
    greenEndInput.value = 60; yellowEndInput.value = 80;
    smoothingRange.value = 0.18; smoothingNum.value = 0.18;
    buildZonesAndTicks();
  });

  // telemetry API accepts min and max now
  window.applyPressure = function(payload){
    if(!payload || typeof payload !== 'object') return;
    if('min' in payload){ minInput.value = Number(payload.min); }
    if('max' in payload){ maxInput.value = Number(payload.max); }
    if('value' in payload){ target.value = Number(payload.value); valueRange.value = target.value; valueNum.value = target.value; }
    buildZonesAndTicks();
  };

  // initialize
  buildZonesAndTicks();
  // initialize range control to sensible values
  valueRange.min = Number(minInput.value);
  valueRange.max = Number(maxInput.value);
  valueRange.value = target.value;
  valueNum.value = target.value;
  requestAnimationFrame(renderLoop);
})();
</script>
</body>
</html>
```