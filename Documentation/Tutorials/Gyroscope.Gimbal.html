<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Silica Gyroscope Demo</title>
<style>
  :root{
    --bg:#071226; --panel:#071226cc; --accent:#58a6ff; --muted:#9aa7bd;
    --ok:#2ecc71; --warn:#f39c12; --err:#e74c3c;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071226,#041020);color:#e6eef8}
  .wrap{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:center}
  h3{margin:0;font-weight:600}
  .layout{display:flex;gap:14px;width:100%;max-width:1200px}
  .stage{flex:1;min-width:320px;background:linear-gradient(180deg,#061326,#041022);border-radius:10px;padding:18px;display:flex;align-items:center;justify-content:center;box-shadow:0 8px 30px rgba(2,6,23,.6)}
  svg{width:min(80vw,640px);height:min(60vh,640px)}
  .panel{width:380px;background:var(--panel);border-radius:10px;padding:12px;box-sizing:border-box;color:var(--muted);display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:8px;align-items:center}
  label{width:120px;color:#cfe3ff;font-size:13px}
  input[type="range"]{flex:1}
  input[type="number"]{width:72px;padding:6px;border-radius:6px;border:none;background:#071022;color:#dbeefe}
  select,button,input[type="color"]{background:#071022;color:#dbeefe;border-radius:6px;padding:6px;border:none}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe3ff;padding:8px 10px;border-radius:7px;cursor:pointer}
  .metrics{display:flex;gap:8px;flex-wrap:wrap}
  .metric{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-size:13px}
  footer{font-size:12px;color:var(--muted)}
  .hint{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <h3>Silica Gyroscope Demo</h3>
    <div class="layout">
      <div class="stage">
        <svg id="svg" viewBox="-200 -200 400 400" preserveAspectRatio="xMidYMid meet" aria-label="Gyroscope">
          <defs>
            <filter id="soft" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="1" result="b" /><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
          </defs>

          <!-- static group for background rings -->
          <g id="rings"></g>

          <!-- dynamic elements: attitude disk, crosshair, needles -->
          <g id="attitude"></g>

          <!-- overlay for labels -->
          <g id="labels"></g>
        </svg>
      </div>

      <div class="panel" aria-label="Controls">
        <div class="row">
          <label>Source</label>
          <select id="mode"><option value="sim">Simulated</option><option value="manual">Manual</option></select>
        </div>

        <div id="manualControls" style="display:none">
          <div class="row"><label for="pitch">Pitch °</label><input id="pitch" type="range" min="-45" max="45" value="-10"/><input id="pitchn" type="number" value="-10" step="0.1"/></div>
          <div class="row"><label for="roll">Roll °</label><input id="roll" type="range" min="-45" max="45" value="6"/><input id="rolln" type="number" value="6" step="0.1"/></div>
          <div class="row"><label for="heading">Heading °</label><input id="heading" type="range" min="0" max="360" value="45"/><input id="headingn" type="number" value="45" step="0.1"/></div>
          <div class="row"><label for="zoom">Zoom</label><input id="zoom" type="range" min="0.6" max="2.0" step="0.01" value="1"/><input id="zoomn" type="number" value="1" step="0.01"/></div>
        </div>

        <div class="row">
          <label>Auto-sim</label>
          <button id="toggleSim">Pause sim</button>
          <div class="hint">Gyro uses fewer primitives than a full wireframe sphere</div>
        </div>

        <div class="row metrics" id="metricReadout">
          <div class="metric">pitch: <span id="mPitch">-10</span>°</div>
          <div class="metric">roll: <span id="mRoll">6</span>°</div>
          <div class="metric">heading: <span id="mHead">45</span>°</div>
        </div>

        <div style="flex:1"></div>
        <footer>Click the face to toggle crosshair visibility. Use Manual mode for direct control.</footer>
      </div>
    </div>
  </div>

<script>
/* Gyroscope demo
   - Efficient SVG: nodes created once and updated each frame
   - Visual: outer ring, inner gimbals, attitude disk that tilts with pitch/roll, heading needle
*/

(() => {
  const svg = document.getElementById('svg');
  const rings = document.getElementById('rings');
  const attitude = document.getElementById('attitude');
  const labels = document.getElementById('labels');

  // controls
  const mode = document.getElementById('mode');
  const manualControls = document.getElementById('manualControls');
  const pitchR = document.getElementById('pitch'), pitchn = document.getElementById('pitchn');
  const rollR = document.getElementById('roll'), rolln = document.getElementById('rolln');
  const headR = document.getElementById('heading'), headn = document.getElementById('headingn');
  const zoomR = document.getElementById('zoom'), zoomn = document.getElementById('zoomn');
  const toggleSim = document.getElementById('toggleSim');

  const mPitch = document.getElementById('mPitch'), mRoll = document.getElementById('mRoll'), mHead = document.getElementById('mHead');

  // state and display smoothing
  const state = { pitch:-10, roll:6, heading:45, zoom:1 };
  const display = { pitch:state.pitch, roll:state.roll, heading:state.heading, zoom:state.zoom };

  // helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const deg = Math.PI/180;
  function smooth(dst, src, alpha){ return dst + (src - dst) * Math.min(1, alpha); }

  // create static rings once
  function createRings(){
    // clear
    while(rings.firstChild) rings.removeChild(rings.firstChild);

    // outer bezel
    const bezel = document.createElementNS('http://www.w3.org/2000/svg','circle');
    bezel.setAttribute('cx','0'); bezel.setAttribute('cy','0'); bezel.setAttribute('r','140');
    bezel.setAttribute('fill','none'); bezel.setAttribute('stroke','rgba(255,255,255,0.06)'); bezel.setAttribute('stroke-width','6');
    rings.appendChild(bezel);

    // inner gimbals (three rings)
    for(let i=0;i<3;i++){
      const r = 95 - i*20;
      const g = document.createElementNS('http://www.w3.org/2000/svg','circle');
      g.setAttribute('cx','0'); g.setAttribute('cy','0'); g.setAttribute('r', String(r));
      g.setAttribute('fill','none'); g.setAttribute('stroke','rgba(180,200,230,0.06)'); g.setAttribute('stroke-width','2');
      rings.appendChild(g);
    }

    // compass ticks (heading marks)
    for(let a=0;a<360;a+=30){
      const rad = a * deg;
      const x1 = Math.cos(rad)*148, y1 = -Math.sin(rad)*148;
      const x2 = Math.cos(rad)*134, y2 = -Math.sin(rad)*134;
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', String(x1)); line.setAttribute('y1', String(y1));
      line.setAttribute('x2', String(x2)); line.setAttribute('y2', String(y2));
      line.setAttribute('stroke','rgba(200,220,255,0.08)'); line.setAttribute('stroke-width','1.5');
      rings.appendChild(line);
      // cardinal labels
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      const lab = (a===0)?'N':(a===90)?'E':(a===180)?'S':(a===270)?'W':String(a);
      label.setAttribute('x', String(Math.cos(rad)*122)); label.setAttribute('y', String(-Math.sin(rad)*122+4));
      label.setAttribute('fill','#cfe3ff'); label.setAttribute('font-size','11'); label.setAttribute('text-anchor','middle');
      label.textContent = lab;
      rings.appendChild(label);
    }
  }

  // create dynamic nodes once
  const nodes = {};
  function createDynamicNodes(){
    // clear attitude group
    while(attitude.firstChild) attitude.removeChild(attitude.firstChild);
    while(labels.firstChild) labels.removeChild(labels.firstChild);

    // attitude disk (represents horizon) as group that will be tilted
    const diskGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    diskGroup.setAttribute('id','diskGroup');
    attitude.appendChild(diskGroup);
    nodes.diskGroup = diskGroup;

    // sky and ground arcs (two rects masked) -- we'll draw a circle clipped and rotate the group to simulate pitch/roll
    const sky = document.createElementNS('http://www.w3.org/2000/svg','rect');
    sky.setAttribute('x','-160'); sky.setAttribute('y','-160'); sky.setAttribute('width','320'); sky.setAttribute('height','320');
    sky.setAttribute('fill','#11324a'); diskGroup.appendChild(sky);
    const ground = document.createElementNS('http://www.w3.org/2000/svg','rect');
    ground.setAttribute('x','-160'); ground.setAttribute('y','-160'); ground.setAttribute('width','320'); ground.setAttribute('height','320');
    ground.setAttribute('fill','#2d1f12'); diskGroup.appendChild(ground);

    // circular mask so sky/ground appear inside a circle
    const clipId = 'diskClip';
    const clip = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
    clip.setAttribute('id', clipId);
    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx','0'); circ.setAttribute('cy','0'); circ.setAttribute('r','100');
    clip.appendChild(circ);
    // clip must be in defs; create or reuse
    let defs = svg.querySelector('defs');
    if(!defs){ defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
    // remove previous clip if exists then add new
    const old = defs.querySelector('#'+clipId);
    if(old) defs.removeChild(old);
    defs.appendChild(clip);
    diskGroup.setAttribute('clip-path','url(#'+clipId+')');

    // horizon line (thin) inside diskGroup
    const horizon = document.createElementNS('http://www.w3.org/2000/svg','line');
    horizon.setAttribute('x1','-200'); horizon.setAttribute('y1','0'); horizon.setAttribute('x2','200'); horizon.setAttribute('y2','0');
    horizon.setAttribute('stroke','#e6eef8'); horizon.setAttribute('stroke-width','1.6'); horizon.setAttribute('opacity','0.9');
    diskGroup.appendChild(horizon);
    nodes.horizon = horizon;

    // crosshair on disk (roll/pitch reference)
    const cross = document.createElementNS('http://www.w3.org/2000/svg','g');
    cross.setAttribute('id','cross');
    const ch1 = document.createElementNS('http://www.w3.org/2000/svg','line');
    ch1.setAttribute('x1','-60'); ch1.setAttribute('y1','0'); ch1.setAttribute('x2','60'); ch1.setAttribute('y2','0'); ch1.setAttribute('stroke','#cfe3ff'); ch1.setAttribute('stroke-width','1.2');
    const ch2 = document.createElementNS('http://www.w3.org/2000/svg','line');
    ch2.setAttribute('x1','0'); ch2.setAttribute('y1','-30'); ch2.setAttribute('x2','0'); ch2.setAttribute('y2','30'); ch2.setAttribute('stroke','#cfe3ff'); ch2.setAttribute('stroke-width','1.2');
    cross.appendChild(ch1); cross.appendChild(ch2);
    attitude.appendChild(cross);
    nodes.cross = cross;

    // heading needle (outside disk) as group rotated by heading
    const needleGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    needleGroup.setAttribute('id','needleGroup');
    attitude.appendChild(needleGroup);
    const needle = document.createElementNS('http://www.w3.org/2000/svg','path');
    needle.setAttribute('d','M0,-146 L6,-132 L0,-120 L-6,-132 Z');
    needle.setAttribute('fill','#ffcc66'); needle.setAttribute('stroke','rgba(0,0,0,0.2)'); needle.setAttribute('stroke-width','0.6');
    needleGroup.appendChild(needle);
    nodes.needleGroup = needleGroup;

    // heading text label
    const headingLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
    headingLabel.setAttribute('x','0'); headingLabel.setAttribute('y','175'); headingLabel.setAttribute('text-anchor','middle');
    headingLabel.setAttribute('fill','#cfe3ff'); headingLabel.setAttribute('font-size','14'); headingLabel.textContent = 'HDG 000';
    labels.appendChild(headingLabel);
    nodes.headingLabel = headingLabel;
  }

  // initial creation
  createRings();
  createDynamicNodes();

  // projection helpers (small linear approximations)
  function applyAttitudeTransform(){
    // display contains smoothed pitch/roll/heading/zoom
    const dPitch = display.pitch;
    const dRoll = display.roll;
    const dHeading = display.heading;

    // diskGroup tilts with pitch and roll (we approximate with 2D transform: translate for pitch and rotate for roll; it's a visual cue not full 3D)
    const diskGroup = nodes.diskGroup;
    const tx = clamp(dPitch * 1.6, -80, 80); // translate horizon vertically to simulate pitch
    const ry = clamp(dRoll, -45, 45); // roll rotates the disk
    diskGroup.setAttribute('transform', `translate(0,${tx}) rotate(${ -ry }) scale(${display.zoom})`);

    // crosshair rotates opposite to disk roll to remain stable relative to world when desired (here we rotate with disk for simpler gimbal feel)
    nodes.cross.setAttribute('transform', `rotate(${ -ry }) scale(${display.zoom})`);

    // heading needle rotates by heading
    nodes.needleGroup.setAttribute('transform', `rotate(${display.heading}) scale(${display.zoom})`);

    // update heading label
    nodes.headingLabel.textContent = 'HDG ' + String(Math.round(display.heading)).padStart(3,'0');
    nodes.headingLabel.setAttribute('transform', `scale(${display.zoom})`);
  }

  // smoothing function
  function smoothDisplay(alpha = 0.16){
    display.pitch = smooth(display.pitch, state.pitch, alpha);
    display.roll = smooth(display.roll, state.roll, alpha);
    // heading wrap-safe
    const cur = display.heading;
    const diff = (((state.heading - cur + 540) % 360) - 180);
    display.heading = (cur + diff * Math.min(1, alpha) + 360) % 360;
    display.zoom = smooth(display.zoom, state.zoom, alpha);
  }

  // UI bindings
  function bind(range, num, field){
    range.addEventListener('input', ()=>{ num.value = range.value; state[field] = parseFloat(range.value); updateMetrics(); });
    num.addEventListener('input', ()=>{ range.value = num.value; state[field] = parseFloat(num.value); updateMetrics(); });
  }
  bind(pitchR, pitchn, 'pitch');
  bind(rollR, rolln, 'roll');
  bind(headR, headn, 'heading');
  bind(zoomR, zoomn, 'zoom');

  function updateMetrics(){
    mPitch.textContent = state.pitch.toFixed(1);
    mRoll.textContent = state.roll.toFixed(1);
    mHead.textContent = state.heading.toFixed(1);
  }

  mode.addEventListener('change', ()=>{
    if(mode.value === 'manual'){ manualControls.style.display='block'; simRunning = false; toggleSim.textContent='Sim paused'; }
    else { manualControls.style.display='none'; simRunning = true; toggleSim.textContent='Pause sim'; }
  });

  toggleSim.addEventListener('click', ()=>{ simRunning = !simRunning; toggleSim.textContent = simRunning ? 'Pause sim' : 'Resume sim'; });

  // click toggles crosshair visibility
  svg.addEventListener('click', ()=>{ const cur = nodes.cross.getAttribute('display') || 'inline'; nodes.cross.setAttribute('display', cur === 'none' ? 'inline' : 'none'); });

  // simulator
  let simT = 0;
  function simulate(dt){
    simT += dt * 0.7;
    const pitch = -10 + Math.sin(simT * 0.9) * 10;
    const roll = 6 + Math.cos(simT * 0.6) * 12;
    const heading = (simT * 15) % 360;
    return { pitch, roll, heading };
  }

  // main loop
  let lastTs = performance.now();
  let simRunning = true;

  function loop(ts){
    const dt = Math.min(0.1, (ts - lastTs) / 1000);
    lastTs = ts;

    if(mode.value === 'sim' && simRunning){
      const raw = simulate(dt);
      state.pitch = raw.pitch;
      state.roll = raw.roll;
      state.heading = raw.heading;
      updateMetrics();
    }

    // smooth and apply transforms
    smoothDisplay(0.18);
    applyAttitudeTransform();

    requestAnimationFrame(loop);
  }

  // initial UI reflect
  updateMetrics();
  requestAnimationFrame(loop);

  // expose for debugging
  window.__gyro = { state, display };

})();
</script>
</body>
</html>
```