/*

EBNF  to be viewed with https://www.bottlecaps.de/rr/ui

Here is a manually conversion using as base
sql-2016-foundation-grammar.txt from https://github.com/JakeWheat/sql-overview
that we can see a railroad diagram for the grammar by copying
and paste the EBNF shown bellow on https://www.bottlecaps.de/rr/ui
in the tab Edit Grammar then switching to the tab View Diagram.

Obs: It's a heavy diagram that takes time and resources to view.

Non reserved words appear with * as suffix, ex: SUBSTRING -> SUBSTRING*.

You can navigate through the grammar by clicking the rectangular boxes.

*/


/*
22 Direct invocation of SQL


22.1 direct_SQL_statement

Function
Specify direct execution of SQL.


Format
*/
direct_SQL_statement ::=
  directly_executable_statement semicolon

directly_executable_statement ::=
    direct_SQL_data_statement
  | SQL_schema_statement
  | SQL_transaction_statement
  | SQL_connection_statement
  | SQL_session_statement
  | direct_implementation_defined_statement

direct_SQL_data_statement ::=
    delete_statement__searched
  | direct_select_statement__multiple_rows
  | insert_statement
  | update_statement__searched
  | truncate_table_statement
  | merge_statement
  | temporary_table_declaration

direct_implementation_defined_statement ::=
  "!! See the Syntax Rules."


/*
5 Lexical elements


5.1     SQL_terminal_character

Function
Define the terminal symbols of the SQL language and the elements of strings.

Format
*/
SQL_terminal_character ::=
  SQL_language_character

SQL_language_character ::=
    simple_Latin_letter
  | digit
  | SQL_special_character

simple_Latin_letter ::=
    simple_Latin_upper_case_letter
  | simple_Latin_lower_case_letter

simple_Latin_upper_case_letter ::=
    "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O"
  | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

simple_Latin_lower_case_letter ::=
    "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o"
  | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

digit ::=
    "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

SQL_special_character ::=
      space
  |   double_quote
  |   percent
  |   ampersand
  |   quote
  |   left_paren
  |   right_paren
  |   asterisk
  |   plus_sign
  |   comma
  |   minus_sign
  |   period
  |   solidus
  |   colon
  |   semicolon
  |   less_than_operator
  |   equals_operator
  |   greater_than_operator
  |   question_mark
  |   left_bracket
  |   right_bracket
  |   circumflex
  |   underscore
  |   vertical_bar
  |   left_brace
  |   right_brace
  |   dollar_sign
  |   apostrophe

space ::=
  "!! See the Syntax Rules."

double_quote ::=
  '"'

percent ::=
  '%'

ampersand ::=
  '&'

quote ::=
  "'"

left_paren ::=
  '('

right_paren ::=
  ')'

asterisk ::=
  '*'

plus_sign ::=
  '+'

comma ::=
  ','

minus_sign ::=
  '-'

period ::=
  '.'

solidus ::=
  '/'

reverse_solidus ::=
  '\'

colon ::=
  ':'

semicolon ::=
  ';'

less_than_operator ::=
  '<'

equals_operator ::=
  '='

greater_than_operator ::=
  '>'

question_mark ::=
  '?'

left_bracket_or_trigraph ::=
    left_bracket
  | left_bracket_trigraph

right_bracket_or_trigraph ::=
    right_bracket
  | right_bracket_trigraph

left_bracket ::=
  '['

left_bracket_trigraph ::=
  "??("

right_bracket ::=
  ']'

right_bracket_trigraph ::=
  "??)"

circumflex ::=
  '^'

underscore ::=
  '_'

vertical_bar ::=
  '|'

left_brace ::=
  '{'

right_brace ::=
  '}'

dollar_sign ::=
  '$'

apostrophe ::=
  "'"
/*
5.2     token and separator

Function
Specify lexical units (tokens and separators) that participate in SQL language.


Format
*/
token ::=
    nondelimiter_token
  | delimiter_token

nondelimiter_token ::=
    regular_identifier
  | key_word
  | unsigned_numeric_literal
  | national_character_string_literal
  | binary_string_literal
  | large_object_length_token
  | Unicode_delimited_identifier
  | Unicode_character_string_literal
  | SQL_language_identifier

regular_identifier ::=
  identifier_body

identifier_body ::=
  identifier_start ( identifier_part )*

identifier_part ::=
    identifier_start
  | identifier_extend
/*
identifier_start ::=
  "!! See the Syntax Rules."

identifier_extend ::=
  "!! See the Syntax Rules."
*/
large_object_length_token ::=
  digit+ multiplier

multiplier ::=
    "K"
  | "M"
  | "G"
  | "T"
  | "P"

delimited_identifier ::=
  double_quote delimited_identifier_body double_quote

delimited_identifier_body ::=
  delimited_identifier_part+

delimited_identifier_part ::=
    nondoublequote_character
  | doublequote_symbol

Unicode_delimited_identifier ::=
  U ampersand double_quote Unicode_delimiter_body double_quote
      Unicode_escape_specifier

Unicode_escape_specifier ::=
  ( UESCAPE quote Unicode_escape_character quote )?

Unicode_delimiter_body ::=
  Unicode_identifier_part+

Unicode_identifier_part ::=
    delimited_identifier_part
  | Unicode_escape_value

Unicode_escape_value ::=
    Unicode_4_digit_escape_value
  | Unicode_6_digit_escape_value
  | Unicode_character_escape_value

Unicode_4_digit_escape_value ::=
  Unicode_escape_character hexit hexit hexit hexit

Unicode_6_digit_escape_value ::=
  Unicode_escape_character plus_sign
      hexit hexit hexit hexit hexit hexit

Unicode_character_escape_value ::=
  Unicode_escape_character Unicode_escape_character

Unicode_escape_character ::=
  "!! See the Syntax Rules."

nondoublequote_character ::=
  "!! See the Syntax Rules."

doublequote_symbol ::=
  '""' //!! two consecutive double quote characters

delimiter_token ::=
    character_string_literal
  | date_string
  | time_string
  | timestamp_string
  | interval_string
  | delimited_identifier
  | SQL_special_character
  | not_equals_operator
  | greater_than_or_equals_operator
  | less_than_or_equals_operator
  | concatenation_operator
  | right_arrow
  | left_bracket_trigraph
  | right_bracket_trigraph
  | double_colon
  | double_period
  | named_argument_assignment_token
  | left_brace_minus
  | right_minus_brace

not_equals_operator ::=
  "<>"

greater_than_or_equals_operator ::=
  ">="

less_than_or_equals_operator ::=
  "<="

concatenation_operator ::=
  "||"

right_arrow ::=
  "->"

double_colon ::=
  "::"

double_period ::=
  ".."

named_argument_assignment_token ::=
  "=>"

left_brace_minus ::=
  "{-"

right_minus_brace ::=
  "-}"

separator ::=
  ( comment | white_space )+
/*
white_space ::=
  "!! See the Syntax Rules."
*/
comment ::=
    simple_comment
  | bracketed_comment

simple_comment ::=
  simple_comment_introducer comment_character* newline

simple_comment_introducer ::=
  minus_sign minus_sign

bracketed_comment ::=
  bracketed_comment_introducer
      bracketed_comment_contents
      bracketed_comment_terminator

bracketed_comment_introducer ::=
  /*

bracketed_comment_terminator ::=
  */

bracketed_comment_contents ::=
  ( comment_character | separator )+ "!! See the Syntax Rules."

comment_character ::=
    nonquote_character
  | quote
/*
newline ::=
  "!! See the Syntax Rules."
*/
key_word ::=
    reserved_word
  | non_reserved_word

non_reserved_word ::=
    A | ABSOLUTE | ACTION | ADA | ADD | ADMIN | AFTER | ALWAYS | ASC
  | ASSERTION | ASSIGNMENT | ATTRIBUTE | ATTRIBUTES

  | BEFORE | BERNOULLI | BREADTH

  | C | CASCADE | CATALOG | CATALOG_NAME | CHAIN | CHAINING | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME | CHARACTER_SET_SCHEMA | CHARACTERISTICS | CHARACTERS
  | CLASS_ORIGIN | COBOL | COLLATION | COLLATION_CATALOG | COLLATION_NAME | COLLATION_SCHEMA
  | COLUMNS | COLUMN_NAME | COMMAND_FUNCTION | COMMAND_FUNCTION_CODE | COMMITTED
  | CONDITIONAL | CONDITION_NUMBER | CONNECTION | CONNECTION_NAME | CONSTRAINT_CATALOG
  | CONSTRAINT_NAME | CONSTRAINT_SCHEMA | CONSTRAINTS | CONSTRUCTOR
  | CONTINUE | CURSOR_NAME

  | DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DEFAULTS | DEFERRABLE
  | DEFERRED | DEFINED | DEFINER | DEGREE | DEPTH | DERIVED | DESC | DESCRIBE_CATALOG
  | DESCRIBE_NAME | DESCRIBE_PROCEDURE_SPECIFIC_CATALOG
  | DESCRIBE_PROCEDURE_SPECIFIC_NAME | DESCRIBE_PROCEDURE_SPECIFIC_SCHEMA
  | DESCRIBE_SCHEMA | DESCRIPTOR
  | DIAGNOSTICS | DISPATCH | DOMAIN | DYNAMIC_FUNCTION | DYNAMIC_FUNCTION_CODE

  | ENCODING | ENFORCED | ERROR | EXCLUDE | EXCLUDING | EXPRESSION

  | FINAL | FINISH | FINISH_CATALOG | FINISH_NAME | FINISH_PROCEDURE_SPECIFIC_CATALOG
  | FINISH_PROCEDURE_SPECIFIC_NAME | FINISH_PROCEDURE_SPECIFIC_SCHEMA
  | FINISH_SCHEMA | FIRST | FLAG | FOLLOWING | FORMAT | FORTRAN | FOUND | FULFILL
  | FULFILL_CATALOG | FULFILL_NAME | FULFILL_PROCEDURE_SPECIFIC_CATALOG
  | FULFILL_PROCEDURE_SPECIFIC_NAME | FULFILL_PROCEDURE_SPECIFIC_SCHEMA | FULFILL_SCHEMA

  | G | GENERAL | GENERATED | GO | GOTO | GRANTED

  | HAS_PASS_THROUGH_COLUMNS | HAS_PASS_THRU_COLS | HIERARCHY

  | IGNORE | IMMEDIATE | IMMEDIATELY | IMPLEMENTATION | INCLUDING | INCREMENT | INITIALLY
  | INPUT | INSTANCE | INSTANTIABLE | INSTEAD | INVOKER | ISOLATION | IS_PRUNABLE

  | JSON

  | K | KEEP | KEY | KEYS | KEY_MEMBER | KEY_TYPE

  | LAST | LENGTH | LEVEL | LOCATOR

  | M | MAP | MATCHED | MAXVALUE | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT | MINVALUE | MORE | MUMPS

  | NAME | NAMES | NESTED | NESTING | NEXT | NFC | NFD | NFKC | NFKD
  | NORMALIZED | NULLABLE | NULLS | NUMBER

  | OBJECT | OCTETS | OPTION | OPTIONS | ORDERING | ORDINALITY | OTHERS
  | OUTPUT | OVERFLOW | OVERRIDING

  | P | PAD | PARAMETER_MODE | PARAMETER_NAME | PARAMETER_ORDINAL_POSITION
  | PARAMETER_SPECIFIC_CATALOG | PARAMETER_SPECIFIC_NAME | PARAMETER_SPECIFIC_SCHEMA
  | PARTIAL | PASCAL | PASS | PASSING | PAST | PATH | PLACING | PLAN | PLI
  | PRECEDING | PRESERVE | PRIOR | PRIVATE | PRIVATE_PARAMETERS | PRIVATE_PARAMS_S
  | PRIVILEGES | PRUNE | PUBLIC

  | QUOTES

  | READ | RELATIVE | REPEATABLE | RESPECT | RESTART | RESTRICT | RETURNED_CARDINALITY
  | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE | RETURNING
  | RETURNS_ONLY_PASS_THROUGH | RET_ONLY_PASS_THRU | ROLE | ROUTINE
  | ROUTINE_CATALOG | ROUTINE_NAME | ROUTINE_SCHEMA | ROW_COUNT

  | SCALAR | SCALE | SCHEMA | SCHEMA_NAME | SCOPE_CATALOG | SCOPE_NAME
  | SCOPE_SCHEMA | SECTION | SECURITY | SELF | SEQUENCE | SERIALIZABLE | SERVER_NAME
  | SESSION | SETS | SIMPLE | SIZE | SOURCE | SPACE | SPECIFIC_NAME | START_CATALOG
  | START_NAME | START_PROCEDURE_SPECIFIC_CATALOG | START_PROCEDURE_SPECIFIC_NAME
  | START_PROCEDURE_SPECIFIC_SCHEMA | START_SCHEMA | STATE | STATEMENT
  | STRING | STRUCTURE | STYLE | SUBCLASS_ORIGIN

  | T | TABLE_NAME | TABLE_SEMANTICS | TEMPORARY | THROUGH | TIES | TOP_LEVEL_COUNT
  | TRANSACTION | TRANSACTION_ACTIVE | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK | TRANSFORM | TRANSFORMS | TRIGGER_CATALOG | TRIGGER_NAME
  | TRIGGER_SCHEMA | TYPE

  | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNDER | UNNAMED | USAGE
  | USER_DEFINED_TYPE_CATALOG | USER_DEFINED_TYPE_CODE | USER_DEFINED_TYPE_NAME
  | USER_DEFINED_TYPE_SCHEMA | UTF16 | UTF32 | UTF8

  | VIEW

  | WORK | WRAPPER | WRITE

  | ZONE

reserved_word ::=
    ABS | ACOS | ALL | ALLOCATE | ALTER | AND | ANY | ARE | ARRAY | ARRAY_AGG
  | ARRAY_MAX_CARDINALITY | AS | ASENSITIVE | ASIN | ASYMMETRIC | AT | ATAN
  | ATOMIC | AUTHORIZATION | AVG

  | BEGIN | BEGIN_FRAME | BEGIN_PARTITION | BETWEEN | BIGINT | BINARY
  | BLOB | BOOLEAN | BOTH | BY

  | CALL | CALLED | CARDINALITY | CASCADED | CASE | CAST | CEIL | CEILING
  | CHAR | CHAR_LENGTH | CHARACTER | CHARACTER_LENGTH | CHECK | CLASSIFIER | CLOB
  | CLOSE | COALESCE | COLLATE | COLLECT | COLUMN | COMMIT | CONDITION | CONNECT
  | CONSTRAINT | CONTAINS | CONVERT | COPY | CORR | CORRESPONDING | COS | COSH
  | COUNT | COVAR_POP | COVAR_SAMP | CREATE | CROSS | CUBE | CUME_DIST | CURRENT
  | CURRENT_CATALOG | CURRENT_DATE | CURRENT_DEFAULT_TRANSFORM_GROUP
  | CURRENT_PATH | CURRENT_ROLE | CURRENT_ROW | CURRENT_SCHEMA | CURRENT_TIME
  | CURRENT_TIMESTAMP | CURRENT_PATH | CURRENT_ROLE | CURRENT_TRANSFORM_GROUP_FOR_TYPE
  | CURRENT_USER | CURSOR | CYCLE

  | DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECFLOAT | DECLARE | DEFAULT | DEFINE
  | DELETE | DENSE_RANK | DEREF | DESCRIBE | DETERMINISTIC | DISCONNECT | DISTINCT
  | DOUBLE | DROP | DYNAMIC

  | EACH | ELEMENT | ELSE | EMPTY | END | END_FRAME | END_PARTITION | END-EXEC
  | EQUALS | ESCAPE | EVERY | EXCEPT | EXEC | EXECUTE | EXISTS | EXP
  | EXTERNAL | EXTRACT

  | FALSE | FETCH | FILTER | FIRST_VALUE | FLOAT | FLOOR | FOR | FOREIGN
  | FRAME_ROW | FREE | FROM | FULL | FUNCTION | FUSION

  | GET | GLOBAL | GRANT | GROUP | GROUPING | GROUPS

  | HAVING | HOLD | HOUR

  | IDENTITY | IN | INDICATOR | INITIAL | INNER | INOUT | INSENSITIVE | INSERT
  | INT | INTEGER | INTERSECT | INTERSECTION | INTERVAL | INTO | IS

  | JOIN | JSON_ARRAY | JSON_ARRAYAGG | JSON_EXISTS | JSON_OBJECT
  | JSON_OBJECTAGG | JSON_QUERY | JSON_TABLE | JSON_TABLE_PRIMITIVE | JSON_VALUE

  | LAG | LANGUAGE | LARGE | LAST_VALUE | LATERAL | LEAD | LEADING | LEFT | LIKE
  | LIKE_REGEX | LISTAGG | LN | LOCAL | LOCALTIME | LOCALTIMESTAMP | LOG | LOG10 | LOWER

  | MATCH | MATCH_NUMBER | MATCH_RECOGNIZE | MATCHES | MAX | MEMBER
  | MERGE | METHOD | MIN | MINUTE | MOD | MODIFIES | MODULE | MONTH | MULTISET

  | NATIONAL | NATURAL | NCHAR | NCLOB | NEW | NO | NONE | NORMALIZE | NOT
  | NTH_VALUE | NTILE | NULL | NULLIF | NUMERIC

  | OCTET_LENGTH | OCCURRENCES_REGEX | OF | OFFSET | OLD | OMIT | ON | ONE
  | ONLY | OPEN | OR | ORDER | OUT | OUTER | OVER | OVERLAPS | OVERLAY

  | PARAMETER | PARTITION | PATTERN | PER | PERCENT | PERCENT_RANK
  | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PORTION | POSITION | POSITION_REGEX
  | POWER | PRECEDES | PRECISION | PREPARE | PRIMARY | PROCEDURE | PTF

  | RANGE | RANK | READS | REAL | RECURSIVE | REF | REFERENCES | REFERENCING
  | REGR_AVGX | REGR_AVGY | REGR_COUNT | REGR_INTERCEPT | REGR_R2 | REGR_SLOPE
  | REGR_SXX | REGR_SXY | REGR_SYY | RELEASE | RESULT | RETURN | RETURNS
  | REVOKE | RIGHT | ROLLBACK | ROLLUP | ROW | ROW_NUMBER | ROWS | RUNNING

  | SAVEPOINT | SCOPE | SCROLL | SEARCH | SECOND | SEEK | SELECT | SENSITIVE
  | SESSION_USER | SET | SHOW | SIMILAR | SIN | SINH | SKIP | SMALLINT | SOME | SPECIFIC
  | SPECIFICTYPE | SQL | SQLEXCEPTION | SQLSTATE | SQLWARNING | SQRT | START
  | STATIC | STDDEV_POP | STDDEV_SAMP | SUBMULTISET | SUBSET | SUBSTRING
  | SUBSTRING_REGEX | SUCCEEDS | SUM | SYMMETRIC | SYSTEM | SYSTEM_TIME
  | SYSTEM_USER

  | TABLE | TABLESAMPLE | TAN | TANH | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR
  | TIMEZONE_MINUTE | TO | TRAILING | TRANSLATE | TRANSLATE_REGEX | TRANSLATION | TREAT
  | TRIGGER | TRIM | TRIM_ARRAY | TRUE | TRUNCATE

  | UESCAPE | UNION | UNIQUE | UNKNOWN | UNNEST | UPDATE    | UPPER | USER | USING

  | VALUE | VALUES | VALUE_OF | VAR_POP | VAR_SAMP | VARBINARY
  | VARCHAR | VARYING | VERSIONING

  | WHEN | WHENEVER | WHERE | WIDTH_BUCKET | WINDOW | WITH | WITHIN | WITHOUT

  | YEAR
/*
5.3     literal

Function
Specify a non-null value.


Format
*/
literal ::=
    signed_numeric_literal
  | general_literal

unsigned_literal ::=
    unsigned_numeric_literal
  | general_literal

general_literal ::=
    character_string_literal
  | national_character_string_literal
  | Unicode_character_string_literal
  | binary_string_literal
  | datetime_literal
  | interval_literal
  | boolean_literal

character_string_literal ::=
  ( introducer character_set_specification )?
      quote character_representation* quote
      ( separator quote character_representation* quote )*

introducer ::=
  underscore

character_representation ::=
    nonquote_character
  | quote_symbol
/*
nonquote_character ::=
  "!! See the Syntax Rules."
*/
quote_symbol ::=
  quote quote

national_character_string_literal ::=
  'N' quote character_representation*
      quote ( separator quote character_representation* quote )*

Unicode_character_string_literal ::=
  ( introducer character_set_specification )?
      'U' ampersand quote Unicode_representation* quote
      ( separator quote Unicode_representation* quote )*
      Unicode_escape_specifier

Unicode_representation ::=
    character_representation
  | Unicode_escape_value

binary_string_literal ::=
  'X' quote space* ( hexit space* hexit space* )* quote
      ( separator quote space* ( hexit space*
      hexit space* )* quote )*

hexit ::=
    digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f"

signed_numeric_literal ::=
  sign? unsigned_numeric_literal

unsigned_numeric_literal ::=
    exact_numeric_literal
  | approximate_numeric_literal

exact_numeric_literal ::=
    unsigned_integer ( period unsigned_integer? )?
  | period unsigned_integer

sign ::=
    plus_sign
  | minus_sign

approximate_numeric_literal ::=
  mantissa 'E' exponent

mantissa ::=
  exact_numeric_literal

exponent ::=
  signed_integer

signed_integer ::=
  sign? unsigned_integer

unsigned_integer ::=
  digit+

datetime_literal ::=
    date_literal
  | time_literal
  | timestamp_literal

date_literal ::=
  DATE date_string

time_literal ::=
  TIME time_string

timestamp_literal ::=
  TIMESTAMP timestamp_string

date_string ::=
  quote unquoted_date_string quote

time_string ::=
  quote unquoted_time_string quote

timestamp_string ::=
  quote unquoted_timestamp_string quote

time_zone_interval ::=
  sign hours_value colon minutes_value

date_value ::=
  years_value minus_sign months_value minus_sign days_value

time_value ::=
  hours_value colon minutes_value colon seconds_value

interval_literal ::=
  INTERVAL sign? interval_string interval_qualifier

interval_string ::=
  quote unquoted_interval_string quote

unquoted_date_string ::=
  date_value

unquoted_time_string ::=
  time_value time_zone_interval?

unquoted_timestamp_string ::=
  unquoted_date_string space unquoted_time_string

unquoted_interval_string ::=
  sign? ( year_month_literal | day_time_literal )

year_month_literal ::=
    years_value ( minus_sign months_value )?
  | months_value

day_time_literal ::=
    day_time_interval
  | time_interval

day_time_interval ::=
  days_value ( space hours_value ( colon minutes_value
      ( colon seconds_value )? )? )?

time_interval ::=
    hours_value ( colon minutes_value ( colon seconds_value )? )?
  | minutes_value ( colon seconds_value )?
  | seconds_value

years_value ::=
  datetime_value

months_value ::=
  datetime_value

days_value ::=
  datetime_value

hours_value ::=
  datetime_value

minutes_value ::=
  datetime_value

seconds_value ::=
  seconds_integer_value ( period  seconds_fraction? )?

seconds_integer_value ::=
  unsigned_integer

seconds_fraction ::=
  unsigned_integer

datetime_value ::=
  unsigned_integer

boolean_literal ::=
    TRUE
  | FALSE
  | UNKNOWN
/*
5.4    Names and identifiers

Function
Specify names.


Format
*/
identifier ::=
  actual_identifier

actual_identifier ::=
    regular_identifier
  | delimited_identifier
  | Unicode_delimited_identifier

SQL_language_identifier ::=
  SQL_language_identifier_start SQL_language_identifier_part*

SQL_language_identifier_start ::=
  simple_Latin_letter

SQL_language_identifier_part ::=
    simple_Latin_letter
  | digit
  | underscore

authorization_identifier ::=
    role_name
  | user_identifier

table_name ::=
  local_or_schema_qualified_name

domain_name ::=
  schema_qualified_name

schema_name ::=
  ( catalog_name period )? unqualified_schema_name

unqualified_schema_name ::=
  identifier

catalog_name ::=
  identifier

schema_qualified_name ::=
  ( schema_name period )? qualified_identifier

local_or_schema_qualified_name ::=
  ( local_or_schema_qualifier period )? qualified_identifier

local_or_schema_qualifier ::=
    schema_name
  | local_qualifier

qualified_identifier ::=
  identifier

column_name ::=
  identifier

correlation_name ::=
  identifier

query_name ::=
  identifier

SQL_client_module_name ::=
  identifier

procedure_name ::=
  identifier

schema_qualified_routine_name ::=
  schema_qualified_name

method_name ::=
  identifier

specific_name ::=
  schema_qualified_name

cursor_name ::=
  local_qualified_name

local_qualified_name ::=
  ( local_qualifier period )? qualified_identifier

local_qualifier ::=
  MODULE

host_parameter_name ::=
  colon identifier

SQL_parameter_name ::=
  identifier

constraint_name ::=
  schema_qualified_name

external_routine_name ::=
    identifier
  | character_string_literal

trigger_name ::=
  schema_qualified_name

collation_name ::=
  schema_qualified_name

character_set_name ::=
  ( schema_name period )? SQL_language_identifier

transliteration_name ::=
  schema_qualified_name

transcoding_name ::=
  schema_qualified_name

schema_resolved_user_defined_type_name ::=
  user_defined_type_name

user_defined_type_name ::=
  ( schema_name period )? qualified_identifier

attribute_name ::=
  identifier

field_name ::=
  identifier

savepoint_name ::=
  identifier

sequence_generator_name ::=
  schema_qualified_name

role_name ::=
  identifier

user_identifier ::=
  identifier

connection_name ::=
  simple_value_specification

SQL_server_name ::=
  simple_value_specification

connection_user_name ::=
  simple_value_specification

SQL_statement_name ::=
    statement_name
  | extended_statement_name

statement_name ::=
  identifier

extended_statement_name ::=
  scope_option? simple_value_specification

dynamic_cursor_name ::=
    conventional_dynamic_cursor_name
  | PTF_cursor_name

conventional_dynamic_cursor_name ::=
    cursor_name
  | extended_cursor_name

extended_cursor_name ::=
  scope_option? simple_value_specification

PTF_cursor_name ::=
  PTF simple_value_specification

descriptor_name ::=
    conventional_descriptor_name
  | PTF_descriptor_name

conventional_descriptor_name ::=
    non_extended_descriptor_name
  | extended_descriptor_name

non_extended_descriptor_name ::=
  identifier

extended_descriptor_name ::=
  scope_option? simple_value_specification

scope_option ::=
    GLOBAL
  | LOCAL

PTF_descriptor_name ::=
  PTF simple_value_specification

window_name ::=
  identifier

row_pattern_variable_name ::=
  correlation_name

measure_name ::=
  identifier
/*
6 Scalar expressions


6.1     data_type

Function
Specify a data type.


Format
*/
data_type ::=
    predefined_type
  | row_type
  | path_resolved_user_defined_type_name
  | reference_type
  | collection_type

predefined_type ::=
      character_string_type ( CHARACTER SET character_set_specification )?
          collate_clause?
  |   national_character_string_type collate_clause?
  |   binary_string_type
  |   numeric_type
  |   boolean_type
  |   datetime_type
  |   interval_type

character_string_type ::=
    CHARACTER ( left_paren character_length right_paren )?
  | CHAR ( left_paren character_length right_paren )?
  | CHARACTER VARYING left_paren character_length right_paren
  | CHAR VARYING left_paren character_length right_paren
  | VARCHAR left_paren character_length right_paren
  | character_large_object_type

character_large_object_type ::=
    CHARACTER LARGE OBJECT ( left_paren character_large_object_length right_paren )?
  | CHAR LARGE OBJECT ( left_paren character_large_object_length right_paren )?
  | CLOB ( left_paren character_large_object_length right_paren )?

national_character_string_type ::=
    NATIONAL CHARACTER ( left_paren character_length right_paren )?
  | NATIONAL CHAR ( left_paren character_length right_paren )?
  | NCHAR ( left_paren character_length right_paren )?
  | NATIONAL CHARACTER VARYING left_paren character_length right_paren
  | NATIONAL CHAR VARYING left_paren character_length right_paren
  | NCHAR VARYING left_paren character_length right_paren
  | national_character_large_object_type

national_character_large_object_type ::=
    NATIONAL CHARACTER LARGE OBJECT ( left_paren character_large_object_length right_paren )?
  | NCHAR LARGE OBJECT ( left_paren character_large_object_length right_paren )?
  | NCLOB ( left_paren character_large_object_length right_paren )?

binary_string_type ::=
    BINARY ( left_paren length right_paren )?
  | BINARY VARYING left_paren length right_paren
  | VARBINARY left_paren length right_paren
  | binary_large_object_string_type

binary_large_object_string_type ::=
    BINARY LARGE OBJECT ( left_paren large_object_length right_paren )?
  | BLOB ( left_paren large_object_length right_paren )?

numeric_type ::=
    exact_numeric_type
  | approximate_numeric_type
  | decimal_floating_point_type

exact_numeric_type ::=
    NUMERIC ( left_paren precision ( comma scale )? right_paren )?
  | DECIMAL ( left_paren precision ( comma scale )? right_paren )?
  | DEC ( left_paren precision ( comma scale)? right_paren )?
  | SMALLINT
  | INTEGER
  | INT
  | BIGINT

approximate_numeric_type ::=
    FLOAT ( left_paren precision right_paren )?
  | REAL
  | DOUBLE PRECISION

decimal_floating_point_type ::=
  DECFLOAT ( left_paren precision right_paren )?

length ::=
  unsigned_integer

character_length ::=
  length char_length_units?

large_object_length ::=
    unsigned_integer multiplier?
  | large_object_length_token

character_large_object_length ::=
  large_object_length char_length_units?

char_length_units ::=
    CHARACTERS
  | OCTETS

precision ::=
  unsigned_integer

scale ::=
  unsigned_integer

boolean_type ::=
  BOOLEAN

datetime_type ::=
    DATE
  | TIME ( left_paren time_precision right_paren )? with_or_without_time_zone?
  | TIMESTAMP ( left_paren timestamp_precision right_paren )?
      with_or_without_time_zone?

with_or_without_time_zone ::=
    WITH TIME ZONE
  | WITHOUT TIME ZONE

time_precision ::=
  time_fractional_seconds_precision

timestamp_precision ::=
  time_fractional_seconds_precision

time_fractional_seconds_precision ::=
  unsigned_integer

interval_type ::=
  INTERVAL interval_qualifier

row_type ::=
  ROW row_type_body

row_type_body ::=
  left_paren field_definition ( comma field_definition )* right_paren

reference_type ::=
  REF left_paren referenced_type right_paren scope_clause?

scope_clause ::=
  SCOPE table_name

referenced_type ::=
  path_resolved_user_defined_type_name

path_resolved_user_defined_type_name ::=
  user_defined_type_name

collection_type ::=
    array_type
  | multiset_type

array_type ::=
  data_type ARRAY
      ( left_bracket_or_trigraph maximum_cardinality right_bracket_or_trigraph )?

maximum_cardinality ::=
  unsigned_integer

multiset_type ::=
  data_type MULTISET
/*
6.2        field_definition

Function
Define a field of a row type.


Format
*/
field_definition ::=
  field_name data_type
/*
6.3         value_expression_primary

Function
Specify a value that is syntactically self-delimited.


Format
*/
value_expression_primary ::=
    parenthesized_value_expression
  | nonparenthesized_value_expression_primary

parenthesized_value_expression ::=
  left_paren value_expression right_paren

nonparenthesized_value_expression_primary ::=
       unsigned_value_specification
     | column_reference
     | set_function_specification
     | window_function
     | nested_window_function
     | scalar_subquery
     | case_expression
     | cast_specification
     | field_reference
     | subtype_treatment
     | method_invocation
     | static_method_invocation
     | new_specification
     | attribute_or_method_reference
     | reference_resolution
     | collection_value_constructor
     | array_element_reference
     | multiset_element_reference
     | next_value_expression
     | routine_invocation
     | row_pattern_navigation_operation
     | JSON_value_function

collection_value_constructor ::=
    array_value_constructor
  | multiset_value_constructor
/*
6.4     value_specification and target_specification

Function
Specify one or more values, host parameters, SQL parameters, dynamic parameters, or host variables.


Format
*/
value_specification ::=
    literal
  | general_value_specification

unsigned_value_specification ::=
    unsigned_literal
  | general_value_specification

general_value_specification ::=
    host_parameter_specification
  | SQL_parameter_reference
  | dynamic_parameter_specification
  | embedded_variable_specification
  | current_collation_specification
  | CURRENT_CATALOG
  | CURRENT_DEFAULT_TRANSFORM_GROUP
  | CURRENT_PATH
  | CURRENT_ROLE
  | CURRENT_SCHEMA
  | CURRENT_TRANSFORM_GROUP_FOR_TYPE path_resolved_user_defined_type_name
  | CURRENT_USER
  | SESSION_USER
  | SYSTEM_USER
  | USER
  | VALUE

simple_value_specification ::=
    literal
  | host_parameter_name
  | SQL_parameter_reference
  | embedded_variable_name

target_specification ::=
    host_parameter_specification
  | SQL_parameter_reference
  | column_reference
  | target_array_element_specification
  | dynamic_parameter_specification
  | embedded_variable_specification

simple_target_specification ::=
    host_parameter_name
  | SQL_parameter_reference
  | column_reference
  | embedded_variable_name

host_parameter_specification ::=
  host_parameter_name indicator_parameter?

dynamic_parameter_specification ::=
  question_mark

embedded_variable_specification ::=
  embedded_variable_name indicator_variable?

indicator_variable ::=
  INDICATOR? embedded_variable_name

indicator_parameter ::=
  INDICATOR? host_parameter_name

target_array_element_specification ::=
  target_array_reference
      left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph

target_array_reference ::=
    SQL_parameter_reference
  | column_reference

current_collation_specification ::=
  COLLATION FOR left_paren string_value_expression right_paren
/*
6.5        contextually_typed_value_specification

Function
Specify a value whose data type is to be inferred from its context.


Format
*/
contextually_typed_value_specification ::=
    implicitly_typed_value_specification
  | default_specification

implicitly_typed_value_specification ::=
    null_specification
  | empty_specification

null_specification ::=
  NULL

empty_specification ::=
    ARRAY left_bracket_or_trigraph right_bracket_or_trigraph
  | MULTISET left_bracket_or_trigraph right_bracket_or_trigraph

default_specification ::=
  DEFAULT
/*
6.6        identifier_chain

Function
Disambiguate a <period>-separated chain of identifiers.


Format
*/
identifier_chain ::=
  identifier ( period identifier )*

basic_identifier_chain ::=
  identifier_chain
/*
6.7        column_reference

Function
Reference a column.


Format
*/
column_reference ::=
    basic_identifier_chain
  | MODULE period qualified_identifier period column_name
/*
6.8      SQL_parameter_reference

Function
Reference an SQL parameter.


Format
*/
SQL_parameter_reference ::=
  basic_identifier_chain
/*
6.9        set_function_specification

Function
Specify a value derived by the application of a function to an argument.


Format
*/
set_function_specification ::=
    running_or_final? aggregate_function
  | grouping_operation

running_or_final ::=
  RUNNING | FINAL

grouping_operation ::=
  GROUPING left_paren column_reference
      ( comma column_reference )* right_paren
/*
6.10 window_function

Function
Specify a window function.


Format
*/
window_function ::=
  window_function_type OVER window_name_or_specification

window_function_type ::=
    rank_function_type left_paren right_paren
  | ROW_NUMBER left_paren right_paren
  | aggregate_function
  | ntile_function
  | lead_or_lag_function
  | first_or_last_value_function
  | nth_value_function
  | window_row_pattern_measure

rank_function_type ::=
    RANK
  | DENSE_RANK
  | PERCENT_RANK
  | CUME_DIST

ntile_function ::=
  NTILE left_paren number_of_tiles right_paren

number_of_tiles ::=
    simple_value_specification
  | dynamic_parameter_specification

lead_or_lag_function ::=
  lead_or_lag left_paren lead_or_lag_extent
      ( comma offset ( comma default_expression )? )? right_paren
      null_treatment?

lead_or_lag ::=
  LEAD | LAG

lead_or_lag_extent ::=
  value_expression

offset ::=
  exact_numeric_literal

default_expression ::=
  value_expression

null_treatment ::=
  RESPECT NULLS | IGNORE NULLS

first_or_last_value_function ::=
  first_or_last_value left_paren value_expression right_paren null_treatment?

first_or_last_value ::=
  FIRST_VALUE | LAST_VALUE

nth_value_function ::=
  NTH_VALUE left_paren value_expression comma nth_row right_paren
      from_first_or_last? null_treatment?

nth_row ::=
    simple_value_specification
  | dynamic_parameter_specification

from_first_or_last ::=
    FROM FIRST
  | FROM LAST

window_name_or_specification ::=
    window_name
  | in_line_window_specification

in_line_window_specification ::=
  window_specification

window_row_pattern_measure ::=
  measure_name
/*
6.11 nested_window_function

Function
Specify a function nested in an aggregated argument of an aggregate_function simply contained in a <window
function>.


Format
*/
nested_window_function ::=
    nested_row_number_function
  | value_of_expression_at_row

nested_row_number_function ::=
  ROW_NUMBER left_paren row_marker right_paren

value_of_expression_at_row ::=
  VALUE_OF left_paren value_expression AT row_marker_expression
      ( comma value_of_default_value ) right_paren

row_marker ::=
    BEGIN_PARTITION
  | BEGIN_FRAME
  | CURRENT_ROW
  | FRAME_ROW
  | END_FRAME
  | END_PARTITION

row_marker_expression ::=
  row_marker row_marker_delta?

row_marker_delta ::=
    plus_sign row_marker_offset
  | minus_sign row_marker_offset

row_marker_offset ::=
    simple_value_specification
  | dynamic_parameter_specification

value_of_default_value ::=
  value_expression
/*
6.12 case_expression

Function
Specify a conditional value.


Format
*/
case_expression ::=
    case_abbreviation
  | case_specification

case_abbreviation ::=
    NULLIF left_paren value_expression comma value_expression right_paren
  | COALESCE left_paren value_expression
      ( comma value_expression )* right_paren

case_specification ::=
    simple_case
  | searched_case

simple_case ::=
  CASE case_operand simple_when_clause+  else_clause? END

searched_case ::=
  CASE searched_when_clause+ else_clause? END

simple_when_clause ::=
  WHEN when_operand_list THEN result

searched_when_clause ::=
  WHEN search_condition THEN result

else_clause ::=
  ELSE result

case_operand ::=
    row_value_predicand
  | overlaps_predicate_part_1

when_operand_list ::=
  when_operand ( comma when_operand )*

when_operand ::=
    row_value_predicand
  | comparison_predicate_part_2
  | between_predicate_part_2
  | in_predicate_part_2
  | character_like_predicate_part_2
  | octet_like_predicate_part_2
  | similar_predicate_part_2
  | regex_like_predicate_part_2
  | null_predicate_part_2
  | quantified_comparison_predicate_part_2
  | normalized_predicate_part_2
  | match_predicate_part_2
  | overlaps_predicate_part_2
  | distinct_predicate_part_2
  | member_predicate_part_2
  | submultiset_predicate_part_2
  | set_predicate_part_2
  | type_predicate_part_2

result ::=
    result_expression
  | NULL

result_expression ::=
  value_expression
/*
6.13 cast_specification

Function
Specify a data conversion.


Format
*/
cast_specification ::=
     CAST left_paren
         cast_operand AS cast_target
         ( FORMAT cast_template )?
         right_paren

cast_operand ::=
    value_expression
  | implicitly_typed_value_specification

cast_target ::=
    domain_name
  | data_type

cast_template ::=
  character_string_literal
/*
6.14 next_value_expression

Function
Return the next value of a sequence generator.


Format
*/
next_value_expression ::=
  NEXT VALUE FOR sequence_generator_name
/*
6.15 field_reference

Function
Reference a field of a row value.


Format
*/
field_reference ::=
  value_expression_primary period field_name
/*
6.16 subtype_treatment

Function
Modify the declared type of an expression.


Format
*/
subtype_treatment ::=
  TREAT left_paren subtype_operand AS target_subtype right_paren

subtype_operand ::=
  value_expression

target_subtype ::=
    path_resolved_user_defined_type_name
  | reference_type
/*
6.17 method_invocation

Function
Reference an SQL-invoked method of a user-defined type value.


Format
*/
method_invocation ::=
    direct_invocation
  | generalized_invocation

direct_invocation ::=
  value_expression_primary period method_name SQL_argument_list?

generalized_invocation ::=
  left_paren value_expression_primary AS data_type right_paren
      period method_name SQL_argument_list?

method_selection ::=
  routine_invocation

constructor_method_selection ::=
  routine_invocation
/*
6.18 static_method_invocation

Function
Invoke a static method.


Format
*/
static_method_invocation ::=
  path_resolved_user_defined_type_name double_colon method_name
      SQL_argument_list?

static_method_selection ::=
  routine_invocation
/*
6.19 new_specification

Function
Invoke a method on a structured type.


Format
*/
new_specification ::=
  NEW path_resolved_user_defined_type_name SQL_argument_list

new_invocation ::=
    method_invocation
  | routine_invocation
/*
6.20 attribute_or_method_reference

Function
Return a value acquired by accessing a column of the row identified by a value of a reference type or by
invoking an SQL-invoked method.


Format
*/
attribute_or_method_reference ::=
  value_expression_primary dereference_operator qualified_identifier
      SQL_argument_list?

dereference_operator ::=
  right_arrow
/*
6.21 dereference_operation

Function
Access a column of the row identified by a value of a reference type.


Format
*/
dereference_operation ::=
  reference_value_expression dereference_operator attribute_name
/*
6.22 method_reference

Function
Return a value acquired from invoking an SQL-invoked routine that is a method.


Format
*/
method_reference ::=
  value_expression_primary dereference_operator method_name SQL_argument_list
/*
6.23 reference_resolution

Function
Obtain the value referenced by a REF value.


Format
*/
reference_resolution ::=
  DEREF left_paren reference_value_expression right_paren
/*
6.24 array_element_reference

Function
Return an element of an array.


Format
*/
array_element_reference ::=
  array_value_expression
      left_bracket_or_trigraph numeric_value_expression right_bracket_or_trigraph
/*
6.25 multiset_element_reference

Function
Return the sole element of a multiset of one element.


Format
*/
multiset_element_reference ::=
  ELEMENT left_paren multiset_value_expression right_paren
/*
6.26 row_pattern_navigation_operation

Function
Return the value of a value expression evaluated in a row determined by navigation within the row pattern
partition using logical and physical offsets from a row mapped to a row pattern variable.


Format
*/
row_pattern_navigation_operation ::=
    row_pattern_navigation__logical
  | row_pattern_navigation__physical
  | row_pattern_navigation__compound

row_pattern_navigation__logical ::=
  running_or_final? first_or_last
      left_paren value_expression ( comma logical_offset )? right_paren

row_pattern_navigation__physical ::=
  prev_or_next
      left_paren value_expression ( comma physical_offset )? right_paren

row_pattern_navigation__compound ::=
  prev_or_next left_paren running_or_final? first_or_last
      left_paren value_expression ( comma logical_offset )? right_paren
      ( comma physical_offset )? right_paren

first_or_last ::=
  FIRST | LAST

prev_or_next ::=
  PREV | NEXT

logical_offset ::=
    simple_value_specification
  | dynamic_parameter_specification

physical_offset ::=
    simple_value_specification
  | dynamic_parameter_specification
/*
6.27 JSON_value_function

Function
Extract an SQL value of a predefined type from a JSON value.


Format
*/
JSON_value_function ::=
  JSON_VALUE left_paren
      JSON_API_common_syntax
      JSON_returning_clause?
      ( JSON_value_empty_behavior ON EMPTY )?
      ( JSON_value_error_behavior ON ERROR )?
  right_paren

JSON_returning_clause ::=
  RETURNING data_type

JSON_value_empty_behavior ::=
    ERROR
  | NULL
  | DEFAULT value_expression

JSON_value_error_behavior ::=
    ERROR
  | NULL
  | DEFAULT value_expression
/*
6.28 value_expression

Function
Specify a value.


Format
*/
value_expression ::=
    common_value_expression
  | boolean_value_expression
  | row_value_expression

common_value_expression ::=
         numeric_value_expression
     |   string_value_expression
     |   datetime_value_expression
     |   interval_value_expression
     |   user_defined_type_value_expression
     |   reference_value_expression
     |   collection_value_expression

user_defined_type_value_expression ::=
  value_expression_primary

reference_value_expression ::=
  value_expression_primary

collection_value_expression ::=
    array_value_expression
  | multiset_value_expression
/*
6.29 numeric_value_expression

Function
Specify a numeric value.


Format
*/
numeric_value_expression ::=
    term
  | numeric_value_expression plus_sign term
  | numeric_value_expression minus_sign term

term ::=
    factor
  | term asterisk factor
  | term solidus factor

factor ::=
  sign? numeric_primary

numeric_primary ::=
    value_expression_primary
  | numeric_value_function
/*
6.30 numeric_value_function

Function
Specify a function yielding a value of type numeric.


Format
*/
numeric_value_function ::=
    position_expression
  | regex_occurrences_function
  | regex_position_expression
  | extract_expression
  | length_expression
  | cardinality_expression
  | max_cardinality_expression
  | absolute_value_expression
  | modulus_expression
  | trigonometric_function
  | general_logarithm_function
  | common_logarithm
  | natural_logarithm
  | exponential_function
  | power_function
  | square_root
  | floor_function
  | ceiling_function
  | width_bucket_function
  | match_number_function

position_expression ::=
    character_position_expression
  | binary_position_expression

regex_occurrences_function ::=
  OCCURRENCES_REGEX left_paren
      XQuery_pattern ( FLAG XQuery_option_flag )?
      IN regex_subject_string
      ( FROM start_position )?
      ( USING char_length_units )?
      right_paren

XQuery_pattern ::=
  character_value_expression

XQuery_option_flag ::=
  character_value_expression

regex_subject_string ::=
  character_value_expression

regex_position_expression ::=
  POSITION_REGEX left_paren
      ( regex_position_start_or_after )?
      XQuery_pattern ( FLAG XQuery_option_flag )?
      IN regex_subject_string
      ( FROM start_position )?
      ( USING char_length_units )?
      ( OCCURRENCE regex_occurrence )?
      ( GROUP regex_capture_group )?
      right_paren

regex_position_start_or_after ::=
    START
  | AFTER

regex_occurrence ::=
  numeric_value_expression

regex_capture_group ::=
  numeric_value_expression

character_position_expression ::=
  POSITION left_paren character_value_expression_1 IN character_value_expression_2
      ( USING char_length_units )? right_paren

character_value_expression_1 ::=
  character_value_expression

character_value_expression_2 ::=
  character_value_expression

binary_position_expression ::=
  POSITION left_paren binary_value_expression IN binary_value_expression right_paren

length_expression ::=
    char_length_expression
  | octet_length_expression

char_length_expression ::=
  ( CHAR_LENGTH | CHARACTER_LENGTH ) left_paren character_value_expression
      ( USING char_length_units )? right_paren

octet_length_expression ::=
  OCTET_LENGTH left_paren string_value_expression right_paren

extract_expression ::=
  EXTRACT left_paren extract_field FROM extract_source right_paren

extract_field ::=
    primary_datetime_field
  | time_zone_field

time_zone_field ::=
    TIMEZONE_HOUR
  | TIMEZONE_MINUTE

extract_source ::=
    datetime_value_expression
  | interval_value_expression

cardinality_expression ::=
  CARDINALITY left_paren collection_value_expression right_paren

max_cardinality_expression ::=
  ARRAY_MAX_CARDINALITY left_paren array_value_expression right_paren

absolute_value_expression ::=
  ABS left_paren numeric_value_expression right_paren

modulus_expression ::=
  MOD left_paren numeric_value_expression_dividend comma
      numeric_value_expression_divisor right_paren

numeric_value_expression_dividend ::=
  numeric_value_expression

numeric_value_expression_divisor ::=
  numeric_value_expression

trigonometric_function ::=
  trigonometric_function_name left_paren numeric_value_expression right_paren

trigonometric_function_name ::=
  SIN | COS | TAN | SINH | COSH | TANH | ASIN | ACOS | ATAN

general_logarithm_function ::=
  LOG left_paren general_logarithm_base comma
      general_logarithm_argument right_paren

general_logarithm_base ::=
  numeric_value_expression

general_logarithm_argument ::=
  numeric_value_expression

common_logarithm ::=
  "LOG10" left_paren numeric_value_expression right_paren

natural_logarithm ::=
  LN left_paren numeric_value_expression right_paren

exponential_function ::=
  EXP left_paren numeric_value_expression right_paren

power_function ::=
  POWER left_paren numeric_value_expression_base comma
      numeric_value_expression_exponent right_paren

numeric_value_expression_base ::=
  numeric_value_expression

numeric_value_expression_exponent ::=
  numeric_value_expression

square_root ::=
  SQRT left_paren numeric_value_expression right_paren

floor_function ::=
  FLOOR left_paren numeric_value_expression right_paren

ceiling_function ::=
  ( CEIL | CEILING ) left_paren numeric_value_expression right_paren

width_bucket_function ::=
  WIDTH_BUCKET left_paren width_bucket_operand comma width_bucket_bound_1 comma
      width_bucket_bound_2 comma width_bucket_count right_paren

width_bucket_operand ::=
  numeric_value_expression

width_bucket_bound_1 ::=
  numeric_value_expression

width_bucket_bound_2 ::=
  numeric_value_expression

width_bucket_count ::=
  numeric_value_expression

match_number_function ::=
  MATCH_NUMBER left_paren right_paren
/*
6.31 string_value_expression

Function
Specify a character string value or a binary string value.


Format
*/
string_value_expression ::=
    character_value_expression
  | binary_value_expression

character_value_expression ::=
    concatenation
  | character_factor

concatenation ::=
  character_value_expression concatenation_operator character_factor

character_factor ::=
  character_primary collate_clause?

character_primary ::=
    value_expression_primary
  | string_value_function

binary_value_expression ::=
    binary_concatenation
  | binary_factor

binary_factor ::=
  binary_primary

binary_primary ::=
    value_expression_primary
  | string_value_function

binary_concatenation ::=
  binary_value_expression concatenation_operator binary_factor
/*
6.32 string_value_function

Function
Specify a function yielding a value of type character string or binary string.


Format
*/
string_value_function ::=
    character_value_function
  | binary_value_function
  | JSON_value_constructor
  | JSON_query

character_value_function ::=
    character_substring_function
  | regular_expression_substring_function
  | regex_substring_function
  | fold
  | transcoding
  | character_transliteration
  | regex_transliteration
  | trim_function
  | character_overlay_function
  | normalize_function
  | specific_type_method
  | classifier_function

character_substring_function ::=
  SUBSTRING left_paren character_value_expression FROM start_position
      ( FOR string_length )? ( USING char_length_units )? right_paren

regular_expression_substring_function ::=
  SUBSTRING left_paren character_value_expression SIMILAR character_value_expression
      ESCAPE escape_character right_paren

regex_substring_function ::=
  SUBSTRING_REGEX left_paren
      XQuery_pattern ( FLAG XQuery_option_flag )?
      IN regex_subject_string
      ( FROM start_position )?
      ( USING char_length_units )?
      ( OCCURRENCE regex_occurrence )?
      ( GROUP regex_capture_group )?
      right_paren

fold ::=
  ( UPPER | LOWER ) left_paren character_value_expression right_paren

transcoding ::=
  CONVERT left_paren character_value_expression
      USING transcoding_name right_paren

character_transliteration ::=
  TRANSLATE left_paren character_value_expression
      USING transliteration_name right_paren

regex_transliteration ::=
  TRANSLATE_REGEX left_paren
      XQuery_pattern ( FLAG XQuery_option_flag )?
      IN regex_subject_string
      ( WITH XQuery_replacement_string )?
      ( FROM start_position )?
      ( USING char_length_units )?
      ( OCCURRENCE regex_transliteration_occurrence )?
      right_paren

XQuery_replacement_string ::=
  character_value_expression

regex_transliteration_occurrence ::=
    regex_occurrence
  | ALL

trim_function ::=
  TRIM left_paren trim_operands right_paren

trim_operands ::=
  ( trim_specification? trim_character? FROM )? trim_source

trim_source ::=
  character_value_expression

trim_specification ::=
    LEADING
  | TRAILING
  | BOTH

trim_character ::=
  character_value_expression

character_overlay_function ::=
  OVERLAY left_paren character_value_expression PLACING character_value_expression
      FROM start_position ( FOR string_length )?
      ( USING char_length_units )? right_paren

normalize_function ::=
  NORMALIZE left_paren character_value_expression
      ( comma normal_form ( comma normalize_function_result_length )? )? right_paren

normal_form ::=
    NFC
  | NFD
  | NFKC
  | NFKD

normalize_function_result_length ::=
    character_length
  | character_large_object_length

specific_type_method ::=
  user_defined_type_value_expression period SPECIFICTYPE
      ( left_paren right_paren )?

binary_value_function ::=
       binary_substring_function
     | binary_trim_function
     | binary_overlay_function

binary_substring_function ::=
  SUBSTRING left_paren binary_value_expression FROM start_position
      ( FOR string_length )? right_paren

binary_trim_function ::=
  TRIM left_paren binary_trim_operands right_paren

binary_trim_operands ::=
  ( trim_specification? trim_octet? FROM )? binary_trim_source

binary_trim_source ::=
  binary_value_expression

trim_octet ::=
  binary_value_expression

binary_overlay_function ::=
  OVERLAY left_paren binary_value_expression PLACING binary_value_expression
      FROM start_position ( FOR string_length )? right_paren

start_position ::=
  numeric_value_expression

string_length ::=
  numeric_value_expression

classifier_function ::=
  CLASSIFIER left_paren ( row_pattern_variable_name )? right_paren
/*
6.33 JSON_value_constructor

Function
Generate a JSON text fragment.


Format
*/
JSON_value_constructor ::=
    JSON_object_constructor
  | JSON_array_constructor

JSON_object_constructor ::=
  JSON_OBJECT left_paren
      ( JSON_name_and_value ( comma JSON_name_and_value )*
      JSON_constructor_null_clause?
      JSON_key_uniqueness_constraint? )?
      JSON_output_clause?
      right_paren

JSON_name_and_value ::=
    KEY? JSON_name VALUE JSON_value_expression
  | JSON_name colon JSON_value_expression

JSON_name ::=
  character_value_expression

JSON_constructor_null_clause ::=
    NULL ON NULL
  | ABSENT ON NULL

JSON_array_constructor ::=
    JSON_array_constructor_by_enumeration
  | JSON_array_constructor_by_query

JSON_array_constructor_by_enumeration ::=
  JSON_ARRAY left_paren
      ( JSON_value_expression ( comma JSON_value_expression )*
      JSON_constructor_null_clause? )?
      JSON_output_clause?
      right_paren

JSON_array_constructor_by_query ::=
  JSON_ARRAY left_paren
      query_expression
      JSON_input_clause?
      JSON_constructor_null_clause?
      JSON_output_clause?
      right_paren
/*
6.34 JSON_query

Function
Extract a JSON text from a JSON text using an SQL/JSON path expression.


Format
*/
JSON_query ::=
  JSON_QUERY left_paren
  JSON_API_common_syntax
      JSON_output_clause?
      ( JSON_query_wrapper_behavior WRAPPER )?
      ( JSON_query_quotes_behavior QUOTES ( ON SCALAR STRING )? )?
      ( JSON_query_empty_behavior ON EMPTY )?
      ( JSON_query_error_behavior ON ERROR )?
  right_paren

JSON_query_wrapper_behavior ::=
    WITHOUT  ARRAY?
  | WITH ( CONDITIONAL | UNCONDITIONAL )?  ARRAY?

JSON_query_quotes_behavior ::=
    KEEP
  | OMIT

JSON_query_empty_behavior ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

JSON_query_error_behavior ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT
/*
6.35 datetime_value_expression

Function
Specify a datetime value.


Format
*/
datetime_value_expression ::=
    datetime_term
  | interval_value_expression plus_sign datetime_term
  | datetime_value_expression plus_sign interval_term
  | datetime_value_expression minus_sign interval_term

datetime_term ::=
  datetime_factor

datetime_factor ::=
  datetime_primary  time_zone?

datetime_primary ::=
    value_expression_primary
  | datetime_value_function

time_zone ::=
  AT time_zone_specifier

time_zone_specifier ::=
    LOCAL
  | TIME ZONE interval_primary
/*
6.36 datetime_value_function

Function
Specify a function yielding a value of type datetime.


Format
*/
datetime_value_function ::=
    current_date_value_function
  | current_time_value_function
  | current_timestamp_value_function
  | current_local_time_value_function
  | current_local_timestamp_value_function

current_date_value_function ::=
  CURRENT_DATE

current_time_value_function ::=
  CURRENT_TIME ( left_paren time_precision right_paren )?

current_local_time_value_function ::=
  LOCALTIME ( left_paren time_precision right_paren )?

current_timestamp_value_function ::=
  CURRENT_TIMESTAMP ( left_paren timestamp_precision right_paren )?

current_local_timestamp_value_function ::=
  LOCALTIMESTAMP ( left_paren timestamp_precision right_paren )?
/*
6.37 interval_value_expression

Function
Specify an interval value.


Format
*/
interval_value_expression ::=
    interval_term
  | interval_value_expression_1 plus_sign interval_term_1
  | interval_value_expression_1 minus_sign interval_term_1
  | left_paren datetime_value_expression minus_sign datetime_term right_paren
      interval_qualifier

interval_term ::=
    interval_factor
  | interval_term_2 asterisk factor
  | interval_term_2 solidus factor
  | term asterisk interval_factor

interval_factor ::=
  sign? interval_primary

interval_primary ::=
    value_expression_primary interval_qualifier?
  | interval_value_function

interval_value_expression_1 ::=
  interval_value_expression

interval_term_1 ::=
  interval_term

interval_term_2 ::=
  interval_term
/*
6.38 interval_value_function

Function
Specify a function yielding a value of type interval.


Format
*/
interval_value_function ::=
  interval_absolute_value_function

interval_absolute_value_function ::=
  ABS left_paren interval_value_expression right_paren
/*
6.39 boolean_value_expression

Function
Specify a boolean value.


Format
*/
boolean_value_expression ::=
    boolean_term
  | boolean_value_expression OR boolean_term

boolean_term ::=
    boolean_factor
  | boolean_term AND boolean_factor

boolean_factor ::=
  NOT? boolean_test

boolean_test ::=
  boolean_primary ( IS NOT? truth_value )?

truth_value ::=
    TRUE
  | FALSE
  | UNKNOWN

boolean_primary ::=
    predicate
  | boolean_predicand

boolean_predicand ::=
    parenthesized_boolean_value_expression
  | nonparenthesized_value_expression_primary

parenthesized_boolean_value_expression ::=
  left_paren boolean_value_expression right_paren
/*
6.40 array_value_expression

Function
Specify an array value.


Format
*/
array_value_expression ::=
    array_concatenation
  | array_primary

array_concatenation ::=
  array_value_expression_1 concatenation_operator array_primary

array_value_expression_1 ::=
  array_value_expression

array_primary ::=
    array_value_function
  | value_expression_primary
/*
6.41 array_value_function

Function
Specify a function yielding a value of an array type.


Format
*/
array_value_function ::=
  trim_array_function

trim_array_function ::=
  TRIM_ARRAY left_paren array_value_expression comma numeric_value_expression right_paren
/*
6.42 array_value_constructor

Function
Specify construction of an array.


Format
*/
array_value_constructor ::=
    array_value_constructor_by_enumeration
  | array_value_constructor_by_query

array_value_constructor_by_enumeration ::=
  ARRAY left_bracket_or_trigraph array_element_list right_bracket_or_trigraph

array_element_list ::=
  array_element ( comma array_element )*

array_element ::=
  value_expression

array_value_constructor_by_query ::=
  ARRAY table_subquery
/*
6.43 multiset_value_expression

Function
Specify a multiset value.


Format
*/
multiset_value_expression ::=
    multiset_term
  | multiset_value_expression MULTISET UNION ( ALL | DISTINCT )? multiset_term
  | multiset_value_expression MULTISET EXCEPT ( ALL | DISTINCT )? multiset_term

multiset_term ::=
    multiset_primary
  | multiset_term MULTISET INTERSECT ( ALL | DISTINCT )? multiset_primary

multiset_primary ::=
    multiset_value_function
  | value_expression_primary
/*
6.44 multiset_value_function

Function
Specify a function yielding a value of a multiset type.


Format
*/
multiset_value_function ::=
  multiset_set_function

multiset_set_function ::=
  SET left_paren multiset_value_expression right_paren
/*
6.45 multiset_value_constructor

Function
Specify construction of a multiset.


Format
*/
multiset_value_constructor ::=
    multiset_value_constructor_by_enumeration
  | multiset_value_constructor_by_query
  | table_value_constructor_by_query

multiset_value_constructor_by_enumeration ::=
  MULTISET left_bracket_or_trigraph multiset_element_list right_bracket_or_trigraph

multiset_element_list ::=
  multiset_element ( comma multiset_element )*

multiset_element ::=
  value_expression

multiset_value_constructor_by_query ::=
  MULTISET table_subquery

table_value_constructor_by_query ::=
  TABLE table_subquery
/*
7 Query expressions


7.1     row_value_constructor

Function
Specify a value or list of values to be constructed into a row.


Format
*/
row_value_constructor ::=
    common_value_expression
  | boolean_value_expression
  | explicit_row_value_constructor

explicit_row_value_constructor ::=
    left_paren row_value_constructor_element comma
        row_value_constructor_element_list right_paren
  | ROW left_paren row_value_constructor_element_list right_paren
  | row_subquery

row_value_constructor_element_list ::=
  row_value_constructor_element ( comma row_value_constructor_element )*

row_value_constructor_element ::=
  value_expression

contextually_typed_row_value_constructor ::=
    common_value_expression
  | boolean_value_expression
  | contextually_typed_value_specification
  | left_paren contextually_typed_value_specification right_paren
  | left_paren contextually_typed_row_value_constructor_element comma
      contextually_typed_row_value_constructor_element_list right_paren
  | ROW left_paren contextually_typed_row_value_constructor_element_list right_paren

contextually_typed_row_value_constructor_element_list ::=
  contextually_typed_row_value_constructor_element
      ( comma contextually_typed_row_value_constructor_element )*

contextually_typed_row_value_constructor_element ::=
    value_expression
  | contextually_typed_value_specification

row_value_constructor_predicand ::=
    common_value_expression
  | boolean_predicand
  | explicit_row_value_constructor
/*
7.2      row_value_expression

Function
Specify a row value.


Format
*/
row_value_expression ::=
    row_value_special_case
  | explicit_row_value_constructor

table_row_value_expression ::=
    row_value_special_case
  | row_value_constructor

contextually_typed_row_value_expression ::=
    row_value_special_case
  | contextually_typed_row_value_constructor

row_value_predicand ::=
    row_value_special_case
  | row_value_constructor_predicand

row_value_special_case ::=
  nonparenthesized_value_expression_primary
/*
7.3      table_value_constructor

Function
Specify a set of <row value expression>s to be constructed into a table.


Format
*/
table_value_constructor ::=
  VALUES row_value_expression_list

row_value_expression_list ::=
  table_row_value_expression ( comma table_row_value_expression )*

contextually_typed_table_value_constructor ::=
  VALUES contextually_typed_row_value_expression_list

contextually_typed_row_value_expression_list ::=
  contextually_typed_row_value_expression
      ( comma contextually_typed_row_value_expression )*
/*
7.4      table_expression

Function
Specify a table or a grouped table.


Format
*/
table_expression ::=
  from_clause
      where_clause?
      group_by_clause?
      having_clause?
      window_clause?
/*
7.5        from_clause

Function
Specify a table derived from one or more tables.


Format
*/
from_clause ::=
  FROM table_reference_list

table_reference_list ::=
  table_reference ( comma table_reference )*
/*
7.6     table_reference

Function
Reference a table.


Format
*/
table_reference ::=
    table_factor
  | joined_table

table_factor ::=
  table_primary sample_clause?

sample_clause ::=
  TABLESAMPLE sample_method left_paren sample_percentage right_paren
      repeatable_clause?

sample_method ::=
    BERNOULLI
  | SYSTEM

repeatable_clause ::=
  REPEATABLE left_paren repeat_argument right_paren

sample_percentage ::=
  numeric_value_expression

repeat_argument ::=
  numeric_value_expression

table_primary ::=
    table_or_query_name
        query_system_time_period_specification?
        correlation_or_recognition?
  | derived_table correlation_or_recognition
  | lateral_derived_table correlation_or_recognition
  | collection_derived_table correlation_or_recognition
  | table_function_derived_table correlation_or_recognition
  | PTF_derived_table correlation_or_recognition?
  | only_spec correlation_or_recognition?
  | data_change_delta_table correlation_or_recognition?
  | JSON_table correlation_or_recognition
  | JSON_table_primitive correlation_name
  | parenthesized_joined_table

correlation_or_recognition ::=
    AS? correlation_name
        parenthesized_derived_column_list?
  | row_pattern_recognition_clause_and_name
query_system_time_period_specification ::=
    FOR SYSTEM_TIME AS OF point_in_time_1
  | FOR SYSTEM_TIME BETWEEN ( ASYMMETRIC | SYMMETRIC )?
      point_in_time_1 AND point_in_time_2
  | FOR SYSTEM_TIME FROM point_in_time_1 TO point_in_time_2

point_in_time_1 ::=
  point_in_time

point_in_time_2 ::=
  point_in_time

point_in_time ::=
  datetime_value_expression

only_spec ::=
  ONLY left_paren table_or_query_name right_paren

lateral_derived_table ::=
  LATERAL table_subquery

collection_derived_table ::=
  UNNEST left_paren collection_value_expression
      ( comma collection_value_expression )* right_paren
      ( WITH ORDINALITY )?

table_function_derived_table ::=
  TABLE left_paren collection_value_expression right_paren

derived_table ::=
  table_subquery

PTF_derived_table ::=
  TABLE left_paren routine_invocation right_paren

table_or_query_name ::=
    table_name
  | transition_table_name
  | query_name

derived_column_list ::=
  column_name_list

column_name_list ::=
  column_name ( comma column_name )*

data_change_delta_table ::=
  result_option TABLE left_paren data_change_statement right_paren

data_change_statement ::=
    delete_statement__searched
  | insert_statement
  | merge_statement
  | update_statement__searched

result_option ::=
    FINAL
  | NEW
  | OLD

parenthesized_joined_table ::=
    left_paren parenthesized_joined_table right_paren
  | left_paren joined_table right_paren

row_pattern_recognition_clause_and_name ::=
  ( AS? row_pattern_input_name
      row_pattern_input_derived_column_list? )?
      row_pattern_recognition_clause ( AS? row_pattern_output_name
      row_pattern_output_derived_column_list? )?

row_pattern_input_name ::=
  correlation_name

row_pattern_output_name ::=
  correlation_name

row_pattern_input_derived_column_list ::=
  parenthesized_derived_column_list

row_pattern_output_derived_column_list ::=
  parenthesized_derived_column_list

parenthesized_derived_column_list ::=
  left_paren derived_column_list right_paren
/*
7.7        row_pattern_recognition_clause

Function
Match row patterns.


Format
*/
row_pattern_recognition_clause ::=
  MATCH_RECOGNIZE left_paren
      row_pattern_partition_by?
      row_pattern_order_by?
      row_pattern_measures?
      row_pattern_rows_per_match?
      row_pattern_common_syntax
      right_paren

row_pattern_partition_by ::=
  PARTITION BY row_pattern_partition_list

row_pattern_partition_list ::=
  row_pattern_partition_column ( comma row_pattern_partition_column )*

row_pattern_partition_column ::=
  column_reference collate_clause?

row_pattern_order_by ::=
  ORDER BY sort_specification_list

row_pattern_rows_per_match ::=
    ONE ROW PER MATCH
  | ALL ROWS PER MATCH row_pattern_empty_match_handling?

row_pattern_empty_match_handling ::=
    SHOW EMPTY MATCHES
  | OMIT EMPTY MATCHES
  | WITH UNMATCHED ROWS
/*
7.8        row_pattern_measures

Function
Specify the measure columns of a row pattern.


Format
*/
row_pattern_measures ::=
  MEASURES row_pattern_measure_list

row_pattern_measure_list ::=
  row_pattern_measure_definition ( comma row_pattern_measure_definition )*

row_pattern_measure_definition ::=
  row_pattern_measure_expression AS measure_name

row_pattern_measure_expression ::=
  value_expression
/*
7.9    row_pattern_common_syntax

Function
Specify syntax that is common to row patterns in table_reference and in window_clause.


Format
*/
row_pattern_common_syntax ::=
  ( AFTER MATCH row_pattern_skip_to )?
      row_pattern_initial_or_seek?
      PATTERN left_paren row_pattern right_paren
      row_pattern_subset_clause?
      DEFINE row_pattern_definition_list

row_pattern_skip_to ::=
    SKIP TO NEXT ROW
  | SKIP PAST LAST ROW
  | SKIP TO FIRST row_pattern_skip_to_variable_name
  | SKIP TO LAST row_pattern_skip_to_variable_name
  | SKIP TO row_pattern_skip_to_variable_name

row_pattern_skip_to_variable_name ::=
  row_pattern_variable_name

row_pattern_initial_or_seek ::=
    INITIAL
  | SEEK

row_pattern ::=
    row_pattern_term
  | row_pattern_alternation

row_pattern_alternation ::=
  row_pattern vertical_bar row_pattern_term

row_pattern_term ::=
    row_pattern_factor
  | row_pattern_term row_pattern_factor

row_pattern_factor ::=
  row_pattern_primary row_pattern_quantifier?

row_pattern_quantifier ::=
    asterisk question_mark?
  | plus_sign question_mark?
  | question_mark question_mark?
  | left_brace unsigned_integer? comma unsigned_integer? right_brace
      question_mark?
  | left_brace unsigned_integer right_brace

row_pattern_primary ::=
    row_pattern_primary_variable_name
  | dollar_sign
  | circumflex
  | left_paren row_pattern? right_paren
  | left_brace_minus row_pattern right_minus_brace
  | row_pattern_permute

row_pattern_primary_variable_name ::=
  row_pattern_variable_name

row_pattern_permute ::=
  PERMUTE left_paren row_pattern ( comma row_pattern )* right_paren

row_pattern_subset_clause ::=
  SUBSET row_pattern_subset_list

row_pattern_subset_list ::=
  row_pattern_subset_item ( comma row_pattern_subset_item )*

row_pattern_subset_item ::=
  row_pattern_subset_item_variable_name equals_operator
      left_paren row_pattern_subset_rhs right_paren

row_pattern_subset_item_variable_name ::=
  row_pattern_variable_name

row_pattern_subset_rhs ::=
  row_pattern_subset_rhs_variable_name
      ( comma row_pattern_subset_rhs_variable_name )*

row_pattern_subset_rhs_variable_name ::=
  row_pattern_variable_name

row_pattern_definition_list ::=
  row_pattern_definition ( comma row_pattern_definition )*

row_pattern_definition ::=
  row_pattern_definition_variable_name AS row_pattern_definition_search_condition

row_pattern_definition_variable_name ::=
  row_pattern_variable_name

row_pattern_definition_search_condition ::=
  search_condition
/*
7.10 joined_table

Function
Specify a table derived from a Cartesian product, inner join, or outer join.


Format
*/
joined_table ::=
    cross_join
  | qualified_join
  | natural_join

cross_join ::=
  table_reference CROSS JOIN table_factor

qualified_join ::=
  ( table_reference | partitioned_join_table )
      join_type? JOIN
      ( table_reference | partitioned_join_table )
      join_specification

partitioned_join_table ::=
  table_factor PARTITION BY
      partitioned_join_column_reference_list

partitioned_join_column_reference_list ::=
  left_paren partitioned_join_column_reference
      ( comma partitioned_join_column_reference )*
      right_paren

partitioned_join_column_reference ::=
  column_reference

natural_join ::=
  ( table_reference | partitioned_join_table )
      NATURAL join_type? JOIN
      ( table_factor | partitioned_join_table )

join_specification ::=
    join_condition
  | named_columns_join

join_condition ::=
  ON search_condition

named_columns_join ::=
  USING left_paren join_column_list right_paren ( AS join_correlation_name )?

join_correlation_name ::=
  correlation_name

join_type ::=
    INNER
  | outer_join_type OUTER?

outer_join_type ::=
    LEFT
  | RIGHT
  | FULL

join_column_list ::=
  column_name_list
/*
7.11 JSON_table

Function
Query a JSON text and present it as a relational table.


Format
*/
JSON_table ::=
  JSON_TABLE left_paren
      JSON_API_common_syntax
      JSON_table_columns_clause
      JSON_table_plan_clause?
      ( JSON_table_error_behavior ON ERROR )?
  right_paren

JSON_table_columns_clause ::=
  COLUMNS left_paren
      JSON_table_column_definition ( comma JSON_table_column_definition )*
  right_paren

JSON_table_column_definition ::=
    JSON_table_ordinality_column_definition
  | JSON_table_regular_column_definition
  | JSON_table_formatted_column_definition
  | JSON_table_nested_columns

JSON_table_ordinality_column_definition ::=
  column_name FOR ORDINALITY

JSON_table_regular_column_definition ::=
  column_name data_type
      ( PATH JSON_table_column_path_specification )?
      ( JSON_table_column_empty_behavior ON EMPTY )?
      ( JSON_table_column_error_behavior ON ERROR )?

JSON_table_column_empty_behavior ::=
    ERROR
  | NULL
  | DEFAULT value_expression

JSON_table_column_error_behavior ::=
    ERROR
  | NULL
  | DEFAULT value_expression

JSON_table_column_path_specification ::=
  JSON_path_specification

JSON_table_formatted_column_definition ::=
  column_name data_type
      FORMAT JSON_representation
      ( PATH JSON_table_column_path_specification )?
      ( JSON_table_formatted_column_wrapper_behavior WRAPPER )?
      ( JSON_table_formatted_column_quotes_behavior QUOTES ( ON SCALAR STRING )? )?
      ( JSON_table_formatted_column_empty_behavior ON EMPTY )?
      ( JSON_table_formatted_column_error_behavior ON ERROR )?

JSON_table_formatted_column_wrapper_behavior ::=
    WITHOUT ARRAY?
  | WITH ( CONDITIONAL | UNCONDITIONAL )?  ARRAY?

JSON_table_formatted_column_quotes_behavior ::=
    KEEP
  | OMIT

JSON_table_formatted_column_empty_behavior ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

JSON_table_formatted_column_error_behavior ::=
    ERROR
  | NULL
  | EMPTY ARRAY
  | EMPTY OBJECT

JSON_table_nested_columns ::=
  NESTED  PATH? JSON_table_nested_path_specification
      ( AS JSON_table_nested_path_name )?
  JSON_table_columns_clause

JSON_table_nested_path_specification ::=
  JSON_path_specification

JSON_table_nested_path_name ::=
  JSON_table_path_name

JSON_table_path_name ::=
  identifier

JSON_table_plan_clause ::=
    JSON_table_specific_plan
  | JSON_table_default_plan

JSON_table_specific_plan ::=
  PLAN left_paren JSON_table_plan right_paren

JSON_table_plan ::=
    JSON_table_path_name
  | JSON_table_plan_parent_child
  | JSON_table_plan_sibling

JSON_table_plan_parent_child ::=
    JSON_table_plan_outer
  | JSON_table_plan_inner

JSON_table_plan_outer ::=
  JSON_table_path_name OUTER JSON_table_plan_primary

JSON_table_plan_inner ::=
  JSON_table_path_name INNER JSON_table_plan_primary

JSON_table_plan_sibling ::=
    JSON_table_plan_union
  | JSON_table_plan_cross

JSON_table_plan_union ::=
  JSON_table_plan_primary UNION JSON_table_plan_primary
      ( UNION JSON_table_plan_primary )*

JSON_table_plan_cross ::=
  JSON_table_plan_primary CROSS JSON_table_plan_primary
      ( CROSS JSON_table_plan_primary )*

JSON_table_plan_primary ::=
    JSON_table_path_name
  | left_paren JSON_table_plan right_paren

JSON_table_default_plan ::=
  PLAN DEFAULT left_paren
      JSON_table_default_plan_choices right_paren

JSON_table_default_plan_choices ::=
    JSON_table_default_plan_inner_outer
        ( comma JSON_table_default_plan_union_cross )?
  | JSON_table_default_plan_union_cross
      ( comma JSON_table_default_plan_inner_outer )?

JSON_table_default_plan_inner_outer ::=
  INNER | OUTER

JSON_table_default_plan_union_cross ::=
  UNION | CROSS

JSON_table_error_behavior ::=
    ERROR
  | EMPTY

JSON_table_primitive ::=
  JSON_TABLE_PRIMITIVE left_paren
      JSON_API_common_syntax
      JSON_table_primitive_columns_clause
      JSON_table_error_behavior ON ERROR
  right_paren

JSON_table_primitive_columns_clause ::=
  COLUMNS left_paren
      JSON_table_primitive_column_definition
      ( comma JSON_table_primitive_column_definition )*
  right_paren

JSON_table_primitive_column_definition ::=
    JSON_table_ordinality_column_definition
  | JSON_table_regular_column_definition
  | JSON_table_formatted_column_definition
  | JSON_table_primitive_chaining_column

JSON_table_primitive_chaining_column ::=
  column_name FOR CHAINING
/*
7.12 where_clause

Function
Specify a table derived by the application of a search_condition to the result of the preceding from_clause.


Format
*/
where_clause ::=
  WHERE search_condition
/*
7.13 group_by_clause

Function
Specify a grouped table derived by the application of the group_by_clause to the result of the previously
specified clause.


Format
*/
group_by_clause ::=
  GROUP BY  set_quantifier? grouping_element_list

grouping_element_list ::=
  grouping_element ( comma grouping_element )*

grouping_element ::=
    ordinary_grouping_set
  | rollup_list
  | cube_list
  | grouping_sets_specification
  | empty_grouping_set

ordinary_grouping_set ::=
    grouping_column_reference
  | left_paren grouping_column_reference_list right_paren

grouping_column_reference ::=
  column_reference  collate_clause?

grouping_column_reference_list ::=
  grouping_column_reference ( comma grouping_column_reference )*

rollup_list ::=
  ROLLUP left_paren ordinary_grouping_set_list right_paren

ordinary_grouping_set_list ::=
  ordinary_grouping_set ( comma ordinary_grouping_set )*

cube_list ::=
  CUBE left_paren ordinary_grouping_set_list right_paren

grouping_sets_specification ::=
  GROUPING SETS left_paren grouping_set_list right_paren

grouping_set_list ::=
  grouping_set ( comma grouping_set )*

grouping_set ::=
    ordinary_grouping_set
  | rollup_list
  | cube_list
  | grouping_sets_specification
  | empty_grouping_set

empty_grouping_set ::=
  left_paren right_paren
/*
7.14 having_clause

Function
Specify a grouped table derived by the elimination of groups that do not satisfy a search_condition.


Format
*/
having_clause ::=
  HAVING search_condition
/*
7.15 window_clause

Function
Specify one or more window definitions.


Format
*/
window_clause ::=
  WINDOW window_definition_list

window_definition_list ::=
  window_definition ( comma window_definition )*

window_definition ::=
  new_window_name AS window_specification

new_window_name ::=
  window_name

window_specification ::=
  left_paren window_specification_details right_paren

window_specification_details ::=
  existing_window_name?
      window_partition_clause?
      window_order_clause?
      window_frame_clause?

existing_window_name ::=
  window_name

window_partition_clause ::=
  PARTITION BY window_partition_column_reference_list

window_partition_column_reference_list ::=
  window_partition_column_reference
      ( comma window_partition_column_reference )*

window_partition_column_reference ::=
  column_reference  collate_clause?

window_order_clause ::=
  ORDER BY sort_specification_list

window_frame_clause ::=
  row_pattern_measures?
      window_frame_units window_frame_extent
      window_frame_exclusion?
      row_pattern_common_syntax?

window_frame_units ::=
    ROWS
  | RANGE
  | GROUPS

window_frame_extent ::=
    window_frame_start
  | window_frame_between

window_frame_start ::=
    UNBOUNDED PRECEDING
  | window_frame_preceding
  | CURRENT ROW

window_frame_preceding ::=
  unsigned_value_specification PRECEDING

window_frame_between ::=
  BETWEEN window_frame_bound_1 AND window_frame_bound_2

window_frame_bound_1 ::=
  window_frame_bound

window_frame_bound_2 ::=
  window_frame_bound

window_frame_bound ::=
    window_frame_start
  | UNBOUNDED FOLLOWING
  | window_frame_following

window_frame_following ::=
  unsigned_value_specification FOLLOWING

window_frame_exclusion ::=
    EXCLUDE CURRENT ROW
  | EXCLUDE GROUP
  | EXCLUDE TIES
  | EXCLUDE NO OTHERS
/*
7.16 query_specification

Function
Specify a table derived from the result of a table_expression.


Format
*/
query_specification ::=
  SELECT set_quantifier? select_list table_expression

select_list ::=
    asterisk
  | select_sublist ( comma select_sublist )*

select_sublist ::=
    derived_column
  | qualified_asterisk

qualified_asterisk ::=
    asterisked_identifier_chain period asterisk
  | all_fields_reference

asterisked_identifier_chain ::=
  asterisked_identifier ( period asterisked_identifier )*

asterisked_identifier ::=
  identifier

derived_column ::=
  value_expression as_clause?

as_clause ::=
  AS? column_name

all_fields_reference ::=
  value_expression_primary period asterisk
      ( AS left_paren all_fields_column_name_list right_paren )?

all_fields_column_name_list ::=
  column_name_list
/*
7.17 query_expression

Function
Specify a table.


Format
*/
query_expression ::=
  with_clause? query_expression_body
      order_by_clause? result_offset_clause? fetch_first_clause?

with_clause ::=
  WITH RECURSIVE? with_list

with_list ::=
  with_list_element ( comma with_list_element )*

with_list_element ::=
  query_name ( left_paren with_column_list right_paren )?
      AS table_subquery  search_or_cycle_clause?

with_column_list ::=
  column_name_list

query_expression_body ::=
    query_term
  | query_expression_body UNION ( ALL | DISTINCT )?
       corresponding_spec? query_term
  | query_expression_body EXCEPT ( ALL | DISTINCT )?
       corresponding_spec? query_term

query_term ::=
    query_primary
  | query_term INTERSECT ( ALL | DISTINCT )?
       corresponding_spec? query_primary

query_primary ::=
    simple_table
  | left_paren query_expression_body
       order_by_clause?  result_offset_clause?  fetch_first_clause?
      right_paren

simple_table ::=
    query_specification
  | table_value_constructor
  | explicit_table

explicit_table ::=
  TABLE table_or_query_name

corresponding_spec ::=
  CORRESPONDING ( BY left_paren corresponding_column_list right_paren )?

corresponding_column_list ::=
  column_name_list

order_by_clause ::=
  ORDER BY sort_specification_list

result_offset_clause ::=
  OFFSET offset_row_count ( ROW | ROWS )

fetch_first_clause ::=
  FETCH ( FIRST | NEXT )  fetch_first_quantity? ( ROW | ROWS ) ( ONLY | WITH TIES )

fetch_first_quantity ::=
    fetch_first_row_count
  | fetch_first_percentage

offset_row_count ::=
  simple_value_specification

fetch_first_row_count ::=
  simple_value_specification

fetch_first_percentage ::=
  simple_value_specification PERCENT

/*
7.18 search_or_cycle_clause

Function
Specify the generation of ordering and cycle detection information in the result of recursive query expressions.


Format
*/
search_or_cycle_clause ::=
    search_clause
  | cycle_clause
  | search_clause cycle_clause

search_clause ::=
  SEARCH recursive_search_order SET sequence_column

recursive_search_order ::=
    DEPTH FIRST BY column_name_list
  | BREADTH FIRST BY column_name_list

sequence_column ::=
  column_name

cycle_clause ::=
  CYCLE cycle_column_list SET cycle_mark_column TO cycle_mark_value
      DEFAULT non_cycle_mark_value USING path_column

cycle_column_list ::=
  cycle_column ( comma cycle_column )*

cycle_column ::=
  column_name

cycle_mark_column ::=
  column_name

path_column ::=
  column_name

cycle_mark_value ::=
  value_expression

non_cycle_mark_value ::=
  value_expression
/*
7.19 subquery

Function
Specify a scalar value, a row, or a table derived from a query_expression.


Format
*/
scalar_subquery ::=
  subquery

row_subquery ::=
  subquery

table_subquery ::=
  subquery

subquery ::=
  left_paren query_expression right_paren
/*
8 Predicates

8.1      predicate

Function
Specify a condition that can be evaluated to give a boolean value.


Format
*/
predicate ::=
    comparison_predicate
  | between_predicate
  | in_predicate
  | like_predicate
  | similar_predicate
  | regex_like_predicate
  | null_predicate
  | quantified_comparison_predicate
  | exists_predicate
  | unique_predicate
  | normalized_predicate
  | match_predicate
  | overlaps_predicate
  | distinct_predicate
  | member_predicate
  | submultiset_predicate
  | set_predicate
  | type_predicate
  | period_predicate
  | JSON_predicate
  | JSON_exists_predicate
/*
8.2        comparison_predicate

Function
Specify a comparison of two row values.


Format
*/
comparison_predicate ::=
  row_value_predicand comparison_predicate_part_2

comparison_predicate_part_2 ::=
  comp_op row_value_predicand

comp_op ::=
    equals_operator
  | not_equals_operator
  | less_than_operator
  | greater_than_operator
  | less_than_or_equals_operator
  | greater_than_or_equals_operator
/*
8.3      between_predicate

Function
Specify a range comparison.


Format
*/
between_predicate ::=
  row_value_predicand between_predicate_part_2

between_predicate_part_2 ::=
  NOT? BETWEEN ( ASYMMETRIC | SYMMETRIC )?
      row_value_predicand AND row_value_predicand
/*
8.4      in_predicate

Function
Specify a quantified comparison.


Format
*/
in_predicate ::=
  row_value_predicand in_predicate_part_2

in_predicate_part_2 ::=
  NOT? IN in_predicate_value

in_predicate_value ::=
    table_subquery
  | left_paren in_value_list right_paren

in_value_list ::=
  row_value_expression ( comma row_value_expression )*
/*
8.5        like_predicate

Function
Specify a pattern-match comparison.


Format
*/
like_predicate ::=
    character_like_predicate
  | octet_like_predicate

character_like_predicate ::=
  row_value_predicand character_like_predicate_part_2

character_like_predicate_part_2 ::=
  NOT? LIKE character_pattern ( ESCAPE escape_character )?

character_pattern ::=
  character_value_expression

escape_character ::=
  character_value_expression

octet_like_predicate ::=
  row_value_predicand octet_like_predicate_part_2

octet_like_predicate_part_2 ::=
  NOT? LIKE octet_pattern ( ESCAPE escape_octet )?

octet_pattern ::=
  binary_value_expression

escape_octet ::=
  binary_value_expression
/*
8.6     similar_predicate

Function
Specify a character string similarity by means of a regular expression.


Format
*/
similar_predicate ::=
  row_value_predicand similar_predicate_part_2

similar_predicate_part_2 ::=
  NOT? SIMILAR TO similar_pattern ( ESCAPE escape_character )?

similar_pattern ::=
  character_value_expression

regular_expression ::=
    regular_term
  | regular_expression vertical_bar regular_term

regular_term ::=
    regular_factor
  | regular_term regular_factor

regular_factor ::=
    regular_primary
  | regular_primary      asterisk
  | regular_primary      plus_sign
  | regular_primary      question_mark
  | regular_primary      repeat_factor

repeat_factor ::=
  left_brace low_value  upper_limit? right_brace

upper_limit ::=
  comma  high_value?

low_value ::=
  unsigned_integer

high_value ::=
  unsigned_integer

regular_primary ::=
    character_specifier
  | percent
  | regular_character_set
  | left_paren regular_expression right_paren

character_specifier ::=
    non_escaped_character
  | escaped_character

non_escaped_character ::=
  "!! See the Syntax Rules."

escaped_character ::=
  "!! See the Syntax Rules."

regular_character_set ::=
    underscore
  | left_bracket character_enumeration+ right_bracket
  | left_bracket circumflex character_enumeration+ right_bracket
  | left_bracket character_enumeration_include+
      circumflex character_enumeration_exclude+ right_bracket

character_enumeration_include ::=
  character_enumeration

character_enumeration_exclude ::=
  character_enumeration

character_enumeration ::=
    character_specifier
  | character_specifier minus_sign character_specifier
  | left_bracket colon regular_character_set_identifier colon right_bracket

regular_character_set_identifier ::=
  identifier
/*
8.7        regex_like_predicate

Function
Specify a pattern-match comparison using an XQuery regular expression.


Format
*/
regex_like_predicate ::=
  row_value_predicand regex_like_predicate_part_2

regex_like_predicate_part_2 ::=
  NOT? LIKE_REGEX XQuery_pattern ( FLAG XQuery_option_flag )?
/*
8.8        null_predicate

Function
Specify a test for a null value.


Format
*/
null_predicate ::=
  row_value_predicand null_predicate_part_2

null_predicate_part_2 ::=
  IS NOT? NULL
/*
8.9        quantified_comparison_predicate

Function
Specify a quantified comparison.


Format
*/
quantified_comparison_predicate ::=
  row_value_predicand quantified_comparison_predicate_part_2

quantified_comparison_predicate_part_2 ::=
  comp_op quantifier table_subquery

quantifier ::=
    all
  | some

all ::=
  ALL

some ::=
    SOME
  | ANY
/*
8.10 exists_predicate

Function
Specify a test for a non-empty set.


Format
*/
exists_predicate ::=
  EXISTS table_subquery
/*
8.11 unique_predicate

Function
Specify a test for the absence of duplicate rows.


Format
*/
unique_predicate ::=
  UNIQUE table_subquery
/*
8.12 normalized_predicate

Function
Determine whether a character string value is normalized.


Format
*/
normalized_predicate ::=
  row_value_predicand normalized_predicate_part_2

normalized_predicate_part_2 ::=
  IS  NOT? normal_form? NORMALIZED
/*
8.13 match_predicate

Function
Specify a test for matching rows.


Format
*/
match_predicate ::=
  row_value_predicand match_predicate_part_2

match_predicate_part_2 ::=
  MATCH  UNIQUE? ( SIMPLE | PARTIAL | FULL )? table_subquery
/*
8.14 overlaps_predicate

Function
Specify a test for an overlap between two datetime periods.


Format
*/
overlaps_predicate ::=
  overlaps_predicate_part_1 overlaps_predicate_part_2

overlaps_predicate_part_1 ::=
  row_value_predicand_1

overlaps_predicate_part_2 ::=
  OVERLAPS row_value_predicand_2

row_value_predicand_1 ::=
  row_value_predicand

row_value_predicand_2 ::=
  row_value_predicand
/*
8.15 distinct_predicate

Function
Specify a test of whether two row values are distinct


Format
*/
distinct_predicate ::=
  row_value_predicand_3 distinct_predicate_part_2

distinct_predicate_part_2 ::=
  IS  NOT? DISTINCT FROM row_value_predicand_4

row_value_predicand_3 ::=
  row_value_predicand

row_value_predicand_4 ::=
  row_value_predicand
/*
8.16 member_predicate

Function
Specify a test of whether a value is a member of a multiset.


Format
*/
member_predicate ::=
  row_value_predicand member_predicate_part_2

member_predicate_part_2 ::=
  NOT? MEMBER OF? multiset_value_expression
/*
8.17 submultiset_predicate

Function
Specify a test of whether a multiset is a submultiset of another multiset.


Format
*/
submultiset_predicate ::=
  row_value_predicand submultiset_predicate_part_2

submultiset_predicate_part_2 ::=
  NOT? SUBMULTISET OF? multiset_value_expression
/*
8.18 set_predicate

Function
Specify a test of whether a multiset is a set (that is, does not contain any duplicates).


Format
*/
set_predicate ::=
  row_value_predicand set_predicate_part_2

set_predicate_part_2 ::=
  IS  NOT? "A" SET
/*
8.19 type_predicate

Function
Specify a type test.


Format
*/
type_predicate ::=
  row_value_predicand type_predicate_part_2

type_predicate_part_2 ::=
  IS  NOT? OF left_paren type_list right_paren

type_list ::=
  user_defined_type_specification
      ( comma user_defined_type_specification )*

user_defined_type_specification ::=
    inclusive_user_defined_type_specification
  | exclusive_user_defined_type_specification

inclusive_user_defined_type_specification ::=
  path_resolved_user_defined_type_name

exclusive_user_defined_type_specification ::=
  ONLY path_resolved_user_defined_type_name
/*
8.20 period_predicate

Function
Specify a test to determine the relationship between periods.


Format
*/
period_predicate ::=
    period_overlaps_predicate
  | period_equals_predicate
  | period_contains_predicate
  | period_precedes_predicate
  | period_succeeds_predicate
  | period_immediately_precedes_predicate
  | period_immediately_succeeds_predicate

period_overlaps_predicate ::=
  period_predicand_1 period_overlaps_predicate_part_2

period_overlaps_predicate_part_2 ::=
  OVERLAPS period_predicand_2

period_predicand_1 ::=
  period_predicand

period_predicand_2 ::=
  period_predicand

period_predicand ::=
    period_reference
  | PERIOD left_paren period_start_value comma period_end_value right_paren

period_reference ::=
  basic_identifier_chain

period_start_value ::=
  datetime_value_expression

period_end_value ::=
  datetime_value_expression

period_equals_predicate ::=
  period_predicand_1 period_equals_predicate_part_2

period_equals_predicate_part_2 ::=
  EQUALS period_predicand_2

period_contains_predicate ::=
  period_predicand_1 period_contains_predicate_part_2

period_contains_predicate_part_2 ::=
  CONTAINS period_or_point_in_time_predicand

period_or_point_in_time_predicand ::=
    period_predicand
  | datetime_value_expression

period_precedes_predicate ::=
  period_predicand_1 period_precedes_predicate_part_2

period_precedes_predicate_part_2 ::=
  PRECEDES period_predicand_2

period_succeeds_predicate ::=
  period_predicand_1 period_succeeds_predicate_part_2

period_succeeds_predicate_part_2 ::=
  SUCCEEDS period_predicand_2

period_immediately_precedes_predicate ::=
  period_predicand_1 period_immediately_precedes_predicate_part_2

period_immediately_precedes_predicate_part_2 ::=
  IMMEDIATELY PRECEDES period_predicand_2

period_immediately_succeeds_predicate ::=
  period_predicand_1 period_immediately_succeeds_predicate_part_2

period_immediately_succeeds_predicate_part_2 ::=
  IMMEDIATELY SUCCEEDS period_predicand_2
/*
8.21 search_condition

Function
Specify a condition that is True, False, or Unknown, depending on the value of a boolean_value_expression.


Format
*/
search_condition ::=
  boolean_value_expression
/*
8.22 JSON_predicate

Function
Test whether a string value is a JSON text.


Format
*/
JSON_predicate ::=
  string_value_expression  JSON_input_clause?
      IS  NOT? JSON
       JSON_predicate_type_constraint?
       JSON_key_uniqueness_constraint?

JSON_predicate_type_constraint ::=
    VALUE
  | ARRAY
  | OBJECT
  | SCALAR

JSON_key_uniqueness_constraint ::=
    WITH UNIQUE  KEYS?
  | WITHOUT UNIQUE  KEYS?
/*
8.23 JSON_exists_predicate

Function
Test whether a JSON path expression returns any SQL/JSON items.


Format
*/
JSON_exists_predicate ::=
  JSON_EXISTS left_paren
      JSON_API_common_syntax
      ( JSON_exists_error_behavior ON ERROR )?
  right_paren

JSON_exists_error_behavior ::=
  TRUE | FALSE | UNKNOWN | ERROR
/*
9 Additional common rules

9.38 SQL/JSON path language: lexical elements

Function
Specify the lexical analysis of the SQL/JSON path language.


Format
*/
SQL_JSON_special_symbol ::=
    asterisk
  | at_sign
  | comma
  | dollar_sign
  | double_ampersand
  | double_equals
  | double_vertical_bar
  | exclamation_mark
  | greater_than_operator
  | greater_than_or_equals_operator
  | left_bracket
  | left_paren
  | less_than_operator
  | less_than_or_equals_operator
  | minus_sign
  | not_equals_operator
  | percent
  | period
  | plus_sign
  | question_mark
  | right_bracket
  | right_paren
  | solidus

at_sign ::=
  '@'

double_ampersand ::=
  "&&"

double_equals ::=
  "=="

double_vertical_bar ::=
  "||"

exclamation_mark ::=
  '!'

SQL_JSON_key_word ::=
    "abs"
  | "ceiling"
  | "datetime"
  | "double"
  | "exists"
  | "false"
  |   "flag"
  |   "floor"
  |   "is"
  |   "keyvalue"
  |   "last"
  |   "lax"
  |   "like_regex"
  |   "null"
  |   "size"
  |   "starts"
  |   "strict"
  |   "to"
  |   "true"
  |   "type"
  |   "unknown"
  |   "with"

JSON_path_literal ::=
  "!! See the Syntax Rules."

JSON_path_string_literal ::=
  "!! See the Syntax Rules."

JSON_path_numeric_literal ::=
  "!! See the Syntax Rules."

JSON_path_identifier ::=
  "!! See the Syntax Rules."

JSON_path_context_variable ::=
  "!! See the Syntax Rules."

JSON_path_named_variable ::=
  "!! See the Syntax Rules."

JSON_path_key_name ::=
  "!! See the Syntax Rules."
/*
9.39 SQL/JSON path language: syntax and semantics

Function
Specify the syntax and semantics of SQL/JSON path language.


Format
*/
JSON_path_expression ::=
  JSON_path_mode JSON_path_wff

JSON_path_mode ::=
  "strict" | "lax"

JSON_path_primary ::=
    JSON_path_literal
  | JSON_path_variable
  | left_paren JSON_path_wff right_paren

JSON_path_variable ::=
    JSON_path_context_variable
  | JSON_path_named_variable
  | at_sign
  | JSON_last_subscript

JSON_path_context_variable ::=
  dollar_sign

JSON_path_named_variable ::=
  dollar_sign JSON_path_identifier

JSON_last_subscript ::=
  "last"

JSON_accessor_expression ::=
    JSON_path_primary
  | JSON_accessor_expression JSON_accessor_op

JSON_accessor_op ::=
      JSON____member_accessor
  |   JSON____wildcard_member_accessor
  |   JSON____array_accessor
  |   JSON____wildcard_array_accessor
  |   JSON____filter_expression
  |   JSON____item_method

JSON_member_accessor ::=
    period JSON_path_key_name
  | period JSON_path_string_literal
/*
      NOTE 447 - Unlike [ECMAScript], SQL/JSON path language does not provide a member accessor using brackets that enclose
      a character string.
*/

JSON_wildcard_member_accessor ::=
  period asterisk

JSON_array_accessor ::=
  left_bracket JSON_subscript_list right_bracket

JSON_subscript_list ::=
  JSON_subscript ( comma JSON_subscript )*

JSON_subscript ::=
    JSON_path_wff_1
  | JSON_path_wff_2 "to" JSON_path_wff_3

JSON_path_wff_1 ::=
  JSON_path_wff

JSON_path_wff_2 ::=
  JSON_path_wff

JSON_path_wff_3 ::=
  JSON_path_wff

JSON_wildcard_array_accessor ::=
  left_bracket asterisk right_bracket

JSON_filter_expression ::=
  question_mark left_paren JSON_path_predicate right_paren
/*
      NOTE 448 - Unlike [ECMAScript], predicates are not expressions; instead they form a separate language that can only be invoked
      within a JSON_filter_expression.
*/

JSON_item_method ::=
  period JSON_method

JSON_method ::=
    "type" left_paren right_paren
  | "size" left_paren right_paren
  | "double" left_paren right_paren
  | "ceiling" left_paren right_paren
  | "floor" left_paren right_paren
  | "abs" left_paren right_paren
  | "datetime" left_paren  JSON_datetime_template? right_paren
  | "keyvalue" left_paren right_paren

JSON_datetime_template ::=
  JSON_path_string_literal
JSON_unary_expression ::=
    JSON_accessor_expression
  | plus_sign JSON_unary_expression
  | minus_sign JSON_unary_expression

JSON_multiplicative_expression ::=
    JSON_unary_expression
  | JSON_multiplicative_expression asterisk JSON_unary_expression
  | JSON_multiplicative_expression solidus JSON_unary_expression
  | JSON_multiplicative_expression percent JSON_unary_expression

JSON_additive_expression ::=
    JSON_multiplicative_expression
  | JSON_additive_expression plus_sign JSON_multiplicative_expression
  | JSON_additive_expression minus_sign JSON_multiplicative_expression

JSON_path_wff ::=
  JSON_additive_expression
/*
   NOTE 449 - This concludes the main language for JSON path expressions. Next comes the language for predicates, used only
   in JSON_filter_expression.
*/
JSON_predicate_primary ::=
    JSON_delimited_predicate
  | JSON_non_delimited_predicate

JSON_delimited_predicate ::=
    JSON_exists_path_predicate
  | left_paren JSON_path_predicate right_paren

JSON_non_delimited_predicate ::=
    JSON_comparison_predicate
  | JSON_like_regex_predicate
  | JSON_starts_with_predicate
  | JSON_unknown_predicate

JSON_exists_path_predicate ::=
  "exists" left_paren JSON_path_wff right_paren

JSON_comparison_predicate ::=
  JSON_path_wff JSON_comp_op JSON_path_wff
/*
   NOTE 450 - Comparison operators are not left associative, unlike [ECMAScript].
*/
JSON_comp_op ::=
    double_equals
  | not_equals_operator
  | less_than_operator
  | greater_than_operator
  | less_than_or_equals_operator
  | greater_than_or_equals_operator
/*
   NOTE 451 - Equality operators have the same precedence as inequality comparison operators, unlike [ECMAScript].
*/
JSON_like_regex_predicate ::=
  JSON_path_wff "like_regex" JSON_like_regex_pattern
      ( "flag" JSON_like_regex_flags )?

JSON_like_regex_pattern ::=
  JSON_path_string_literal
JSON_like_regex_flags ::=
  JSON_path_string_literal

JSON_starts_with_predicate ::=
  JSON_starts_with_whole "starts" "with" JSON_starts_with_initial

JSON_starts_with_whole ::=
  JSON_path_wff

JSON_starts_with_initial ::=
    JSON_path_string_literal
  | JSON_path_named_variable

JSON_unknown_predicate ::=
  left_paren JSON_path_predicate right_paren "is" "unknown"

JSON_boolean_negation ::=
    JSON_predicate_primary
  | exclamation_mark JSON_delimited_predicate

JSON_boolean_conjunction ::=
    JSON_boolean_negation
  | JSON_boolean_conjunction double_ampersand JSON_boolean_negation

JSON_boolean_disjunction ::=
    JSON_boolean_conjunction
  | JSON_boolean_disjunction double_vertical_bar JSON_boolean_conjunction

JSON_path_predicate ::=
  JSON_boolean_disjunction
/*
9.44 Datetime templates

Function
Specify the templates to use to convert between datetime types and character string types.


Format
*/
datetime_template ::=
   datetime_template_part+

datetime_template_part ::=
    datetime_template_field
  | datetime_template_delimiter

datetime_template_field ::=
    datetime_template_year
  | datetime_template_rounded_year
  | datetime_template_month
  | datetime_template_day_of_month
  | datetime_template_day_of_year
  | datetime_template_12_hour
  | datetime_template_24_hour
  | datetime_template_minute
  | datetime_template_second_of_minute
  | datetime_template_second_of_day
  | datetime_template_fraction
  | datetime_template_am_pm
  | datetime_template_time_zone_hour
  | datetime_template_time_zone_minute

datetime_template_delimiter ::=
    minus_sign
  | period
  | solidus
  | comma
  | apostrophe
  | semicolon
  | colon
  | space

datetime_template_year ::=
  YYYY | YYY | YY | "Y"

datetime_template_rounded_year ::=
  RRRR | RR
datetime_template_month ::=
  MM

datetime_template_day_of_month ::=
  DD

datetime_template_day_of_year ::=
  DDD

datetime_template_12_hour ::=
  HH | "HH12"

datetime_template_24_hour ::=
  "HH24"

datetime_template_minute ::=
  MI

datetime_template_second_of_minute ::=
  SS

datetime_template_second_of_day ::=
  SSSSS

datetime_template_fraction ::=
  "FF1" | "FF2" | "FF3" | "FF4" | "FF5" | "FF6" | "FF7" | "FF8" | "FF9"

datetime_template_am_pm ::=
  "A.M." | "P.M."

datetime_template_time_zone_hour ::=
  TZH

datetime_template_time_zone_minute ::=
  TZM

/*
10 Additional common elements


10.1 interval_qualifier

Function
Specify the precision of an interval data type.


Format
*/
interval_qualifier ::=
    start_field TO end_field
  | single_datetime_field

start_field ::=
  non_second_primary_datetime_field
      ( left_paren interval_leading_field_precision right_paren )?

end_field ::=
    non_second_primary_datetime_field
  | SECOND ( left_paren interval_fractional_seconds_precision right_paren )?

single_datetime_field ::=
    non_second_primary_datetime_field
        ( left_paren interval_leading_field_precision right_paren )?
  | SECOND ( left_paren interval_leading_field_precision
      ( comma interval_fractional_seconds_precision )? right_paren )?

primary_datetime_field ::=
    non_second_primary_datetime_field
  | SECOND

non_second_primary_datetime_field ::=
    YEAR
  | MONTH
  | DAY
  | HOUR
  | MINUTE

interval_fractional_seconds_precision ::=
  unsigned_integer

interval_leading_field_precision ::=
  unsigned_integer
/*
10.2 language_clause


Function
Specify a programming language.


Format
*/
language_clause ::=
  LANGUAGE language_name

language_name ::=
    ADA
  | "C"
  | COBOL
  | FORTRAN
  | ("M" | MUMPS)
  | PASCAL
  | PLI
  | SQL
/*
10.3 path_specification

Function
Specify an order for searching for an SQL-invoked routine.


Format
*/
path_specification ::=
  PATH schema_name_list

schema_name_list ::=
  schema_name ( comma schema_name )*
/*
10.4 routine_invocation

Function
Invoke an SQL-invoked routine.


Format
*/
routine_invocation ::=
  routine_name SQL_argument_list

routine_name ::=
   schema_name period? qualified_identifier

SQL_argument_list ::=
  left_paren
      ( SQL_argument ( comma SQL_argument )*  copartition_clause? )?
      right_paren

SQL_argument ::=
    value_expression
  | generalized_expression
  | target_specification
  | contextually_typed_value_specification
  | named_argument_specification
  | table_argument
  | descriptor_argument

generalized_expression ::=
  value_expression AS path_resolved_user_defined_type_name

named_argument_specification ::=
  SQL_parameter_name named_argument_assignment_token
      named_argument_SQL_argument

named_argument_SQL_argument ::=
    value_expression
  | target_specification
  | contextually_typed_value_specification
  | table_argument
  | descriptor_argument

table_argument ::=
  table_argument_proper
      (  AS? table_argument_correlation_name
      table_argument_parenthesized_derived_column_list? )?
      table_argument_partitioning?
      table_argument_pruning?
      table_argument_ordering?

table_argument_correlation_name ::=
  correlation_name

table_argument_parenthesized_derived_column_list ::=
  parenthesized_derived_column_list

table_argument_proper ::=
    TABLE left_paren table_or_query_name right_paren
  | TABLE table_subquery
  | table_function_invocation

table_function_invocation ::=
  routine_invocation

table_argument_partitioning ::=
  PARTITION BY table_argument_partitioning_list

table_argument_partitioning_list ::=
    column_reference
  | left_paren ( column_reference ( comma column_reference )* )? right_paren

table_argument_pruning ::=
    PRUNE WHEN EMPTY
  | KEEP WHEN EMPTY

table_argument_ordering ::=
  ORDER BY table_argument_ordering_list

table_argument_ordering_list ::=
    table_argument_ordering_column
  | left_paren
      table_argument_ordering_column
      ( comma table_argument_ordering_column )*
      right_paren

table_argument_ordering_column ::=
  column_reference ordering_specification?  null_ordering?

copartition_clause ::=
  COPARTITION copartition_list

copartition_list ::=
  copartition_specification ( comma copartition_specification )*

copartition_specification ::=
  left_paren range_variable comma range_variable
      ( comma range_variable )* right_paren

range_variable ::=
    table_name
  | query_name
  | correlation_name

descriptor_argument ::=
    descriptor_value_constructor
  | CAST left_paren NULL AS DESCRIPTOR right_paren

/*
10.5 character_set_specification

Function
Identify a character set.


Format
*/
character_set_specification ::=
    standard_character_set_name
  | implementation_defined_character_set_name
  | user_defined_character_set_name

standard_character_set_name ::=
  character_set_name

implementation_defined_character_set_name ::=
  character_set_name

user_defined_character_set_name ::=
  character_set_name
/*
10.6 specific_routine_designator

Function
Specify an SQL-invoked routine.


Format
*/
specific_routine_designator ::=
    SPECIFIC routine_type specific_name
  | routine_type member_name ( FOR schema_resolved_user_defined_type_name )?

routine_type ::=
    ROUTINE
  | FUNCTION
  | PROCEDURE
  | ( INSTANCE | STATIC | CONSTRUCTOR )? METHOD

member_name ::=
  member_name_alternatives  data_type_list?

member_name_alternatives ::=
    schema_qualified_routine_name
  | method_name

data_type_list ::=
  left_paren ( data_type ( comma data_type )* )? right_paren
/*
10.7 collate_clause

Function
Specify a default collation.


Format
*/
collate_clause ::=
  COLLATE collation_name
/*
10.8 constraint_name_definition and constraint_characteristics

Function
Specify the name of a constraint and its characteristics.


Format
*/
constraint_name_definition ::=
  CONSTRAINT constraint_name

constraint_characteristics ::=
    constraint_check_time ( NOT? DEFERRABLE )?  constraint_enforcement?
  | NOT? DEFERRABLE  constraint_check_time?  constraint_enforcement?
  | constraint_enforcement

constraint_check_time ::=
    INITIALLY DEFERRED
  | INITIALLY IMMEDIATE

constraint_enforcement ::=
  NOT? ENFORCED
/*
10.9 aggregate_function

Function
Specify a value computed from a collection of rows.


Format
*/
aggregate_function ::=
    COUNT left_paren asterisk right_paren  filter_clause?
  | general_set_function  filter_clause?
  | binary_set_function  filter_clause?
  | ordered_set_function  filter_clause?
  | array_aggregate_function  filter_clause?
  | row_pattern_count_function  filter_clause?
  | JSON_aggregate_function  filter_clause?

general_set_function ::=
  set_function_type left_paren  set_quantifier?
      value_expression right_paren

set_function_type ::=
  computational_operation

computational_operation ::=
    AVG
  | MAX
  | MIN
  | SUM
  | EVERY
  | ANY
  | SOME
  | COUNT
  | STDDEV_POP
  | STDDEV_SAMP
  | VAR_SAMP
  | VAR_POP
  | COLLECT
  | FUSION
  | INTERSECTION

set_quantifier ::=
    DISTINCT
  | ALL

filter_clause ::=
  FILTER left_paren WHERE search_condition right_paren

binary_set_function ::=
  binary_set_function_type left_paren dependent_variable_expression comma
      independent_variable_expression right_paren

binary_set_function_type ::=
    COVAR_POP
  | COVAR_SAMP
  | CORR
  | REGR_SLOPE
  | REGR_INTERCEPT
  | REGR_COUNT
  | "REGR_R2"
  | REGR_AVGX
  | REGR_AVGY
  | REGR_SXX
  | REGR_SYY
  | REGR_SXY

dependent_variable_expression ::=
  numeric_value_expression

independent_variable_expression ::=
  numeric_value_expression

ordered_set_function ::=
    hypothetical_set_function
  | inverse_distribution_function
  | listagg_set_function

hypothetical_set_function ::=
  rank_function_type left_paren
      hypothetical_set_function_value_expression_list right_paren
      within_group_specification

within_group_specification ::=
  WITHIN GROUP left_paren ORDER BY sort_specification_list right_paren

hypothetical_set_function_value_expression_list ::=
  value_expression ( comma value_expression )*

inverse_distribution_function ::=
  inverse_distribution_function_type left_paren
      inverse_distribution_function_argument right_paren
      within_group_specification

inverse_distribution_function_argument ::=
  numeric_value_expression

inverse_distribution_function_type ::=
    PERCENTILE_CONT
  | PERCENTILE_DISC

listagg_set_function ::=
  LISTAGG left_paren  set_quantifier? character_value_expression
      comma listagg_separator  listagg_overflow_clause? right_paren
      within_group_specification

listagg_separator ::=
  character_string_literal

listagg_overflow_clause ::=
  ON OVERFLOW overflow_behavior

overflow_behavior ::=
    ERROR
  | TRUNCATE  listagg_truncation_filler? listagg_count_indication

listagg_truncation_filler ::=
  character_string_literal

listagg_count_indication ::=
    WITH COUNT
  | WITHOUT COUNT

array_aggregate_function ::=
  ARRAY_AGG
      left_paren value_expression ( ORDER BY sort_specification_list )? right_paren

row_pattern_count_function ::=
  COUNT left_paren row_pattern_variable_name period asterisk right_paren
/*
10.10 sort_specification_list

Function
Specify a sort order.


Format
*/
sort_specification_list ::=
  sort_specification ( comma sort_specification )*

sort_specification ::=
  sort_key  ordering_specification?  null_ordering?

sort_key ::=
  value_expression

ordering_specification ::=
    ASC
  | DESC

null_ordering ::=
    NULLS FIRST
  | NULLS LAST

/*
10.11 JSON_aggregate_function

Function
Construct a JSON object or a JSON array from an aggregation of SQL data.


Format
*/
JSON_aggregate_function ::=
    JSON_object_aggregate_constructor
  | JSON_array_aggregate_constructor

JSON_object_aggregate_constructor ::=
  JSON_OBJECTAGG left_paren
      JSON_name_and_value
       JSON_constructor_null_clause?
       JSON_key_uniqueness_constraint?
       JSON_output_clause?
      right_paren

JSON_array_aggregate_constructor ::=
  JSON_ARRAYAGG left_paren
      JSON_value_expression
       JSON_array_aggregate_order_by_clause?
       JSON_constructor_null_clause?
       JSON_output_clause?
      right_paren

JSON_array_aggregate_order_by_clause ::=
  ORDER BY sort_specification_list

/*
10.12 JSON_value_expression

Function
Specify a value to be used as input by an SQL/JSON function.


Format
*/
JSON_value_expression ::=
  value_expression  JSON_input_clause?

JSON_input_clause ::=
  FORMAT JSON_representation

/*
10.13 JSON_output_clause

Function
Specify the data type, format, and encoding of the JSON text created by a JSON-returning function.


Format
*/
JSON_output_clause ::=
  RETURNING data_type ( FORMAT JSON_representation )?

JSON_representation ::=
    JSON ( ENCODING ( "UTF8" | "UTF16" | "UTF32" ) )?
  | implementation_defined_JSON_representation_option

implementation_defined_JSON_representation_option ::=
  "!! See the Syntax Rules."

/*
10.14 JSON_API_common_syntax

Subclause Signature
"<JSON API common syntax>" General Rules? (
  Parameter: "JSON API COMMON SYNTAX"
) Returns: STATUS and "SQL/JSON SEQUENCE"


Function
Define the inputs to JSON_VALUE, JSON_QUERY, JSON_TABLE, and JSON_EXISTS.


Format
*/
JSON_API_common_syntax ::=
  JSON_context_item comma JSON_path_specification ( AS JSON_table_path_name )?
       JSON_passing_clause?

JSON_context_item ::=
  JSON_value_expression

JSON_path_specification ::=
  character_string_literal

JSON_passing_clause ::=
  PASSING JSON_argument ( comma JSON_argument )*

JSON_argument ::=
  JSON_value_expression AS identifier

/*
11 Schema definition and manipulation


11.1 schema_definition

Function
Define a schema.


Format
*/
schema_definition ::=
  CREATE SCHEMA schema_name_clause
      schema_character_set_or_path?
      schema_element*

schema_character_set_or_path ::=
    schema_character_set_specification
  | schema_path_specification
  | schema_character_set_specification schema_path_specification
  | schema_path_specification schema_character_set_specification

schema_name_clause ::=
    schema_name
  | AUTHORIZATION schema_authorization_identifier
  | schema_name AUTHORIZATION schema_authorization_identifier

schema_authorization_identifier ::=
  authorization_identifier

schema_character_set_specification ::=
  DEFAULT CHARACTER SET character_set_specification

schema_path_specification ::=
  path_specification

schema_element ::=
      table_definition
  |   view_definition
  |   domain_definition
  |   character_set_definition
  |   collation_definition
  |   transliteration_definition
  |   assertion_definition
  |   trigger_definition
  |   user_defined_type_definition
  |   user_defined_cast_definition
  |   user_defined_ordering_definition
  |   transform_definition
  |   schema_routine
  |   sequence_generator_definition
  |   grant_statement
  |   role_definition
/*
11.2 drop_schema_statement

Function
Destroy a schema.


Format
*/
drop_schema_statement ::=
  DROP SCHEMA schema_name drop_behavior

drop_behavior ::=
    CASCADE
  | RESTRICT
/*
11.3 table_definition

Function
Define a persistent base table, a created local temporary table, or a global temporary table.


Format
*/
table_definition ::=
  CREATE  table_scope? TABLE table_name table_contents_source
      ( WITH system_versioning_clause )?
      ( ON COMMIT table_commit_action ROWS )?

table_contents_source ::=
    table_element_list
  | typed_table_clause
  | as_subquery_clause

table_scope ::=
  global_or_local TEMPORARY

global_or_local ::=
    GLOBAL
  | LOCAL

system_versioning_clause ::=
  SYSTEM VERSIONING

table_commit_action ::=
    PRESERVE
  | DELETE

table_element_list ::=
  left_paren table_element ( comma table_element )* right_paren

table_element ::=
    column_definition
  | table_period_definition
  | table_constraint_definition
  | like_clause

typed_table_clause ::=
  OF path_resolved_user_defined_type_name  subtable_clause?
       typed_table_element_list?

typed_table_element_list ::=
  left_paren typed_table_element
      ( comma typed_table_element )* right_paren

typed_table_element ::=
    column_options
  | table_constraint_definition
  | self_referencing_column_specification

self_referencing_column_specification ::=
  REF IS self_referencing_column_name  reference_generation?

reference_generation ::=
    SYSTEM GENERATED
  | USER GENERATED
  | DERIVED

self_referencing_column_name ::=
  column_name

column_options ::=
  column_name WITH OPTIONS column_option_list

column_option_list ::=
  scope_clause? default_clause? column_constraint_definition*

subtable_clause ::=
  UNDER supertable_clause

supertable_clause ::=
  supertable_name

supertable_name ::=
  table_name

like_clause ::=
  LIKE table_name  like_options?

like_options ::=
  like_option+

like_option ::=
    identity_option
  | column_default_option
  | generation_option

identity_option ::=
    INCLUDING IDENTITY
  | EXCLUDING IDENTITY

column_default_option ::=
    INCLUDING DEFAULTS
  | EXCLUDING DEFAULTS

generation_option ::=
    INCLUDING GENERATED
  | EXCLUDING GENERATED

as_subquery_clause ::=
  ( left_paren column_name_list right_paren )? AS table_subquery
      with_or_without_data

with_or_without_data ::=
    WITH NO DATA
  | WITH DATA

table_period_definition ::=
  system_or_application_time_period_specification
      left_paren period_begin_column_name comma period_end_column_name right_paren

system_or_application_time_period_specification ::=
    system_time_period_specification
  | application_time_period_specification

system_time_period_specification ::=
  PERIOD FOR SYSTEM_TIME

application_time_period_specification ::=
  PERIOD FOR application_time_period_name

application_time_period_name ::=
  identifier

period_begin_column_name ::=
  column_name

period_end_column_name ::=
  column_name
/*
11.4 column_definition

Function
Define a column of a base table.


Format
*/
column_definition ::=
  column_name data_type_or_domain_name?
      ( default_clause | identity_column_specification | generation_clause
      | system_time_period_start_column_specification
      | system_time_period_end_column_specification )?
      column_constraint_definition*
      collate_clause?

data_type_or_domain_name ::=
    data_type
  | domain_name

system_time_period_start_column_specification ::=
  timestamp_generation_rule AS ROW START

system_time_period_end_column_specification ::=
  timestamp_generation_rule AS ROW END

timestamp_generation_rule ::=
  GENERATED ALWAYS

column_constraint_definition ::=
   constraint_name_definition? column_constraint  constraint_characteristics?

column_constraint ::=
    NOT NULL
  | unique_specification
  | references_specification
  | check_constraint_definition

identity_column_specification ::=
  GENERATED ( ALWAYS | BY DEFAULT ) AS IDENTITY
      ( left_paren common_sequence_generator_options right_paren )?

generation_clause ::=
  generation_rule AS generation_expression

generation_rule ::=
  GENERATED ALWAYS

generation_expression ::=
  left_paren value_expression right_paren
/*
11.5 default_clause

Function
Specify the default for a column, domain, or attribute.


Format
*/
default_clause ::=
  DEFAULT default_option

default_option ::=
    literal
  | datetime_value_function
  | USER
  | CURRENT_USER
  | CURRENT_ROLE
  | SESSION_USER
  | SYSTEM_USER
  | CURRENT_CATALOG
  | CURRENT_SCHEMA
  | CURRENT_PATH
  | implicitly_typed_value_specification
/*
11.6 table_constraint_definition

Function
Specify an integrity constraint.


Format
*/
table_constraint_definition ::=
   constraint_name_definition? table_constraint
       constraint_characteristics?

table_constraint ::=
    unique_constraint_definition
  | referential_constraint_definition
  | check_constraint_definition
/*
11.7 unique_constraint_definition

Function
Specify a uniqueness constraint for a table.


Format
*/
unique_constraint_definition ::=
    unique_specification left_paren unique_column_list ( comma without_overlap_specification )? right_paren
  | UNIQUE  VALUE?

unique_specification ::=
    UNIQUE
  | PRIMARY KEY

unique_column_list ::=
  column_name_list

without_overlap_specification ::=
  application_time_period_name WITHOUT OVERLAPS
/*
11.8 referential_constraint_definition

Function
Specify a referential constraint.


Format
*/
referential_constraint_definition ::=
  FOREIGN KEY left_paren referencing_column_list
      ( comma referencing_period_specification )? right_paren
      references_specification

references_specification ::=
  REFERENCES referenced_table_and_columns
      ( MATCH match_type )?  referential_triggered_action?

match_type ::=
    FULL
  | PARTIAL
  | SIMPLE

referencing_column_list ::=
  column_name_list

referencing_period_specification ::=
  PERIOD application_time_period_name

referenced_table_and_columns ::=
  table_name ( left_paren referenced_column_list
      ( comma referenced_period_specification )? right_paren )?

referenced_column_list ::=
  column_name_list

referenced_period_specification ::=
  PERIOD application_time_period_name

referential_triggered_action ::=
    update_rule  delete_rule?
  | delete_rule  update_rule?

update_rule ::=
  ON UPDATE referential_action

delete_rule ::=
  ON DELETE referential_action

referential_action ::=
    CASCADE
  | SET NULL
  | SET DEFAULT
  | RESTRICT
  | NO ACTION
/*
11.9 check_constraint_definition

Function
Specify a condition for the SQL-data.


Format
*/
check_constraint_definition ::=
     CHECK left_paren search_condition right_paren
/*
11.10 alter_table_statement

Function
Change the definition of a table.


Format
*/
alter_table_statement ::=
  ALTER TABLE table_name alter_table_action

alter_table_action ::=
    add_column_definition
  | alter_column_definition
  | drop_column_definition
  | add_table_constraint_definition
  | alter_table_constraint_definition
  | drop_table_constraint_definition
  | add_table_period_definition
  | drop_table_period_definition
  | add_system_versioning_clause
  | drop_system_versioning_clause
/*
11.11 add_column_definition

Function
Add a column to a table.


Format
*/
add_column_definition ::=
  ADD  COLUMN? column_definition
/*
11.12 alter_column_definition

Function
Change a column and its definition.


Format
*/
alter_column_definition ::=

  ALTER  COLUMN? column_name alter_column_action

alter_column_action ::=
    set_column_default_clause
  | drop_column_default_clause
  | set_column_not_null_clause
  | drop_column_not_null_clause
  | add_column_scope_clause
  | drop_column_scope_clause
  | alter_column_data_type_clause
  | alter_identity_column_specification
  | drop_identity_property_clause
  | drop_column_generation_expression_clause
/*
11.13 set_column_default_clause

Function
Set the default clause for a column.


Format
*/
set_column_default_clause ::=
  SET default_clause
/*
11.14 drop_column_default_clause

Function
Drop the default clause from a column.


Format
*/
drop_column_default_clause ::=
  DROP DEFAULT
/*
11.15 set_column_not_null_clause

Function
Add a not null constraint to a column.


Format
*/
set_column_not_null_clause ::=
  SET NOT NULL
/*
11.16 drop_column_not_null_clause

Function
Drop a not null constraint on a column.


Format
*/
drop_column_not_null_clause ::=
  DROP NOT NULL
/*
11.17 add_column_scope_clause

Function
Add a non-empty scope for an existing column of data type REF in a base table.


Format
*/
add_column_scope_clause ::=
  ADD scope_clause
/*
11.18 drop_column_scope_clause

Function
Drop the scope from an existing column of data type REF in a base table.


Format
*/
drop_column_scope_clause ::=
  DROP SCOPE drop_behavior
/*
11.19 alter_column_data_type_clause

Function
Change the declared type of a column.


Format
*/
alter_column_data_type_clause ::=
  SET DATA TYPE data_type
/*
11.20 alter_identity_column_specification

Function
Change the options specified for an identity column.


Format
*/
alter_identity_column_specification ::=
    set_identity_column_generation_clause alter_identity_column_option*
  | alter_identity_column_option+

set_identity_column_generation_clause ::=
  SET GENERATED ( ALWAYS | BY DEFAULT )

alter_identity_column_option ::=
    alter_sequence_generator_restart_option
  | SET basic_sequence_generator_option
/*
11.21 drop_identity_property_clause

Function
Convert an identity column to a column that is not an identity column.


Format
*/
drop_identity_property_clause ::=
  DROP IDENTITY
/*
11.22 drop_column_generation_expression_clause

Function
Convert a generated column to a column that is not a generated column.


Format
*/
drop_column_generation_expression_clause ::=
  DROP EXPRESSION
/*
11.23 drop_column_definition

Function
Destroy a column of a base table.


Format
*/
drop_column_definition ::=
  DROP  COLUMN? column_name drop_behavior
/*
11.24 add_table_constraint_definition

Function
Add a constraint to a table.


Format
*/
add_table_constraint_definition ::=
  ADD table_constraint_definition
/*
11.25 alter_table_constraint_definition

Function
Change the definition of a table constraint.


Format
*/
alter_table_constraint_definition ::=
  ALTER CONSTRAINT constraint_name constraint_enforcement
/*
11.26 drop_table_constraint_definition

Function
Destroy a constraint on a table.


Format
*/
drop_table_constraint_definition ::=
  DROP CONSTRAINT constraint_name drop_behavior
/*
11.27 add_table_period_definition

Function
Add a system-time period or an application-time period to a persistent base table.


Format
*/
add_table_period_definition ::=
  ADD table_period_definition  add_system_time_period_column_list?

add_system_time_period_column_list ::=
  ADD  COLUMN? column_definition_1 ADD  COLUMN? column_definition_2

column_definition_1 ::=
  column_definition

column_definition_2 ::=
  column_definition
/*
11.28 drop_table_period_definition

Function
Remove a system-time period or application-time period from a persistent base table.


Format
*/
drop_table_period_definition ::=
  DROP system_or_application_time_period_specification drop_behavior
/*
11.29 add_system_versioning_clause

Function
Alter a regular persistent base table to a system-versioned table.


Format
*/
add_system_versioning_clause ::=
  ADD system_versioning_clause
/*
11.30 drop_system_versioning_clause

Function
Change a system-versioned table into a regular persistent base table.


Format
*/
drop_system_versioning_clause ::=
  DROP SYSTEM VERSIONING drop_behavior
/*
11.31 drop_table_statement

Function
Destroy a table.


Format
*/
drop_table_statement ::=
  DROP TABLE table_name drop_behavior
/*
11.32 view_definition

Function
Define a viewed table.


Format
*/
view_definition ::=
  CREATE  RECURSIVE? VIEW table_name view_specification
      AS query_expression ( WITH  levels_clause? CHECK OPTION )?

view_specification ::=
    regular_view_specification
  | referenceable_view_specification

regular_view_specification ::=
  ( left_paren view_column_list right_paren )?

referenceable_view_specification ::=
  OF path_resolved_user_defined_type_name  subview_clause?
       view_element_list?

subview_clause ::=
  UNDER table_name

view_element_list ::=
  left_paren view_element ( comma view_element )* right_paren

view_element ::=
    self_referencing_column_specification
  | view_column_option

view_column_option ::=
  column_name WITH OPTIONS scope_clause

levels_clause ::=
    CASCADED
  | LOCAL

view_column_list ::=
  column_name_list
/*
11.33 drop_view_statement

Function
Destroy a view.


Format
*/
drop_view_statement ::=
  DROP VIEW table_name drop_behavior
/*
11.34 domain_definition

Function
Define a domain.


Format
*/
domain_definition ::=
  CREATE DOMAIN domain_name AS? predefined_type
      default_clause?
      domain_constraint*
      collate_clause?

domain_constraint ::=
   constraint_name_definition? check_constraint_definition
      constraint_characteristics?
/*
11.35 alter_domain_statement

Function
Change a domain and its definition.


Format
*/
alter_domain_statement ::=
  ALTER DOMAIN domain_name alter_domain_action

alter_domain_action ::=
    set_domain_default_clause
  | drop_domain_default_clause
  | add_domain_constraint_definition
  | drop_domain_constraint_definition
/*
11.36 set_domain_default_clause

Function
Set the default value in a domain.


Format
*/
set_domain_default_clause ::=
  SET default_clause
/*
11.37 drop_domain_default_clause

Function
Remove the default clause of a domain.


Format
*/
drop_domain_default_clause ::=
  DROP DEFAULT

/*
11.38 add_domain_constraint_definition

Function
Add a constraint to a domain.


Format
*/
add_domain_constraint_definition ::=
  ADD domain_constraint
/*
11.39 drop_domain_constraint_definition

Function
Destroy a constraint on a domain.


Format
*/
drop_domain_constraint_definition ::=
  DROP CONSTRAINT constraint_name
/*
11.40 drop_domain_statement

Function
Destroy a domain.


Format
*/
drop_domain_statement ::=
  DROP DOMAIN domain_name drop_behavior
/*
11.41 character_set_definition

Function
Define a character set.


Format
*/
character_set_definition ::=
  CREATE CHARACTER SET character_set_name  AS?
      character_set_source collate_clause?

character_set_source ::=
  GET character_set_specification
/*
11.42 drop_character_set_statement

Function
Destroy a character set.


Format
*/
drop_character_set_statement ::=
  DROP CHARACTER SET character_set_name
/*
11.43 collation_definition

Function
Define a collation.


Format
*/
collation_definition ::=
  CREATE COLLATION collation_name FOR character_set_specification
      FROM existing_collation_name  pad_characteristic?

existing_collation_name ::=
  collation_name

pad_characteristic ::=
    NO PAD
  | PAD SPACE
/*
11.44 drop_collation_statement

Function
Destroy a collation.


Format
*/
drop_collation_statement ::=
  DROP COLLATION collation_name drop_behavior
/*
11.45 transliteration_definition

Function
Define a character transliteration.


Format
*/
transliteration_definition ::=
  CREATE TRANSLATION transliteration_name FOR source_character_set_specification
      TO target_character_set_specification FROM transliteration_source

source_character_set_specification ::=
  character_set_specification

target_character_set_specification ::=
  character_set_specification

transliteration_source ::=
    existing_transliteration_name
  | transliteration_routine

existing_transliteration_name ::=
  transliteration_name

transliteration_routine ::=
  specific_routine_designator
/*
11.46 drop_transliteration_statement

Function
Destroy a character transliteration.


Format
*/
drop_transliteration_statement ::=
  DROP TRANSLATION transliteration_name
/*
11.47 assertion_definition

Function
Specify an integrity constraint.


Format
*/
assertion_definition ::=
     CREATE ASSERTION constraint_name
         CHECK left_paren search_condition right_paren
          constraint_characteristics?
/*
11.48 drop_assertion_statement

Function
Destroy an assertion.


Format
*/
drop_assertion_statement ::=
  DROP ASSERTION constraint_name  drop_behavior?
/*
11.49 trigger_definition

Function
Define triggered SQL-statements.


Format
*/
trigger_definition ::=
  CREATE TRIGGER trigger_name trigger_action_time trigger_event
      ON table_name ( REFERENCING transition_table_or_variable_list )?
      triggered_action

trigger_action_time ::=
    BEFORE
  | AFTER
  | INSTEAD OF

trigger_event ::=
    INSERT
  | DELETE
  | UPDATE ( OF trigger_column_list )?

trigger_column_list ::=
  column_name_list

triggered_action ::=
  ( FOR EACH ( ROW | STATEMENT ) )?
       triggered_when_clause?
      triggered_SQL_statement

triggered_when_clause ::=
  WHEN left_paren search_condition right_paren

triggered_SQL_statement ::=
    SQL_procedure_statement
  | BEGIN ATOMIC ( SQL_procedure_statement semicolon)+ END

transition_table_or_variable_list ::=
  transition_table_or_variable+

transition_table_or_variable ::=
    OLD  ROW?  AS? old_transition_variable_name
  | NEW  ROW?  AS? new_transition_variable_name
  | OLD TABLE  AS? old_transition_table_name
  | NEW TABLE  AS? new_transition_table_name

old_transition_table_name ::=
  transition_table_name

new_transition_table_name ::=
  transition_table_name

transition_table_name ::=
  identifier

old_transition_variable_name ::=
  correlation_name

new_transition_variable_name ::=
  correlation_name
/*
11.50 drop_trigger_statement

Function
Destroy a trigger.


Format
*/
drop_trigger_statement ::=
  DROP TRIGGER trigger_name
/*
11.51 user_defined_type_definition

Function
Define a user-defined type.


Format
*/
user_defined_type_definition ::=
  CREATE TYPE user_defined_type_body

user_defined_type_body ::=
  schema_resolved_user_defined_type_name
       subtype_clause?
      ( AS representation )?
       user_defined_type_option_list?
       method_specification_list?

user_defined_type_option_list ::=
  user_defined_type_option user_defined_type_option*

user_defined_type_option ::=
    instantiable_clause
  | finality
  | reference_type_specification
  | cast_to_ref
  | cast_to_type
  | cast_to_distinct
  | cast_to_source

subtype_clause ::=
  UNDER supertype_name

supertype_name ::=
  path_resolved_user_defined_type_name

representation ::=
    predefined_type
  | collection_type
  | member_list

member_list ::=
  left_paren member ( comma member )* right_paren

member ::=
  attribute_definition

instantiable_clause ::=
    INSTANTIABLE
  | NOT INSTANTIABLE

finality ::=
    FINAL
  | NOT FINAL

reference_type_specification ::=
    user_defined_representation
  | derived_representation
  | system_generated_representation

user_defined_representation ::=
  REF USING predefined_type

derived_representation ::=
  REF FROM list_of_attributes

system_generated_representation ::=
  REF IS SYSTEM GENERATED

cast_to_ref ::=
  CAST left_paren SOURCE AS REF right_paren WITH cast_to_ref_identifier

cast_to_ref_identifier ::=
  identifier

cast_to_type ::=
  CAST left_paren REF AS SOURCE right_paren WITH cast_to_type_identifier

cast_to_type_identifier ::=
  identifier

list_of_attributes ::=
  left_paren attribute_name ( comma attribute_name )* right_paren

cast_to_distinct ::=
  CAST left_paren SOURCE AS DISTINCT right_paren
      WITH cast_to_distinct_identifier

cast_to_distinct_identifier ::=
  identifier

cast_to_source ::=
  CAST left_paren DISTINCT AS SOURCE right_paren
      WITH cast_to_source_identifier

cast_to_source_identifier ::=
  identifier

method_specification_list ::=
  method_specification ( comma method_specification )*

method_specification ::=
    original_method_specification
  | overriding_method_specification

original_method_specification ::=
  partial_method_specification ( SELF AS RESULT ) ( SELF AS LOCATOR )
       method_characteristics?

overriding_method_specification ::=
  OVERRIDING partial_method_specification

partial_method_specification ::=
  ( INSTANCE | STATIC | CONSTRUCTOR )
      METHOD method_name SQL_parameter_declaration_list
      returns_clause
      ( SPECIFIC specific_method_name )

specific_method_name ::=
  ( schema_name period )? qualified_identifier

method_characteristics ::=
  method_characteristic+

method_characteristic ::=
       language_clause
     | parameter_style_clause
     | deterministic_characteristic
     | SQL_data_access_indication
     | null_call_clause
/*
11.52 attribute_definition

Function
Define an attribute of a structured type.


Format
*/
attribute_definition ::=
     attribute_name data_type
          attribute_default?
          collate_clause?

attribute_default ::=
  default_clause
/*
11.53 alter_type_statement

Function
Change the definition of a user-defined type.


Format
*/
alter_type_statement ::=
  ALTER TYPE schema_resolved_user_defined_type_name alter_type_action

alter_type_action ::=
    add_attribute_definition
  | drop_attribute_definition
  | add_original_method_specification
  | add_overriding_method_specification
  | drop_method_specification
/*
11.54 add_attribute_definition

Function
Add an attribute to a user-defined type.


Format
*/
add_attribute_definition ::=
  ADD ATTRIBUTE attribute_definition
/*
11.55 drop_attribute_definition

Function
Destroy an attribute of a user-defined type.


Format
*/
drop_attribute_definition ::=
  DROP ATTRIBUTE attribute_name RESTRICT
/*
11.56 add_original_method_specification

Function
Add an original method specification to a user-defined type.


Format
*/
add_original_method_specification ::=
  ADD original_method_specification
/*
11.57 add_overriding_method_specification

Function
Add an overriding method specification to a user-defined type.


Format
*/
add_overriding_method_specification ::=
  ADD overriding_method_specification
/*
11.58 drop_method_specification

Function
Remove a method specification from a user-defined type.


Format
*/
drop_method_specification ::=
  DROP specific_method_specification_designator RESTRICT

specific_method_specification_designator ::=
  ( INSTANCE | STATIC | CONSTRUCTOR )?
      METHOD method_name data_type_list
/*
11.59 drop_data_type_statement


Function
Destroy a user-defined type.


Format
*/
drop_data_type_statement ::=
  DROP TYPE schema_resolved_user_defined_type_name drop_behavior
/*
11.60 SQL_invoked_routine

Function
Define an SQL-invoked routine.


Format
*/
SQL_invoked_routine ::=
  schema_routine

schema_routine ::=
    schema_procedure
  | schema_function

schema_procedure ::=
  CREATE SQL_invoked_procedure

schema_function ::=
  CREATE SQL_invoked_function

SQL_invoked_procedure ::=
  PROCEDURE schema_qualified_routine_name SQL_parameter_declaration_list
      routine_characteristics
      routine_body

SQL_invoked_function ::=
  ( function_specification | method_specification_designator ) routine_body

SQL_parameter_declaration_list ::=
  left_paren ( SQL_parameter_declaration
      ( comma SQL_parameter_declaration )* )? right_paren

SQL_parameter_declaration ::=
   parameter_mode?
       SQL_parameter_name?
      parameter_type  RESULT?
      ( DEFAULT parameter_default )?

parameter_default ::=
    value_expression
  | contextually_typed_value_specification
  | descriptor_value_constructor

parameter_mode ::=
    IN
  | OUT
  | INOUT

parameter_type ::=
   data_type  locator_indication?
 | generic_table_parameter_type
 | descriptor_parameter_type

generic_table_parameter_type ::=
  TABLE  pass_through_option?  generic_table_semantics?

pass_through_option ::=
    PASS THROUGH
  | NO PASS THROUGH

generic_table_semantics ::=
    WITH ROW SEMANTICS
  | WITH SET SEMANTICS  generic_table_pruning?

generic_table_pruning ::=
    PRUNE ON EMPTY
  | KEEP ON EMPTY

descriptor_parameter_type ::=
  DESCRIPTOR

locator_indication ::=
  AS LOCATOR

function_specification ::=
  FUNCTION schema_qualified_routine_name SQL_parameter_declaration_list
      returns_clause
      routine_characteristics
       dispatch_clause?

method_specification_designator ::=
    SPECIFIC METHOD specific_method_name
  | ( INSTANCE | STATIC | CONSTRUCTOR )
      METHOD method_name SQL_parameter_declaration_list
       returns_clause?
      FOR schema_resolved_user_defined_type_name

routine_characteristics ::=
  routine_characteristic*

routine_characteristic ::=
    language_clause
  | parameter_style_clause
  | SPECIFIC specific_name
  | deterministic_characteristic
  | SQL_data_access_indication
  | null_call_clause
  | returned_result_sets_characteristic
  | savepoint_level_indication

savepoint_level_indication ::=
    NEW SAVEPOINT LEVEL
  | OLD SAVEPOINT LEVEL

returned_result_sets_characteristic ::=
  DYNAMIC RESULT SETS maximum_returned_result_sets

parameter_style_clause ::=
  PARAMETER STYLE parameter_style

dispatch_clause ::=
  STATIC DISPATCH

returns_clause ::=
  RETURNS returns_type

returns_type ::=
    returns_data_type  result_cast?
  | returns_table_type

returns_table_type ::=
    TABLE  table_function_column_list?
  | ONLY PASS THROUGH

table_function_column_list ::=
  left_paren table_function_column_list_element
      ( comma table_function_column_list_element )* right_paren

table_function_column_list_element ::=
  column_name data_type

result_cast ::=
  CAST FROM result_cast_from_type

result_cast_from_type ::=
  data_type  locator_indication?

returns_data_type ::=
  data_type  locator_indication?

routine_body ::=
    SQL_routine_spec
  | external_body_reference
  | polymorphic_table_function_body

SQL_routine_spec ::=
   rights_clause? SQL_routine_body

rights_clause ::=
    SQL SECURITY INVOKER
  | SQL SECURITY DEFINER

SQL_routine_body ::=
  SQL_procedure_statement

external_body_reference ::=
  EXTERNAL ( NAME external_routine_name )?
       parameter_style_clause?
       transform_group_specification?
       external_security_clause?

polymorphic_table_function_body ::=
   PTF_private_parameters?
      ( DESCRIBE WITH PTF_describe_component_procedure )?
      ( START WITH PTF_start_component_procedure )?
      FULFILL WITH PTF_fulfill_component_procedure
      ( FINISH WITH PTF_finish_component_procedure )?
PTF_private_parameters ::=
  PRIVATE  DATA? private_parameter_declaration_list

private_parameter_declaration_list ::=
  left_paren ( SQL_parameter_declaration
      ( comma SQL_parameter_declaration )* )?
      right_paren

PTF_describe_component_procedure ::=
  specific_routine_designator

PTF_start_component_procedure ::=
  specific_routine_designator

PTF_fulfill_component_procedure ::=
  specific_routine_designator

PTF_finish_component_procedure ::=
  specific_routine_designator

external_security_clause ::=
    EXTERNAL SECURITY DEFINER
  | EXTERNAL SECURITY INVOKER
  | EXTERNAL SECURITY IMPLEMENTATION DEFINED

parameter_style ::=
    SQL
  | GENERAL

deterministic_characteristic ::=
    DETERMINISTIC
  | NOT DETERMINISTIC

SQL_data_access_indication ::=
    NO SQL
  | CONTAINS SQL
  | READS SQL DATA
  | MODIFIES SQL DATA

null_call_clause ::=
    RETURNS NULL ON NULL INPUT
  | CALLED ON NULL INPUT

maximum_returned_result_sets ::=
  unsigned_integer

transform_group_specification ::=
  TRANSFORM GROUP ( single_group_specification | multiple_group_specification )

single_group_specification ::=
  group_name

multiple_group_specification ::=
  group_specification ( comma group_specification )*

group_specification ::=
  group_name FOR TYPE path_resolved_user_defined_type_name
/*
11.61 alter_routine_statement

Function
Alter a characteristic of an SQL-invoked routine.


Format
*/
alter_routine_statement ::=
  ALTER specific_routine_designator
      alter_routine_characteristics alter_routine_behavior

alter_routine_characteristics ::=
  alter_routine_characteristic+

alter_routine_characteristic ::=
    language_clause
  | parameter_style_clause
  | SQL_data_access_indication
  | null_call_clause
  | returned_result_sets_characteristic
  | NAME external_routine_name

alter_routine_behavior ::=
  RESTRICT
/*
11.62 drop_routine_statement

Function
Destroy an SQL-invoked routine.


Format
*/
drop_routine_statement ::=
  DROP specific_routine_designator drop_behavior
/*
11.63 user_defined_cast_definition

Function
Define a user-defined cast.


Format
*/
user_defined_cast_definition ::=
  CREATE CAST left_paren source_data_type AS target_data_type right_paren
      WITH cast_function
      ( AS ASSIGNMENT )?

cast_function ::=
  specific_routine_designator

source_data_type ::=
  data_type

target_data_type ::=
  data_type
/*
11.64 drop_user_defined_cast_statement

Function
Destroy a user-defined cast.


Format
*/
drop_user_defined_cast_statement ::=
  DROP CAST left_paren source_data_type AS target_data_type right_paren
      drop_behavior
/*
11.65 user_defined_ordering_definition

Function
Define a user-defined ordering for a user-defined type.


Format
*/
user_defined_ordering_definition ::=
  CREATE ORDERING FOR schema_resolved_user_defined_type_name ordering_form

ordering_form ::=
    equals_ordering_form
  | full_ordering_form

equals_ordering_form ::=
  EQUALS ONLY BY ordering_category

full_ordering_form ::=
  ORDER FULL BY ordering_category

ordering_category ::=
    relative_category
  | map_category
  | state_category

relative_category ::=
  RELATIVE WITH relative_function_specification

map_category ::=
  MAP WITH map_function_specification

state_category ::=
  STATE  specific_name?

relative_function_specification ::=
  specific_routine_designator

map_function_specification ::=
  specific_routine_designator
/*
11.66 drop_user_defined_ordering_statement

Function
Destroy a user-defined ordering method.


Format
*/
drop_user_defined_ordering_statement ::=
  DROP ORDERING FOR schema_resolved_user_defined_type_name drop_behavior
/*
11.67 transform_definition

Function
Define one or more transform functions for a user-defined type.


Format
*/
transform_definition ::=
  CREATE ( TRANSFORM | TRANSFORMS ) FOR
      schema_resolved_user_defined_type_name transform_group+

transform_group ::=
  group_name left_paren transform_element_list right_paren

group_name ::=
  identifier

transform_element_list ::=
  transform_element ( comma transform_element )?

transform_element ::=
    to_sql
  | from_sql

to_sql ::=
  TO SQL WITH to_sql_function

from_sql ::=
  FROM SQL WITH from_sql_function

to_sql_function ::=
  specific_routine_designator

from_sql_function ::=
  specific_routine_designator
/*
11.68 alter_transform_statement

Function
Change the definition of one or more transform groups.


Format
*/
alter_transform_statement ::=
  ALTER ( TRANSFORM | TRANSFORMS )
      FOR schema_resolved_user_defined_type_name alter_group+

alter_group ::=
  group_name left_paren alter_transform_action_list right_paren

alter_transform_action_list ::=
  alter_transform_action ( comma alter_transform_action )*

alter_transform_action ::=
    add_transform_element_list
  | drop_transform_element_list
/*
11.69 add_transform_element_list

Function
Add a transform element (<to sql> and/or <from sql>) to an existing transform group.


Format
*/
add_transform_element_list ::=
  ADD left_paren transform_element_list right_paren
/*
11.70 drop_transform_element_list

Function
Remove a transform element (<to sql> and/or <from sql>) from a transform group.


Format
*/
drop_transform_element_list ::=
  DROP left_paren transform_kind
      ( comma transform_kind )? drop_behavior right_paren

transform_kind ::=
    TO SQL
  | FROM SQL
/*
11.71 drop_transform_statement

Function
Remove one or more transform functions associated with a transform.


Format
*/
drop_transform_statement ::=
  DROP ( TRANSFORM | TRANSFORMS ) transforms_to_be_dropped
      FOR schema_resolved_user_defined_type_name drop_behavior

transforms_to_be_dropped ::=
    ALL
  | transform_group_element

transform_group_element ::=
  group_name
/*
11.72 sequence_generator_definition

Function
Define an external sequence generator.


Format
*/
sequence_generator_definition ::=
  CREATE SEQUENCE sequence_generator_name  sequence_generator_options?

sequence_generator_options ::=
  sequence_generator_option+

sequence_generator_option ::=
    sequence_generator_data_type_option
  | common_sequence_generator_options

common_sequence_generator_options ::=
  common_sequence_generator_option+

common_sequence_generator_option ::=
    sequence_generator_start_with_option
  | basic_sequence_generator_option

basic_sequence_generator_option ::=
    sequence_generator_increment_by_option
  | sequence_generator_maxvalue_option
  | sequence_generator_minvalue_option
  | sequence_generator_cycle_option

sequence_generator_data_type_option ::=
  AS data_type

sequence_generator_start_with_option ::=
  START WITH sequence_generator_start_value

sequence_generator_start_value ::=
  signed_numeric_literal

sequence_generator_increment_by_option ::=
  INCREMENT BY sequence_generator_increment

sequence_generator_increment ::=
  signed_numeric_literal

sequence_generator_maxvalue_option ::=
    MAXVALUE sequence_generator_max_value
  | NO MAXVALUE

sequence_generator_max_value ::=
  signed_numeric_literal

sequence_generator_minvalue_option ::=
    MINVALUE sequence_generator_min_value
  | NO MINVALUE

sequence_generator_min_value ::=
  signed_numeric_literal

sequence_generator_cycle_option ::=
    CYCLE
  | NO CYCLE
/*
11.73 alter_sequence_generator_statement

Function
Change the definition of an external sequence generator.


Format
*/
alter_sequence_generator_statement ::=
  ALTER SEQUENCE sequence_generator_name alter_sequence_generator_options

alter_sequence_generator_options ::=
  alter_sequence_generator_option+

alter_sequence_generator_option ::=
    alter_sequence_generator_restart_option
  | basic_sequence_generator_option

alter_sequence_generator_restart_option ::=
  RESTART ( WITH sequence_generator_restart_value )?

sequence_generator_restart_value ::=
  signed_numeric_literal
/*
11.74 drop_sequence_generator_statement

Function
Destroy an external sequence generator.


Format
*/
drop_sequence_generator_statement ::=
  DROP SEQUENCE sequence_generator_name drop_behavior
/*
12 Access control


12.1 grant_statement

Function
Define privileges and role authorizations.


Format
*/
grant_statement ::=
    grant_privilege_statement
  | grant_role_statement
/*
12.2 grant_privilege_statement

Function
Define privileges.


Format
*/
grant_privilege_statement ::=
  GRANT privileges TO grantee ( comma grantee )*
      ( WITH HIERARCHY OPTION )?
      ( WITH GRANT OPTION )?
      ( GRANTED BY grantor )?
/*
12.3 privileges

Function
Specify privileges.


Format
*/
privileges ::=
  object_privileges ON object_name

object_name ::=
       TABLE? table_name
  |   DOMAIN domain_name
  |   COLLATION collation_name
  |   CHARACTER SET character_set_name
  |   TRANSLATION transliteration_name
  |   TYPE schema_resolved_user_defined_type_name
  |   SEQUENCE sequence_generator_name
  |   specific_routine_designator

object_privileges ::=
    ALL PRIVILEGES
  | action ( comma action )*

action ::=
    SELECT
  | SELECT left_paren privilege_column_list right_paren
  | SELECT left_paren privilege_method_list right_paren
  | DELETE
  | INSERT ( left_paren privilege_column_list right_paren )?
  | UPDATE ( left_paren privilege_column_list right_paren )?
  | REFERENCES ( left_paren privilege_column_list right_paren )?
  | USAGE
  | TRIGGER
  | UNDER
  | EXECUTE

privilege_method_list ::=
  specific_routine_designator ( comma specific_routine_designator )*

privilege_column_list ::=
  column_name_list

grantee ::=
    PUBLIC
  | authorization_identifier

grantor ::=
    CURRENT_USER
  | CURRENT_ROLE
/*
12.4 role_definition

Function
Define a role.


Format
*/
role_definition ::=
  CREATE ROLE role_name ( WITH ADMIN grantor )?
/*
12.5 grant_role_statement

Function
Define role authorizations.


Format
*/
grant_role_statement ::=
  GRANT role_granted ( comma role_granted )*
      TO grantee ( comma grantee )*
      ( WITH ADMIN OPTION )?
      ( GRANTED BY grantor )?

role_granted ::=
  role_name
/*
12.6 drop_role_statement

Function
Destroy a role.


Format
*/
drop_role_statement ::=
  DROP ROLE role_name
/*
12.7 revoke_statement

Function
Destroy privileges and role authorizations.


Format
*/
revoke_statement ::=
    revoke_privilege_statement
  | revoke_role_statement

revoke_privilege_statement ::=
  REVOKE revoke_option_extension? privileges
      FROM grantee ( comma grantee )*
      ( GRANTED BY grantor )?
      drop_behavior

revoke_option_extension ::=
    GRANT OPTION FOR
  | HIERARCHY OPTION FOR

revoke_role_statement ::=
  REVOKE ( ADMIN OPTION FOR )? role_revoked ( comma role_revoked )*
      FROM grantee ( comma grantee )*
      ( GRANTED BY grantor )?
      drop_behavior

role_revoked ::=
  role_name
/*
13 SQL-client modules


13.1 SQL_client_module_definition

Function
Define an SQL-client module.


Format
*/
SQL_client_module_definition ::=
  module_name_clause language_clause module_authorization_clause
      module_path_specification?
      module_transform_group_specification?
      module_collations?
      temporary_table_declaration*
      module_contents+

module_authorization_clause ::=
    SCHEMA schema_name
  | AUTHORIZATION module_authorization_identifier
      ( FOR STATIC ( ONLY | AND DYNAMIC ) )?
  | SCHEMA schema_name AUTHORIZATION module_authorization_identifier
      ( FOR STATIC ( ONLY | AND DYNAMIC ) )?

module_authorization_identifier ::=
  authorization_identifier

module_path_specification ::=
  path_specification

module_transform_group_specification ::=
  transform_group_specification

module_collations ::=
  module_collation_specification+

module_collation_specification ::=
  COLLATION collation_name ( FOR character_set_specification_list )?

character_set_specification_list ::=
  character_set_specification ( comma character_set_specification )*

module_contents ::=
    declare_cursor
  | dynamic_declare_cursor
  | externally_invoked_procedure
/*
13.2 module_name_clause

Function
Name an SQL-client module.


Format
*/
module_name_clause ::=
  MODULE  SQL_client_module_name? module_character_set_specification?

module_character_set_specification ::=
  NAMES ARE character_set_specification
/*
13.3 externally_invoked_procedure

Function
Define an externally-invoked procedure.


Format
*/
externally_invoked_procedure ::=
  PROCEDURE procedure_name host_parameter_declaration_list semicolon
      SQL_procedure_statement semicolon

host_parameter_declaration_list ::=
  left_paren host_parameter_declaration
      ( comma host_parameter_declaration )? right_paren

host_parameter_declaration ::=
    host_parameter_name host_parameter_data_type
  | status_parameter

host_parameter_data_type ::=
  data_type  locator_indication?

status_parameter ::=
  SQLSTATE
/*
13.4 SQL_procedure_statement

Function
Define all of the SQL-statements that are <SQL procedure statement>s.


Format
*/
SQL_procedure_statement ::=
  SQL_executable_statement

SQL_executable_statement ::=
    SQL_schema_statement
  | SQL_data_statement
  | SQL_control_statement
  | SQL_transaction_statement
  | SQL_connection_statement
  | SQL_session_statement
  | SQL_diagnostics_statement
  | SQL_dynamic_statement

SQL_schema_statement ::=
    SQL_schema_definition_statement
  | SQL_schema_manipulation_statement

SQL_schema_definition_statement ::=
    schema_definition
  | table_definition
  | view_definition
  | SQL_invoked_routine
  | grant_statement
  | role_definition
  | domain_definition
  | character_set_definition
  | collation_definition
  | transliteration_definition
  | assertion_definition
  | trigger_definition
  | user_defined_type_definition
  | user_defined_cast_definition
  | user_defined_ordering_definition
  | transform_definition
  | sequence_generator_definition

SQL_schema_manipulation_statement ::=
    drop_schema_statement
  | alter_table_statement
  | drop_table_statement
  | drop_view_statement
  | alter_routine_statement
  | drop_routine_statement
  | drop_user_defined_cast_statement
  | revoke_statement
  | drop_role_statement
  | alter_domain_statement
  | drop_domain_statement
  | drop_character_set_statement
  | drop_collation_statement
  | drop_transliteration_statement
  | drop_assertion_statement
  | drop_trigger_statement
  | alter_type_statement
  | drop_data_type_statement
  | drop_user_defined_ordering_statement
  | alter_transform_statement
  | drop_transform_statement
  | alter_sequence_generator_statement
  | drop_sequence_generator_statement

SQL_data_statement ::=
    open_statement
  | fetch_statement
  | close_statement
  | select_statement__single_row
  | free_locator_statement
  | hold_locator_statement
  | SQL_data_change_statement

SQL_data_change_statement ::=
    delete_statement__positioned
  | delete_statement__searched
  | insert_statement
  | update_statement__positioned
  | update_statement__searched
  | truncate_table_statement
  | merge_statement

SQL_control_statement ::=
    call_statement
  | return_statement

SQL_transaction_statement ::=
    start_transaction_statement
  | set_transaction_statement
  | set_constraints_mode_statement
  | savepoint_statement
  | release_savepoint_statement
  | commit_statement
  | rollback_statement

SQL_connection_statement ::=
    connect_statement
  | set_connection_statement
  | disconnect_statement

SQL_session_statement ::=
    set_session_user_identifier_statement
  | set_role_statement
  | set_local_time_zone_statement
  | set_session_characteristics_statement
  | set_catalog_statement
  | set_schema_statement
  | set_names_statement
  | set_path_statement
  | set_transform_group_statement
  | set_session_collation_statement

SQL_diagnostics_statement ::=
  get_diagnostics_statement

SQL_dynamic_statement ::=
    SQL_descriptor_statement
  | prepare_statement
  | deallocate_prepared_statement
  | describe_statement
  | execute_statement
  | execute_immediate_statement
  | SQL_dynamic_data_statement
  | copy_descriptor_statement
  | pipe_row_statement

SQL_dynamic_data_statement ::=
    allocate_extended_dynamic_cursor_statement
  | allocate_received_cursor_statement
  | dynamic_open_statement
  | dynamic_fetch_statement
  | dynamic_close_statement
  | dynamic_delete_statement__positioned
  | dynamic_update_statement__positioned

SQL_descriptor_statement ::=
    allocate_descriptor_statement
  | deallocate_descriptor_statement
  | set_descriptor_statement
  | get_descriptor_statement
/*
14 Data manipulation


14.1 declare_cursor

Function
Declare a standing cursor.


Format
*/
declare_cursor ::=
  DECLARE cursor_name cursor_properties
      FOR cursor_specification
/*
14.2 cursor_properties

Function
Specify the declared properties of a cursor.


Format
*/
cursor_properties ::=
   cursor_sensitivity?  cursor_scrollability? CURSOR
       cursor_holdability?
       cursor_returnability?

cursor_sensitivity ::=
    SENSITIVE
  | INSENSITIVE
  | ASENSITIVE

cursor_scrollability ::=
    SCROLL
  | NO SCROLL

cursor_holdability ::=
    WITH HOLD
  | WITHOUT HOLD

cursor_returnability ::=
    WITH RETURN
  | WITHOUT RETURN
/*
14.3 cursor_specification

Function
Define a result set.


Format
*/
cursor_specification ::=
  query_expression  updatability_clause?

updatability_clause ::=
  FOR ( READ ONLY | UPDATE ( OF column_name_list )? )
/*
14.4 open_statement

Function
Open a standing cursor.


Format
*/
open_statement ::=
  OPEN cursor_name
/*
14.5 fetch_statement

Function
Position a standing cursor on a specified row of the standing cursor's result set and retrieve values from that
row.


Format
*/
fetch_statement ::=
     FETCH (  fetch_orientation? FROM )? cursor_name INTO fetch_target_list

fetch_orientation ::=
    NEXT
  | PRIOR
  | FIRST
  | LAST
  | ( ABSOLUTE | RELATIVE ) simple_value_specification

fetch_target_list ::=
     target_specification ( comma target_specification )?
/*
14.6 close_statement

Function
Close a standing cursor.


Format
*/
close_statement ::=
  CLOSE cursor_name
/*
14.7 select_statement__single_row

Function
Retrieve values from a specified row of a table.


Format
*/
select_statement__single_row ::=
  SELECT  set_quantifier? select_list
      INTO select_target_list
      table_expression

select_target_list ::=
  target_specification ( comma target_specification )*
/*
14.8 delete_statement__positioned

Function
Delete a row of a table.


Format
*/
delete_statement__positioned ::=
     DELETE FROM target_table ( AS? correlation_name )?
         WHERE CURRENT OF cursor_name

target_table ::=
    table_name
  | ONLY left_paren table_name right_paren
/*
14.9 delete_statement__searched

Function
Delete rows of a table.


Format
*/
delete_statement__searched ::=
  DELETE FROM target_table
      ( FOR PORTION OF application_time_period_name
        FROM point_in_time_1 TO point_in_time_2 )?
      (  AS? correlation_name )?
      ( WHERE search_condition )?
/*
14.10 truncate_table_statement

Function
Delete all rows of a base table without causing any triggered action.


Format
*/
truncate_table_statement ::=
  TRUNCATE TABLE target_table  identity_column_restart_option?

identity_column_restart_option ::=
    CONTINUE IDENTITY
  | RESTART IDENTITY
/*
14.11 insert_statement

Function
Create new rows in a table.


Format
*/
insert_statement ::=
  INSERT INTO insertion_target insert_columns_and_source

insertion_target ::=
  table_name

insert_columns_and_source ::=
    from_subquery
  | from_constructor
  | from_default

from_subquery ::=
  ( left_paren insert_column_list right_paren )?
       override_clause?
      query_expression

from_constructor ::=
  ( left_paren insert_column_list right_paren )
       override_clause?
      contextually_typed_table_value_constructor

override_clause ::=
    OVERRIDING USER VALUE
  | OVERRIDING SYSTEM VALUE

from_default ::=
  DEFAULT VALUES

insert_column_list ::=
  column_name_list
/*
14.12 merge_statement

Function
Conditionally update and/or delete rows of a table and/or insert new rows into a table.


Format
*/
merge_statement ::=
  MERGE INTO target_table ( AS? merge_correlation_name )
      USING table_reference
      ON search_condition merge_operation_specification

merge_correlation_name ::=
  correlation_name

merge_operation_specification ::=
  merge_when_clause+

merge_when_clause ::=
    merge_when_matched_clause
  | merge_when_not_matched_clause

merge_when_matched_clause ::=
  WHEN MATCHED ( AND search_condition )?
      THEN merge_update_or_delete_specification

merge_update_or_delete_specification ::=
    merge_update_specification
  | merge_delete_specification

merge_when_not_matched_clause ::=
  WHEN NOT MATCHED ( AND search_condition )?
      THEN merge_insert_specification

merge_update_specification ::=
  UPDATE SET set_clause_list

merge_delete_specification ::=
  DELETE

merge_insert_specification ::=
  INSERT ( left_paren insert_column_list right_paren )?
       override_clause?
      VALUES merge_insert_value_list

merge_insert_value_list ::=
  left_paren
      merge_insert_value_element ( comma merge_insert_value_element )*
      right_paren

merge_insert_value_element ::=
    value_expression
  | contextually_typed_value_specification
/*
14.13 update_statement__positioned

Function
Update a row of a table.


Format
*/
update_statement__positioned ::=
     UPDATE target_table ( AS? correlation_name )?
         SET set_clause_list
         WHERE CURRENT OF cursor_name
/*
14.14 update_statement__searched

Function
Update rows of a table.


Format
*/
update_statement__searched ::=
  UPDATE target_table
      ( FOR PORTION OF application_time_period_name
        FROM point_in_time_1 TO point_in_time_2 )?
      ( AS? correlation_name )?
      SET set_clause_list
      ( WHERE search_condition )?
/*
14.15 set_clause_list

Function
Specify a list of updates.


Format
*/
set_clause_list ::=
  set_clause ( comma set_clause )*

set_clause ::=
    multiple_column_assignment
  | set_target equals_operator update_source

set_target ::=
    update_target
  | mutated_set_clause

multiple_column_assignment ::=
  set_target_list equals_operator assigned_row

set_target_list ::=
  left_paren set_target ( comma set_target )* right_paren

assigned_row ::=
  contextually_typed_row_value_expression

update_target ::=
    object_column
  | object_column
      left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph

object_column ::=
  column_name

mutated_set_clause ::=
  mutated_target period method_name

mutated_target ::=
    object_column
  | mutated_set_clause

update_source ::=
    value_expression
  | contextually_typed_value_specification
/*
14.16 temporary_table_declaration

Function
Declare a declared local temporary table.


Format
*/
temporary_table_declaration ::=
  DECLARE LOCAL TEMPORARY TABLE table_name table_element_list
      ( ON COMMIT table_commit_action ROWS )?
/*
14.17 free_locator_statement

Function
Remove the association between a locator variable and the value that is represented by that locator.


Format
*/
free_locator_statement ::=
  FREE LOCATOR locator_reference ( comma locator_reference )*

locator_reference ::=
    host_parameter_name
  | embedded_variable_name
  | dynamic_parameter_specification
/*
14.18 hold_locator_statement

Function
Mark a locator variable as being holdable.


Format
*/
hold_locator_statement ::=
  HOLD LOCATOR locator_reference ( comma locator_reference )*

/*
16 Control statements

16.1 call_statement


Function
Invoke an SQL-invoked routine.


Format
*/
call_statement ::=
  CALL routine_invocation
/*
16.2 return_statement

Function
Return a value from an SQL routine that is an SQL-invoked function.


Format
*/
return_statement ::=
  RETURN return_value

return_value ::=
    value_expression
  | NULL
/*
17 Transaction management


17.1 start_transaction_statement

Function
Start an SQL-transaction and set its characteristics.


Format
*/
start_transaction_statement ::=
  START TRANSACTION  transaction_characteristics?
/*
17.2 set_transaction_statement

Function
Set the characteristics of the next SQL-transaction for the SQL-agent.
    NOTE 711 - This statement has no effect on any SQL-transactions subsequent to the next SQL-transaction.


Format
*/
set_transaction_statement ::=
  SET  LOCAL? TRANSACTION transaction_characteristics
/*
17.3 transaction_characteristics

Function
Specify transaction characteristics.


Format
*/
transaction_characteristics ::=
      ( transaction_mode ( comma transaction_mode )* )?

transaction_mode ::=
    isolation_level
  | transaction_access_mode
  | diagnostics_size

transaction_access_mode ::=
    READ ONLY
  | READ WRITE

isolation_level ::=
  ISOLATION LEVEL level_of_isolation

level_of_isolation ::=
    READ UNCOMMITTED
  | READ COMMITTED
  | REPEATABLE READ
  | SERIALIZABLE

diagnostics_size ::=
  DIAGNOSTICS SIZE number_of_conditions

number_of_conditions ::=
  simple_value_specification
/*
17.4 set_constraints_mode_statement

Function
If an SQL-transaction is currently active, then set the constraint mode for that SQL-transaction in the current
SQL-session. If no SQL-transaction is currently active, then set the constraint mode for the next SQL-transaction
in the current SQL-session for the SQL-agent.
    NOTE 713 - This statement has no effect on any SQL-transactions subsequent to this SQL-transaction.


Format
*/
set_constraints_mode_statement ::=
  SET CONSTRAINTS constraint_name_list ( DEFERRED | IMMEDIATE )

constraint_name_list ::=
    ALL
  | constraint_name ( comma constraint_name )*
/*
17.5 savepoint_statement

Function
Establish a savepoint.


Format
*/
savepoint_statement ::=
  SAVEPOINT savepoint_specifier

savepoint_specifier ::=
  savepoint_name
/*
17.6 release_savepoint_statement

Function
Destroy a savepoint.


Format
*/
release_savepoint_statement ::=
  RELEASE SAVEPOINT savepoint_specifier
/*
17.7 commit_statement

Function
Terminate the current SQL-transaction with commit.


Format
*/
commit_statement ::=
  COMMIT  WORK? ( AND  NO? CHAIN )?
/*
17.8 rollback_statement

Function
Terminate the current SQL-transaction with rollback, or rollback all actions affecting SQL-data and/or schemas
since the establishment of a savepoint.


Format
*/
rollback_statement ::=
  ROLLBACK  WORK? ( AND  NO? CHAIN )?  savepoint_clause?

savepoint_clause ::=
  TO SAVEPOINT savepoint_specifier

/*
18 Connection management


18.1 connect_statement

Function
Establish an SQL-session.


Format
*/
connect_statement ::=
  CONNECT TO connection_target

connection_target ::=
    SQL_server_name ( AS connection_name )? ( USER connection_user_name )?
  | DEFAULT
/*
18.2 set_connection_statement

Function
Select an SQL-connection from the available SQL-connections.


Format
*/
set_connection_statement ::=
  SET CONNECTION connection_object

connection_object ::=
    DEFAULT
  | connection_name
/*
18.3 disconnect_statement

Function
Terminate an SQL-connection.


Format
*/
disconnect_statement ::=
  DISCONNECT disconnect_object

disconnect_object ::=
    connection_object
  | ALL
  | CURRENT
/*
19 Session management

19.1 set_session_characteristics_statement

Function
Set one or more characteristics for the current SQL-session.


Format
*/
set_session_characteristics_statement ::=
  SET SESSION CHARACTERISTICS AS session_characteristic_list

session_characteristic_list ::=
  session_characteristic ( comma session_characteristic )*

session_characteristic ::=
  session_transaction_characteristics

session_transaction_characteristics ::=
  TRANSACTION transaction_mode ( comma transaction_mode )*
/*
19.2 set_session_user_identifier_statement

Function
Set the SQL-session user identifier and the current user identifier of the current SQL-session context.


Format
*/
set_session_user_identifier_statement ::=
  SET SESSION AUTHORIZATION value_specification
/*
19.3 set_role_statement

Function
Set the SQL-session role name and the current role name for the current SQL-session context.


Format
*/
set_role_statement ::=
  SET ROLE role_specification

role_specification ::=
    value_specification
  | NONE
/*
19.4 set_local_time_zone_statement

Function
Set the current default time zone displacement for the current SQL-session.


Format
*/
set_local_time_zone_statement ::=
  SET TIME ZONE set_time_zone_value

set_time_zone_value ::=
    interval_value_expression
  | LOCAL
/*
19.5 set_catalog_statement

Function
Set the default catalog name for unqualified <schema name>s in <preparable statement>s that are prepared in
the current SQL-session by an execute_immediate_statement or a prepare_statement and in <direct SQL
statement>s that are invoked directly.


Format
*/
set_catalog_statement ::=
  SET catalog_name_characteristic

catalog_name_characteristic ::=
  CATALOG value_specification
/*
19.6 set_schema_statement

Function
Set the default schema name for unqualified <schema qualified name>s in <preparable statement>s that are
prepared in the current SQL-session by an execute_immediate_statement or a prepare_statement and in
<direct SQL statement>s that are invoked directly.


Format
*/
set_schema_statement ::=
  SET schema_name_characteristic

schema_name_characteristic ::=
  SCHEMA value_specification
/*
19.7 set_names_statement

Function
Set the default character set name for <character string literal>s in <preparable statement>s that are prepared
in the current SQL-session by an execute_immediate_statement or a prepare_statement and in <direct SQL
statement>s that are invoked directly.


Format
*/
set_names_statement ::=
  SET character_set_name_characteristic

character_set_name_characteristic ::=
  NAMES value_specification
/*
19.8 set_path_statement

Function
Set the SQL-path used to determine the subject routine of <routine invocation>s with unqualified <routine
name>s in <preparable statement>s that are prepared in the current SQL-session by an <execute immediate
statement> or a prepare_statement and in <direct SQL statement>s that are invoked directly. The SQL-path
remains the current SQL-path of the SQL-session until another SQL-path is successfully set.


Format
*/
set_path_statement ::=
  SET SQL_path_characteristic

SQL_path_characteristic ::=
  PATH value_specification
/*
19.9 set_transform_group_statement

Function
Set the group name that identifies the group of transform functions for mapping values of user-defined types
to predefined data types.


Format
*/
set_transform_group_statement ::=
  SET transform_group_characteristic

transform_group_characteristic ::=
    DEFAULT TRANSFORM GROUP value_specification
  | TRANSFORM GROUP FOR TYPE path_resolved_user_defined_type_name value_specification
/*
19.10 set_session_collation_statement

Function
Set the SQL-session collation of the SQL-session for one or more character sets. An SQL-session collation
remains effective until another SQL-session collation for the same character set is successfully set.


Format
*/
set_session_collation_statement ::=
    SET COLLATION collation_specification ( FOR character_set_specification_list )?
  | SET NO COLLATION ( FOR character_set_specification_list )?

collation_specification ::=
  value_specification
/*
20 Dynamic SQL

20.2 allocate_descriptor_statement

Function
Allocate an SQL descriptor area.


Format
*/
allocate_descriptor_statement ::=
  ALLOCATE  SQL? DESCRIPTOR conventional_descriptor_name ( WITH MAX occurrences )?

occurrences ::=
  simple_value_specification

/*
20.3 deallocate_descriptor_statement

Function
Deallocate an SQL descriptor area.


Format
*/
deallocate_descriptor_statement ::=
  DEALLOCATE  SQL? DESCRIPTOR conventional_descriptor_name
/*
20.4 get_descriptor_statement

Function
Get information from an SQL descriptor area.


Format
*/
get_descriptor_statement ::=
  GET  SQL?  DESCRIPTOR descriptor_name get_descriptor_information

get_descriptor_information ::=
    get_header_information ( comma get_header_information )*
  | VALUE item_number get_item_information
      ( comma get_item_information )*

get_header_information ::=
  simple_target_specification_1 equals_operator header_item_name

header_item_name ::=
    COUNT
  | KEY_TYPE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | TOP_LEVEL_COUNT

get_item_information ::=
  simple_target_specification_2 equals_operator descriptor_item_name

item_number ::=
  simple_value_specification

simple_target_specification_1 ::=
  simple_target_specification

simple_target_specification_2 ::=
  simple_target_specification

descriptor_item_name ::=
    CARDINALITY
  | CHARACTER_SET_CATALOG
  | CHARACTER_SET_NAME
  | CHARACTER_SET_SCHEMA
  | COLLATION_CATALOG
  | COLLATION_NAME
  | COLLATION_SCHEMA
  | DATA
  | DATETIME_INTERVAL_CODE
  | DATETIME_INTERVAL_PRECISION
  | DEGREE
  | INDICATOR
  | KEY_MEMBER
  | LENGTH
  | LEVEL
  | NAME
  | NULLABLE
  | NULL_ORDERING
  | OCTET_LENGTH
  | PARAMETER_MODE
  | PARAMETER_ORDINAL_POSITION
  | PARAMETER_SPECIFIC_CATALOG
  | PARAMETER_SPECIFIC_NAME
  | PARAMETER_SPECIFIC_SCHEMA
  | PRECISION
  | RETURNED_CARDINALITY
  | RETURNED_LENGTH
  | RETURNED_OCTET_LENGTH
  | SCALE
  | SCOPE_CATALOG
  | SCOPE_NAME
  | SCOPE_SCHEMA
  | SORT_DIRECTION
  | TYPE
  | UNNAMED
  | USER_DEFINED_TYPE_CATALOG
  | USER_DEFINED_TYPE_NAME
  | USER_DEFINED_TYPE_SCHEMA
  | USER_DEFINED_TYPE_CODE
/*
20.5 set_descriptor_statement

Function
Set information in an SQL descriptor area.


Format
*/
set_descriptor_statement ::=
  SET  SQL? DESCRIPTOR descriptor_name set_descriptor_information

set_descriptor_information ::=
    set_header_information ( comma set_header_information )*
  | VALUE item_number set_item_information
      ( comma set_item_information )*

set_header_information ::=
  header_item_name equals_operator simple_value_specification_1

set_item_information ::=
  descriptor_item_name equals_operator simple_value_specification_2

simple_value_specification_1 ::=
  simple_value_specification

simple_value_specification_2 ::=
  simple_value_specification
/*
20.6 copy_descriptor_statement

Function
Copy one SQL descriptor area, in whole or in part, to another SQL descriptor area.


Format
*/
copy_descriptor_statement ::=
    copy_whole_descriptor_statement
  | copy_item_descriptor_statement

copy_whole_descriptor_statement ::=
  COPY source_descriptor_name TO target_descriptor_name

copy_item_descriptor_statement ::=
  COPY source_descriptor_name VALUE item_number_1
      left_paren copy_descriptor_options right_paren
      TO target_descriptor_name VALUE item_number_2

source_descriptor_name ::=
  descriptor_name

target_descriptor_name ::=
  PTF_descriptor_name

item_number_1 ::=
  simple_value_specification

item_number_2 ::=
  simple_value_specification

copy_descriptor_options ::=
    NAME
  | TYPE
  | NAME comma TYPE
  | DATA
/*
20.7 prepare_statement

Function
Prepare a statement for execution.


Format
*/
prepare_statement ::=
  PREPARE SQL_statement_name  attributes_specification?
      FROM SQL_statement_variable

attributes_specification ::=
  ATTRIBUTES attributes_variable

attributes_variable ::=
  simple_value_specification

SQL_statement_variable ::=
  simple_value_specification

preparable_statement ::=
    preparable_SQL_data_statement
  | preparable_SQL_schema_statement
  | preparable_SQL_transaction_statement
  | preparable_SQL_control_statement
  | preparable_SQL_session_statement
  | preparable_implementation_defined_statement

preparable_SQL_data_statement ::=
    delete_statement__searched
  | dynamic_single_row_select_statement
  | insert_statement
  | dynamic_select_statement
  | update_statement__searched
  | truncate_table_statement
  | merge_statement
  | preparable_dynamic_delete_statement__positioned
  | preparable_dynamic_update_statement__positioned
  | hold_locator_statement
  | free_locator_statement

preparable_SQL_schema_statement ::=
  SQL_schema_statement

preparable_SQL_transaction_statement ::=
  SQL_transaction_statement

preparable_SQL_control_statement ::=
  SQL_control_statement

preparable_SQL_session_statement ::=
  SQL_session_statement

dynamic_select_statement ::=
  cursor_specification

preparable_implementation_defined_statement ::=
  "!! See the Syntax Rules."
/*
20.8 cursor_attributes

Function
Specify a list of cursor attributes.


Format
*/
cursor_attributes ::=
  cursor_attribute+

cursor_attribute ::=
    cursor_sensitivity
  | cursor_scrollability
  | cursor_holdability
  | cursor_returnability
/*
20.9 deallocate_prepared_statement

Function
Deallocate SQL-statements that have been prepared with a prepare_statement.


Format
*/
deallocate_prepared_statement ::=
  DEALLOCATE PREPARE SQL_statement_name
/*
20.10 describe_statement


Function
Obtain information about the select_list columns or <dynamic parameter specification>s contained in a prepared
statement or about the columns of the result set associated with a cursor.


Format
*/
describe_statement ::=
    describe_input_statement
  | describe_output_statement

describe_input_statement ::=
  DESCRIBE INPUT SQL_statement_name using_descriptor  nesting_option?

describe_output_statement ::=
  DESCRIBE  OUTPUT? described_object using_descriptor  nesting_option?

nesting_option ::=
    WITH NESTING
  | WITHOUT NESTING

using_descriptor ::=
  USING  SQL? DESCRIPTOR descriptor_name

described_object ::=
    SQL_statement_name
  | CURSOR cursor_name STRUCTURE
/*
20.11 input_using_clause

Function
Supply input values for an SQL_dynamic_statement.


Format
*/
input_using_clause ::=
    using_arguments
  | using_input_descriptor

using_arguments ::=
  USING using_argument ( comma using_argument )*

using_argument ::=
  general_value_specification

using_input_descriptor ::=
  using_descriptor
/*
20.12 output_using_clause


Function
Supply output variables for an SQL_dynamic_statement.


Format
*/
output_using_clause ::=
    into_arguments
  | into_descriptor

into_arguments ::=
  INTO into_argument ( comma into_argument )*

into_argument ::=
  target_specification

into_descriptor ::=
  INTO  SQL? DESCRIPTOR descriptor_name
/*
20.13 execute_statement

Function
Associate input SQL parameters and output targets with a prepared statement and execute the statement.


Format
*/
execute_statement ::=
  EXECUTE SQL_statement_name  result_using_clause?  parameter_using_clause?

result_using_clause ::=
  output_using_clause

parameter_using_clause ::=
  input_using_clause
/*
20.14 execute_immediate_statement

Function
Dynamically prepare and execute a preparable statement.


Format
*/
execute_immediate_statement ::=
  EXECUTE IMMEDIATE SQL_statement_variable
/*
20.15 dynamic_declare_cursor

Function
Declare a declared dynamic cursor to be associated with a <statement name>, which may in turn be associated
with a cursor_specification.


Format
*/
dynamic_declare_cursor ::=
  DECLARE cursor_name
      cursor_properties
      FOR statement_name
/*
20.16 descriptor_value_constructor

Function
Construct a PTF descriptor.


Format
*/
descriptor_value_constructor ::=
  DESCRIPTOR left_paren descriptor_column_list right_paren

descriptor_column_list ::=
  descriptor_column_specification ( comma descriptor_column_specification )*

descriptor_column_specification ::=
  column_name  data_type?
/*
20.17 allocate_extended_dynamic_cursor_statement

Function
Define a cursor based on a prepared statement for a cursor_specification.


Format
*/
allocate_extended_dynamic_cursor_statement ::=
  ALLOCATE extended_cursor_name
      cursor_properties
      FOR extended_statement_name
/*
20.18 allocate_received_cursor_statement

Function
Assign a cursor to the result set sequence returned from an SQL-invoked procedure.


Format
*/
allocate_received_cursor_statement ::=
  ALLOCATE cursor_name
       CURSOR? FOR PROCEDURE specific_routine_designator
/*
20.19 dynamic_open_statement

Function
Associate input dynamic parameters with a cursor_specification and open the dynamic cursor.


Format
*/
dynamic_open_statement ::=
  OPEN conventional_dynamic_cursor_name  input_using_clause?
/*
20.20 dynamic_fetch_statement

Function
Fetch a row for a dynamic cursor.


Format
*/
dynamic_fetch_statement ::=
  FETCH ( fetch_orientation? FROM )? dynamic_cursor_name output_using_clause
/*
20.21 dynamic_single_row_select_statement

Function
Retrieve values from a dynamically-specified row of a table.


Format
*/
dynamic_single_row_select_statement ::=
  query_specification
/*
20.22 dynamic_close_statement

Function
Close a dynamic cursor.


Format
*/
dynamic_close_statement ::=
  CLOSE conventional_dynamic_cursor_name
/*
20.23 dynamic_delete_statement__positioned

Function
Delete a row of a table.


Format
*/
dynamic_delete_statement__positioned ::=
  DELETE FROM target_table WHERE CURRENT OF conventional_dynamic_cursor_name

/*
20.24 dynamic_update_statement__positioned

Function
Update a row of a table.


Format
*/
dynamic_update_statement__positioned ::=
  UPDATE target_table SET set_clause_list
      WHERE CURRENT OF conventional_dynamic_cursor_name
/*
20.25 preparable_dynamic_delete_statement__positioned

Function
Delete a row of a table through a dynamic cursor.


Format
*/
preparable_dynamic_delete_statement__positioned ::=
  DELETE ( FROM target_table )?
      WHERE CURRENT OF preparable_dynamic_cursor_name
/*
20.26 preparable_dynamic_cursor_name

Function
Specify the cursor of a preparable_dynamic_delete_statement__positioned or a <preparable dynamic update
statement: positioned>.


Format
*/
preparable_dynamic_cursor_name ::=
   scope_option? cursor_name
/*
20.27 preparable_dynamic_update_statement__positioned

Function
Update a row of a table through a dynamic cursor.


Format
*/
preparable_dynamic_update_statement__positioned ::=
  UPDATE  target_table? SET set_clause_list
      WHERE CURRENT OF preparable_dynamic_cursor_name
/*
20.28 pipe_row_statement

Function
Output a row from a polymorphic table function.


Format
*/
pipe_row_statement ::=
  PIPE ROW PTF_descriptor_name
/*
21 Embedded SQL


21.1 embedded_SQL_host_program

Function
Specify an embedded_SQL_host_program.


Format
*/
embedded_SQL_host_program ::=
    embedded_SQL_Ada_program
  | embedded_SQL_C_program
  | embedded_SQL_COBOL_program
  | embedded_SQL_Fortran_program
  | embedded_SQL_MUMPS_program
  | embedded_SQL_Pascal_program
  | embedded_SQL_PL_I_program

embedded_SQL_statement ::=
  SQL_prefix statement_or_declaration  SQL_terminator?

statement_or_declaration ::=
    declare_cursor
  | dynamic_declare_cursor
  | temporary_table_declaration
  | embedded_authorization_declaration
  | embedded_path_specification
  | embedded_transform_group_specification
  | embedded_collation_specification
  | embedded_exception_declaration
  | SQL_procedure_statement

SQL_prefix ::=
    EXEC SQL
  | ampersand SQL left_paren

SQL_terminator ::=
    END EXEC
  | semicolon
  | right_paren

embedded_authorization_declaration ::=
  DECLARE embedded_authorization_clause

embedded_authorization_clause ::=
    SCHEMA schema_name
  | AUTHORIZATION embedded_authorization_identifier
      ( FOR STATIC ( ONLY | AND DYNAMIC ) )?
  | SCHEMA schema_name AUTHORIZATION embedded_authorization_identifier
      ( FOR STATIC ( ONLY | AND DYNAMIC ) )?

embedded_authorization_identifier ::=
  module_authorization_identifier

embedded_path_specification ::=
  path_specification

embedded_transform_group_specification ::=
  transform_group_specification

embedded_collation_specification ::=
  module_collations

embedded_SQL_declare_section ::=
    embedded_SQL_begin_declare
        embedded_character_set_declaration?
        host_variable_definition*
        embedded_SQL_end_declare
  | embedded_SQL_MUMPS_declare

embedded_character_set_declaration ::=
  SQL NAMES ARE character_set_specification

embedded_SQL_begin_declare ::=
  SQL_prefix BEGIN DECLARE SECTION SQL_terminator?

embedded_SQL_end_declare ::=
  SQL_prefix END DECLARE SECTION SQL_terminator?

embedded_SQL_MUMPS_declare ::=
  SQL_prefix
      BEGIN DECLARE SECTION
      embedded_character_set_declaration?
      host_variable_definition*
      END DECLARE SECTION
      SQL_terminator

host_variable_definition ::=
    Ada_variable_definition
  | C_variable_definition
  | COBOL_variable_definition
  | Fortran_variable_definition
  | MUMPS_variable_definition
  | Pascal_variable_definition
  | PL_I_variable_definition

embedded_variable_name ::=
  colon host_identifier

host_identifier ::=
    Ada_host_identifier
  | C_host_identifier
  | COBOL_host_identifier
  | Fortran_host_identifier
  | MUMPS_host_identifier
  | Pascal_host_identifier
  | PL_I_host_identifier
/*
21.2 embedded_exception_declaration

Function
Specify the action to be taken when an SQL-statement causes a specific class of condition to be raised.


Format
*/
embedded_exception_declaration ::=
  WHENEVER condition condition_action

condition ::=
  SQL_condition

SQL_condition ::=
    major_category
  | SQLSTATE ( SQLSTATE_class_code ( ',' SQLSTATE_subclass_code )? )
  | CONSTRAINT constraint_name

major_category ::=
    SQLEXCEPTION
  | SQLWARNING
  | NOT FOUND

SQLSTATE_class_code ::=
  SQLSTATE_char SQLSTATE_char "!! See the Syntax Rules."

SQLSTATE_subclass_code ::=
  SQLSTATE_char SQLSTATE_char SQLSTATE_char "!! See the Syntax Rules."

SQLSTATE_char ::=
    simple_Latin_upper_case_letter
  | digit

condition_action ::=
    CONTINUE
  | go_to

go_to ::=
  ( GOTO | GO TO ) goto_target

goto_target ::=
    host_label_identifier
  | unsigned_integer
  | host_PL_I_label_variable

host_label_identifier ::=
  "!! See the Syntax Rules."

host_PL_I_label_variable ::=
  "!! See the Syntax Rules."
/*
21.3 embedded_SQL_Ada_program

Function
Specify an embedded_SQL_Ada_program.


Format
*/
embedded_SQL_Ada_program ::=
  "!! See the Syntax Rules."

Ada_variable_definition ::=
  Ada_host_identifier ( comma Ada_host_identifier )* colon
      Ada_type_specification  Ada_initial_value?

Ada_initial_value ::=
  Ada_assignment_operator character_representation+

Ada_assignment_operator ::=
  colon equals_operator

Ada_host_identifier ::=
  "!! See the Syntax Rules."

Ada_type_specification ::=
    Ada_qualified_type_specification
  | Ada_unqualified_type_specification
  | Ada_derived_type_specification

Ada_qualified_type_specification ::=
    Interfaces.SQL.CHAR
        ( CHARACTER SET IS? character_set_specification )?
        left_paren "1" double_period character_length right_paren
  | Interfaces.SQL.SMALLINT
  | Interfaces.SQL.INT
  | Interfaces.SQL.BIGINT
  | Interfaces.SQL.REAL
  | Interfaces.SQL.DOUBLE_PRECISION
  | Interfaces.SQL.BOOLEAN
  | Interfaces.SQL.SQLSTATE_TYPE
  | Interfaces.SQL.INDICATOR_TYPE

Ada_unqualified_type_specification ::=
    CHAR left_paren "1" double_period character_length right_paren
  | SMALLINT
  | INT
  | BIGINT
  | REAL
  | DOUBLE_PRECISION
  | BOOLEAN
  | SQLSTATE_TYPE
  | INDICATOR_TYPE

Ada_derived_type_specification ::=
    Ada_CLOB_variable
  | Ada_CLOB_locator_variable
  | Ada_BINARY_variable
  | Ada_VARBINARY_variable
  | Ada_BLOB_variable
  | Ada_BLOB_locator_variable
  | Ada_user_defined_type_variable
  | Ada_user_defined_type_locator_variable
  | Ada_REF_variable
  | Ada_array_locator_variable
  | Ada_multiset_locator_variable

Ada_CLOB_variable ::=
  SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET IS? character_set_specification )?

Ada_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR

Ada_BINARY_variable ::=
  SQL TYPE IS BINARY left_paren length right_paren

Ada_VARBINARY_variable ::=
  SQL TYPE IS VARBINARY left_paren length right_paren

Ada_BLOB_variable ::=
  SQL TYPE IS BLOB left_paren large_object_length right_paren

Ada_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR

Ada_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type

Ada_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

Ada_REF_variable ::=
  SQL TYPE IS reference_type

Ada_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR

Ada_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR
/*
21.4 embedded_SQL_C_program

Function
Specify an embedded_SQL_C_program.


Format
*/
embedded_SQL_C_program ::=
  "!! See the Syntax Rules."

C_variable_definition ::=
   C_storage_class?  C_class_modifier?
      C_variable_specification semicolon

C_variable_specification ::=
    C_numeric_variable
  | C_character_variable
  | C_derived_variable

C_storage_class ::=
    "auto"
  | "extern"
  | "static"

C_class_modifier ::=
    "const"
  | "volatile"

C_numeric_variable ::=
  ( "long" "long" | "long" | "short" | "float" | "double" )
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier  C_initial_value? )*

C_character_variable ::=
  C_character_type ( CHARACTER SET  IS? character_set_specification )?
      C_host_identifier C_array_specification  C_initial_value?
      ( comma C_host_identifier C_array_specification
       C_initial_value? )*

C_character_type ::=
    "char"
  | "unsigned" "char"
  | "unsigned" "short"

C_array_specification ::=
  left_bracket character_length right_bracket

C_host_identifier ::=
  "!! See the Syntax Rules."

C_derived_variable ::=
    C_VARCHAR_variable
  | C_NCHAR_variable
  | C_NCHAR_VARYING_variable
  | C_CLOB_variable
  | C_NCLOB_variable
  | C_BINARY_variable
  | C_VARBINARY_variable
  | C_BLOB_variable
  | C_user_defined_type_variable
  | C_CLOB_locator_variable
  | C_BLOB_locator_variable
  | C_array_locator_variable
  | C_multiset_locator_variable
  | C_user_defined_type_locator_variable
  | C_REF_variable

C_VARCHAR_variable ::=
  VARCHAR ( CHARACTER SET  IS? character_set_specification )?
      C_host_identifier C_array_specification  C_initial_value?
      ( comma C_host_identifier C_array_specification C_initial_value? )*

C_NCHAR_variable ::=
  NCHAR C_host_identifier C_array_specification  C_initial_value?
      ( comma C_host_identifier C_array_specification
       C_initial_value? )*

C_NCHAR_VARYING_variable ::=
  NCHAR VARYING C_host_identifier C_array_specification  C_initial_value?
      ( comma C_host_identifier C_array_specification C_initial_value? )*

C_CLOB_variable ::=
  SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET  IS? character_set_specification )?
      C_host_identifier  C_initial_value? ( comma C_host_identifier C_initial_value? )*

C_NCLOB_variable ::=
  SQL TYPE IS NCLOB left_paren character_large_object_length right_paren
      C_host_identifier  C_initial_value? ( comma C_host_identifier
       C_initial_value? )*

C_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_BINARY_variable ::=
  SQL TYPE IS BINARY left_paren length right_paren
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_VARBINARY_variable ::=
  SQL TYPE IS VARBINARY left_paren length right_paren
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier  C_initial_value? )*

C_BLOB_variable ::=
  SQL TYPE IS BLOB left_paren large_object_length right_paren
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR
      C_host_identifier  C_initial_value?
      ( comma C_host_identifier C_initial_value? )*

C_REF_variable ::=
  SQL TYPE IS reference_type C_host_identifier  C_initial_value?
      ( comma C_host_identifier  C_initial_value? )*

C_initial_value ::=
  equals_operator character_representation+
/*
21.5 embedded_SQL_COBOL_program

Function
Specify an embedded_SQL_COBOL_program.


Format
*/
embedded_SQL_COBOL_program ::=
  "!! See the Syntax Rules."

COBOL_variable_definition ::=
  ( "01" | "77" ) COBOL_host_identifier
      COBOL_type_specification character_representation* period

COBOL_host_identifier ::=
  "!! See the Syntax Rules."

COBOL_type_specification ::=
    COBOL_character_type
  | COBOL_national_character_type
  | COBOL_numeric_type
  | COBOL_integer_type
  | COBOL_derived_type_specification

COBOL_derived_type_specification ::=
    COBOL_CLOB_variable
  | COBOL_NCLOB_variable
  | COBOL_BINARY_variable
  | COBOL_BLOB_variable
  | COBOL_user_defined_type_variable
  | COBOL_CLOB_locator_variable
  | COBOL_BLOB_locator_variable
  | COBOL_array_locator_variable
  | COBOL_multiset_locator_variable
  | COBOL_user_defined_type_locator_variable
  | COBOL_REF_variable

COBOL_character_type ::=
  ( CHARACTER SET IS? character_set_specification )?
      ( PIC | PICTURE )  IS? ( "X" ( left_paren character_length right_paren )? )+

COBOL_national_character_type ::=
  ( PIC | PICTURE )  IS? ( "N" ( left_paren character_length right_paren )? )+

COBOL_CLOB_variable ::=
  ( USAGE  IS? )? SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET IS? character_set_specification )?

COBOL_NCLOB_variable ::=
  ( USAGE  IS? )? SQL TYPE IS NCLOB left_paren character_large_object_length right_paren

COBOL_BINARY_variable ::=
  ( USAGE  IS? )? SQL TYPE IS BINARY left_paren length right_paren

COBOL_BLOB_variable ::=
  ( USAGE  IS? )? SQL TYPE IS BLOB left_paren large_object_length right_paren

COBOL_user_defined_type_variable ::=
  ( USAGE  IS? )? SQL TYPE IS path_resolved_user_defined_type_name
      AS predefined_type

COBOL_CLOB_locator_variable ::=
  ( USAGE  IS? )? SQL TYPE IS CLOB AS LOCATOR

COBOL_BLOB_locator_variable ::=
  ( USAGE IS? )? SQL TYPE IS BLOB AS LOCATOR

COBOL_array_locator_variable ::=
  ( USAGE  IS? )? SQL TYPE IS array_type AS LOCATOR

COBOL_multiset_locator_variable ::=
  ( USAGE  IS? )? SQL TYPE IS multiset_type AS LOCATOR

COBOL_user_defined_type_locator_variable ::=
  ( USAGE  IS? )? SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

COBOL_REF_variable ::=
  ( USAGE  IS? )? SQL TYPE IS reference_type

COBOL_numeric_type ::=
  ( PIC | PICTURE )  IS? "S" COBOL_nines_specification
      ( USAGE  IS? )? DISPLAY SIGN LEADING SEPARATE

COBOL_nines_specification ::=
    COBOL_nines ( "V"  COBOL_nines? )?
  | "V" COBOL_nines

COBOL_integer_type ::=
  ( PIC | PICTURE )  IS? "S" COBOL_nines
      ( USAGE  IS? )? BINARY

COBOL_nines ::=
  ( "9" ( left_paren length right_paren )? )+
/*
21.6 embedded_SQL_Fortran_program

Function
Specify an embedded_SQL_Fortran_program.


Format
*/
embedded_SQL_Fortran_program ::=
  "!! See the Syntax Rules."

Fortran_variable_definition ::=
  Fortran_type_specification Fortran_host_identifier
      ( comma Fortran_host_identifier )*

Fortran_host_identifier ::=
  "!! See the Syntax Rules."

Fortran_type_specification ::=
    CHARACTER ( asterisk character_length )? ( CHARACTER SET
	IS? character_set_specification )?
  | CHARACTER KIND "=" "n" ( asterisk character_length )?
      ( CHARACTER SET  IS? character_set_specification )?
  | INTEGER
  | REAL
  | DOUBLE PRECISION
  | LOGICAL
  | Fortran_derived_type_specification

Fortran_derived_type_specification ::=
    Fortran_CLOB_variable
  | Fortran_BINARY_variable
  | Fortran_VARBINARY_variable
  | Fortran_BLOB_variable
  | Fortran_user_defined_type_variable
  | Fortran_CLOB_locator_variable
  | Fortran_BLOB_locator_variable
  | Fortran_user_defined_type_locator_variable
  | Fortran_array_locator_variable
  | Fortran_multiset_locator_variable
  | Fortran_REF_variable

Fortran_CLOB_variable ::=
  SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET  IS? character_set_specification )?

Fortran_BINARY_variable ::=
  SQL TYPE IS BINARY left_paren length right_paren

Fortran_VARBINARY_variable ::=
  SQL TYPE IS VARBINARY left_paren length right_paren

Fortran_BLOB_variable ::=
  SQL TYPE IS BLOB left_paren large_object_length right_paren

Fortran_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type

Fortran_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR

Fortran_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR

Fortran_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

Fortran_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR

Fortran_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR

Fortran_REF_variable ::=
  SQL TYPE IS reference_type
/*
21.7 embedded_SQL_MUMPS_program

Function
Specify an embedded_SQL_MUMPS_program.


Format
*/
embedded_SQL_MUMPS_program ::=
  "!! See the Syntax Rules."

MUMPS_variable_definition ::=
    MUMPS_numeric_variable semicolon
  | MUMPS_character_variable semicolon
  | MUMPS_derived_type_specification MUMPS_host_identifier semicolon

MUMPS_character_variable ::=
  VARCHAR MUMPS_character_variable_specifier
      ( comma MUMPS_character_variable_specifier )*

MUMPS_character_variable_specifier ::=
  MUMPS_host_identifier MUMPS_length_specification
      ( CHARACTER SET  IS? character_set_specification )?

MUMPS_host_identifier ::=
  "!! See the Syntax Rules."

MUMPS_length_specification ::=
  left_paren character_length right_paren

MUMPS_numeric_variable ::=
  MUMPS_type_specification MUMPS_host_identifier
      ( comma MUMPS_host_identifier )*

MUMPS_type_specification ::=
    INT
  | DEC ( left_paren precision ( comma scale )? right_paren )?
  | REAL

MUMPS_derived_type_specification ::=
    MUMPS_user_defined_type_variable
  | MUMPS_CLOB_locator_variable
  | MUMPS_BLOB_locator_variable
  | MUMPS_user_defined_type_locator_variable
  | MUMPS_array_locator_variable
  | MUMPS_multiset_locator_variable
  | MUMPS_REF_variable

MUMPS_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type

MUMPS_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR

MUMPS_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR

MUMPS_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

MUMPS_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR

MUMPS_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR

MUMPS_REF_variable ::=
  SQL TYPE IS reference_type
/*
21.8 embedded_SQL_Pascal_program

Function
Specify an embedded_SQL_Pascal_program.


Format
*/
embedded_SQL_Pascal_program ::=
  "!! See the Syntax Rules."

Pascal_variable_definition ::=
  Pascal_host_identifier ( comma Pascal_host_identifier )* colon
      Pascal_type_specification semicolon

Pascal_host_identifier ::=
  "!! See the Syntax Rules."

Pascal_type_specification ::=
    PACKED ARRAY left_bracket "1" double_period character_length right_bracket
        OF CHAR ( CHARACTER SET  IS? character_set_specification )?
  | INTEGER
  | REAL
  | CHAR ( CHARACTER SET  IS? character_set_specification )?
  | BOOLEAN
  | Pascal_derived_type_specification

Pascal_derived_type_specification ::=
    Pascal_CLOB_variable
  | Pascal_BINARY_variable
  | Pascal_BLOB_variable
  | Pascal_user_defined_type_variable
  | Pascal_CLOB_locator_variable
  | Pascal_BLOB_locator_variable
  | Pascal_user_defined_type_locator_variable
  | Pascal_array_locator_variable
  | Pascal_multiset_locator_variable
  | Pascal_REF_variable

Pascal_CLOB_variable ::=
  SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET  IS? character_set_specification )?

Pascal_BINARY_variable ::=
  SQL TYPE IS BINARY left_paren length right_paren

Pascal_BLOB_variable ::=
  SQL TYPE IS BLOB left_paren large_object_length right_paren

Pascal_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR

Pascal_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type

Pascal_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR

Pascal_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

Pascal_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR

Pascal_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR

Pascal_REF_variable ::=
  SQL TYPE IS reference_type
/*
21.9 embedded_SQL_PL_I_program

Function
Specify an embedded_SQL_PL_I_program.


Format
*/
embedded_SQL_PL_I_program ::=
  "!! See the Syntax Rules."

PL_I_variable_definition ::=
    ( DCL | DECLARE ) PL_I_type_specification character_representation* semicolon
  | ( PL_I_host_identifier | left_paren PL_I_host_identifier
      ( comma PL_I_host_identifier )* right_paren )
      PL_I_type_specification character_representation* semicolon

PL_I_host_identifier ::=
  "!! See the Syntax Rules."

PL_I_type_specification ::=
    ( CHAR | CHARACTER )  VARYING? left_paren character_length right_paren
        ( CHARACTER SET  IS? character_set_specification )?
  | PL_I_type_fixed_decimal left_paren precision ( comma scale )? right_paren
  | PL_I_type_fixed_binary ( left_paren precision right_paren )?
  | PL_I_type_float_binary left_paren precision right_paren
  | PL_I_derived_type_specification

PL_I_derived_type_specification ::=
    PL_I_CLOB_variable
  | PL_I_BINARY_variable
  | PL_I_VARBINARY_variable
  | PL_I_BLOB_variable
  | PL_I_user_defined_type_variable
  | PL_I_CLOB_locator_variable
  | PL_I_BLOB_locator_variable
  | PL_I_user_defined_type_locator_variable
  | PL_I_array_locator_variable
  | PL_I_multiset_locator_variable
  | PL_I_REF_variable

PL_I_CLOB_variable ::=
  SQL TYPE IS CLOB left_paren character_large_object_length right_paren
      ( CHARACTER SET  IS? character_set_specification )?

PL_I_BINARY_variable ::=
  SQL TYPE IS BINARY left_paren length right_paren

PL_I_VARBINARY_variable ::=
  SQL TYPE IS VARBINARY left_paren length right_paren

PL_I_BLOB_variable ::=
  SQL TYPE IS BLOB left_paren large_object_length right_paren

PL_I_user_defined_type_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS predefined_type

PL_I_CLOB_locator_variable ::=
  SQL TYPE IS CLOB AS LOCATOR

PL_I_BLOB_locator_variable ::=
  SQL TYPE IS BLOB AS LOCATOR

PL_I_user_defined_type_locator_variable ::=
  SQL TYPE IS path_resolved_user_defined_type_name AS LOCATOR

PL_I_array_locator_variable ::=
  SQL TYPE IS array_type AS LOCATOR

PL_I_multiset_locator_variable ::=
  SQL TYPE IS multiset_type AS LOCATOR

PL_I_REF_variable ::=
  SQL TYPE IS reference_type

PL_I_type_fixed_decimal ::=
    ( DEC | DECIMAL ) FIXED
  | FIXED ( DEC | DECIMAL )

PL_I_type_fixed_binary ::=
    ( BIN | BINARY ) FIXED
  | FIXED ( BIN | BINARY )

PL_I_type_float_binary ::=
    ( BIN | BINARY ) FLOAT
  | FLOAT ( BIN | BINARY )

/*
22.2 direct_select_statement__multiple_rows

Function
Specify a statement to retrieve multiple rows from a specified table.


Format
*/
direct_select_statement__multiple_rows ::=
  cursor_specification
/*
23 Diagnostics management


23.1 get_diagnostics_statement

Function
Get exception or completion condition information from a diagnostics area.


Format
*/
get_diagnostics_statement ::=
  GET DIAGNOSTICS SQL_diagnostics_information

SQL_diagnostics_information ::=
    statement_information
  | condition_information
  | all_information

statement_information ::=
      statement_information_item ( comma statement_information_item )*

statement_information_item ::=
  simple_target_specification equals_operator statement_information_item_name

statement_information_item_name ::=
    NUMBER
  | MORE
  | COMMAND_FUNCTION
  | COMMAND_FUNCTION_CODE
  | DYNAMIC_FUNCTION
  | DYNAMIC_FUNCTION_CODE
  | ROW_COUNT
  | TRANSACTIONS_COMMITTED
  | TRANSACTIONS_ROLLED_BACK
  | TRANSACTION_ACTIVE

condition_information ::=
  CONDITION condition_number condition_information_item
      ( comma condition_information_item )*

condition_information_item ::=
  simple_target_specification equals_operator condition_information_item_name

condition_information_item_name ::=
    CATALOG_NAME
  | CLASS_ORIGIN
  | COLUMN_NAME
  | CONDITION_NUMBER
  | CONNECTION_NAME
  | CONSTRAINT_CATALOG
  | CONSTRAINT_NAME
  | CONSTRAINT_SCHEMA
  | CURSOR_NAME
  | MESSAGE_LENGTH
  | MESSAGE_OCTET_LENGTH
  | MESSAGE_TEXT
  | PARAMETER_MODE
  | PARAMETER_NAME
  | PARAMETER_ORDINAL_POSITION
  | RETURNED_SQLSTATE
  | ROUTINE_CATALOG
  | ROUTINE_NAME
  | ROUTINE_SCHEMA
  | SCHEMA_NAME
  | SERVER_NAME
  | SPECIFIC_NAME
  | SUBCLASS_ORIGIN
  | TABLE_NAME
  | TRIGGER_CATALOG
  | TRIGGER_NAME
  | TRIGGER_SCHEMA

all_information ::=
  all_info_target equals_operator ALL  all_qualifier?

all_info_target ::=
  simple_target_specification

all_qualifier ::=
    STATEMENT
  | CONDITION  condition_number?

condition_number ::=
  simple_value_specification

// Tokens

//non_reserved_word

 A ::= "A*"
ABSOLUTE ::= "ABSOLUTE*"
ACTION ::= "ACTION*"
ADA ::= "ADA*"
ADD ::= "ADD*"
ADMIN ::= "ADMIN*"
AFTER ::= "AFTER*"
ALWAYS ::= "ALWAYS*"
ASC ::= "ASC*"
ASSERTION ::= "ASSERTION*"
ASSIGNMENT ::= "ASSIGNMENT*"
ATTRIBUTE ::= "ATTRIBUTE*"
ATTRIBUTES ::= "ATTRIBUTES*"
BEFORE ::= "BEFORE*"
BERNOULLI ::= "BERNOULLI*"
BREADTH ::= "BREADTH*"
C ::= "C*"
CASCADE ::= "CASCADE*"
CATALOG ::= "CATALOG*"
CATALOG_NAME ::= "CATALOG_NAME*"
CHAIN ::= "CHAIN*"
CHAINING ::= "CHAINING*"
CHARACTER_SET_CATALOG ::= "CHARACTER_SET_CATALOG*"
CHARACTER_SET_NAME ::= "CHARACTER_SET_NAME*"
CHARACTER_SET_SCHEMA ::= "CHARACTER_SET_SCHEMA*"
CHARACTERISTICS ::= "CHARACTERISTICS*"
CHARACTERS ::= "CHARACTERS*"
CLASS_ORIGIN ::= "CLASS_ORIGIN*"
COBOL ::= "COBOL*"
COLLATION ::= "COLLATION*"
COLLATION_CATALOG ::= "COLLATION_CATALOG*"
COLLATION_NAME ::= "COLLATION_NAME*"
COLLATION_SCHEMA ::= "COLLATION_SCHEMA*"
COLUMNS ::= "COLUMNS*"
COLUMN_NAME ::= "COLUMN_NAME*"
COMMAND_FUNCTION ::= "COMMAND_FUNCTION*"
COMMAND_FUNCTION_CODE ::= "COMMAND_FUNCTION_CODE*"
COMMITTED ::= "COMMITTED*"
CONDITIONAL ::= "CONDITIONAL*"
CONDITION_NUMBER ::= "CONDITION_NUMBER*"
CONNECTION ::= "CONNECTION*"
CONNECTION_NAME ::= "CONNECTION_NAME*"
CONSTRAINT_CATALOG ::= "CONSTRAINT_CATALOG*"
CONSTRAINT_NAME ::= "CONSTRAINT_NAME*"
CONSTRAINT_SCHEMA ::= "CONSTRAINT_SCHEMA*"
CONSTRAINTS ::= "CONSTRAINTS*"
CONSTRUCTOR ::= "CONSTRUCTOR*"
CONTINUE ::= "CONTINUE*"
CURSOR_NAME ::= "CURSOR_NAME*"
DATA ::= "DATA*"
DATETIME_INTERVAL_CODE ::= "DATETIME_INTERVAL_CODE*"
DATETIME_INTERVAL_PRECISION ::= "DATETIME_INTERVAL_PRECISION*"
DEFAULTS ::= "DEFAULTS*"
DEFERRABLE ::= "DEFERRABLE*"
DEFERRED ::= "DEFERRED*"
DEFINED ::= "DEFINED*"
DEFINER ::= "DEFINER*"
DEGREE ::= "DEGREE*"
DEPTH ::= "DEPTH*"
DERIVED ::= "DERIVED*"
DESC ::= "DESC*"
DESCRIBE_CATALOG ::= "DESCRIBE_CATALOG*"
DESCRIBE_NAME ::= "DESCRIBE_NAME*"
DESCRIBE_PROCEDURE_SPECIFIC_CATALOG ::= "DESCRIBE_PROCEDURE_SPECIFIC_CATALOG*"
DESCRIBE_PROCEDURE_SPECIFIC_NAME ::= "DESCRIBE_PROCEDURE_SPECIFIC_NAME*"
DESCRIBE_PROCEDURE_SPECIFIC_SCHEMA ::= "DESCRIBE_PROCEDURE_SPECIFIC_SCHEMA*"
DESCRIBE_SCHEMA ::= "DESCRIBE_SCHEMA*"
DESCRIPTOR ::= "DESCRIPTOR*"
DIAGNOSTICS ::= "DIAGNOSTICS*"
DISPATCH ::= "DISPATCH*"
DOMAIN ::= "DOMAIN*"
DYNAMIC_FUNCTION ::= "DYNAMIC_FUNCTION*"
DYNAMIC_FUNCTION_CODE ::= "DYNAMIC_FUNCTION_CODE*"
ENCODING ::= "ENCODING*"
ENFORCED ::= "ENFORCED*"
ERROR ::= "ERROR*"
EXCLUDE ::= "EXCLUDE*"
EXCLUDING ::= "EXCLUDING*"
EXPRESSION ::= "EXPRESSION*"
FINAL ::= "FINAL*"
FINISH ::= "FINISH*"
FINISH_CATALOG ::= "FINISH_CATALOG*"
FINISH_NAME ::= "FINISH_NAME*"
FINISH_PROCEDURE_SPECIFIC_CATALOG ::= "FINISH_PROCEDURE_SPECIFIC_CATALOG*"
FINISH_PROCEDURE_SPECIFIC_NAME ::= "FINISH_PROCEDURE_SPECIFIC_NAME*"
FINISH_PROCEDURE_SPECIFIC_SCHEMA ::= "FINISH_PROCEDURE_SPECIFIC_SCHEMA*"
FINISH_SCHEMA ::= "FINISH_SCHEMA*"
FIRST ::= "FIRST*"
FLAG ::= "FLAG*"
FOLLOWING ::= "FOLLOWING*"
FORMAT ::= "FORMAT*"
FORTRAN ::= "FORTRAN*"
FOUND ::= "FOUND*"
FULFILL ::= "FULFILL*"
FULFILL_CATALOG ::= "FULFILL_CATALOG*"
FULFILL_NAME ::= "FULFILL_NAME*"
FULFILL_PROCEDURE_SPECIFIC_CATALOG ::= "FULFILL_PROCEDURE_SPECIFIC_CATALOG*"
FULFILL_PROCEDURE_SPECIFIC_NAME ::= "FULFILL_PROCEDURE_SPECIFIC_NAME*"
FULFILL_PROCEDURE_SPECIFIC_SCHEMA ::= "FULFILL_PROCEDURE_SPECIFIC_SCHEMA*"
FULFILL_SCHEMA ::= "FULFILL_SCHEMA*"
G ::= "G*"
GENERAL ::= "GENERAL*"
GENERATED ::= "GENERATED*"
GO ::= "GO*"
GOTO ::= "GOTO*"
GRANTED ::= "GRANTED*"
HAS_PASS_THROUGH_COLUMNS ::= "HAS_PASS_THROUGH_COLUMNS*"
HAS_PASS_THRU_COLS ::= "HAS_PASS_THRU_COLS*"
HIERARCHY ::= "HIERARCHY*"
IGNORE ::= "IGNORE*"
IMMEDIATE ::= "IMMEDIATE*"
IMMEDIATELY ::= "IMMEDIATELY*"
IMPLEMENTATION ::= "IMPLEMENTATION*"
INCLUDING ::= "INCLUDING*"
INCREMENT ::= "INCREMENT*"
INITIALLY ::= "INITIALLY*"
INPUT ::= "INPUT*"
INSTANCE ::= "INSTANCE*"
INSTANTIABLE ::= "INSTANTIABLE*"
INSTEAD ::= "INSTEAD*"
INVOKER ::= "INVOKER*"
ISOLATION ::= "ISOLATION*"
IS_PRUNABLE ::= "IS_PRUNABLE*"
JSON ::= "JSON*"
K ::= "K*"
KEEP ::= "KEEP*"
KEY ::= "KEY*"
KEYS ::= "KEYS*"
KEY_MEMBER ::= "KEY_MEMBER*"
KEY_TYPE ::= "KEY_TYPE*"
LAST ::= "LAST*"
LENGTH ::= "LENGTH*"
LEVEL ::= "LEVEL*"
LOCATOR ::= "LOCATOR*"
M ::= "M*"
MAP ::= "MAP*"
MATCHED ::= "MATCHED*"
MAXVALUE ::= "MAXVALUE*"
MESSAGE_LENGTH ::= "MESSAGE_LENGTH*"
MESSAGE_OCTET_LENGTH ::= "MESSAGE_OCTET_LENGTH*"
MESSAGE_TEXT ::= "MESSAGE_TEXT*"
MINVALUE ::= "MINVALUE*"
MORE ::= "MORE*"
MUMPS ::= "MUMPS*"
NAME ::= "NAME*"
NAMES ::= "NAMES*"
NESTED ::= "NESTED*"
NESTING ::= "NESTING*"
NEXT ::= "NEXT*"
NFC ::= "NFC*"
NFD ::= "NFD*"
NFKC ::= "NFKC*"
NFKD ::= "NFKD*"
NORMALIZED ::= "NORMALIZED*"
NULLABLE ::= "NULLABLE*"
NULLS ::= "NULLS*"
NUMBER ::= "NUMBER*"
OBJECT ::= "OBJECT*"
OCTETS ::= "OCTETS*"
OPTION ::= "OPTION*"
OPTIONS ::= "OPTIONS*"
ORDERING ::= "ORDERING*"
ORDINALITY ::= "ORDINALITY*"
OTHERS ::= "OTHERS*"
OUTPUT ::= "OUTPUT*"
OVERFLOW ::= "OVERFLOW*"
OVERRIDING ::= "OVERRIDING*"
P ::= "P*"
PAD ::= "PAD*"
PARAMETER_MODE ::= "PARAMETER_MODE*"
PARAMETER_NAME ::= "PARAMETER_NAME*"
PARAMETER_ORDINAL_POSITION ::= "PARAMETER_ORDINAL_POSITION*"
PARAMETER_SPECIFIC_CATALOG ::= "PARAMETER_SPECIFIC_CATALOG*"
PARAMETER_SPECIFIC_NAME ::= "PARAMETER_SPECIFIC_NAME*"
PARAMETER_SPECIFIC_SCHEMA ::= "PARAMETER_SPECIFIC_SCHEMA*"
PARTIAL ::= "PARTIAL*"
PASCAL ::= "PASCAL*"
PASS ::= "PASS*"
PASSING ::= "PASSING*"
PAST ::= "PAST*"
PATH ::= "PATH*"
PLACING ::= "PLACING*"
PLAN ::= "PLAN*"
PLI ::= "PLI*"
PRECEDING ::= "PRECEDING*"
PRESERVE ::= "PRESERVE*"
PRIOR ::= "PRIOR*"
PRIVATE ::= "PRIVATE*"
PRIVATE_PARAMETERS ::= "PRIVATE_PARAMETERS*"
PRIVATE_PARAMS_S ::= "PRIVATE_PARAMS_S*"
PRIVILEGES ::= "PRIVILEGES*"
PRUNE ::= "PRUNE*"
PUBLIC ::= "PUBLIC*"
QUOTES ::= "QUOTES*"
READ ::= "READ*"
RELATIVE ::= "RELATIVE*"
REPEATABLE ::= "REPEATABLE*"
RESPECT ::= "RESPECT*"
RESTART ::= "RESTART*"
RESTRICT ::= "RESTRICT*"
RETURNED_CARDINALITY ::= "RETURNED_CARDINALITY*"
RETURNED_LENGTH ::= "RETURNED_LENGTH*"
RETURNED_OCTET_LENGTH ::= "RETURNED_OCTET_LENGTH*"
RETURNED_SQLSTATE ::= "RETURNED_SQLSTATE*"
RETURNING ::= "RETURNING*"
RETURNS_ONLY_PASS_THROUGH ::= "RETURNS_ONLY_PASS_THROUGH*"
RET_ONLY_PASS_THRU ::= "RET_ONLY_PASS_THRU*"
ROLE ::= "ROLE*"
ROUTINE ::= "ROUTINE*"
ROUTINE_CATALOG ::= "ROUTINE_CATALOG*"
ROUTINE_NAME ::= "ROUTINE_NAME*"
ROUTINE_SCHEMA ::= "ROUTINE_SCHEMA*"
ROW_COUNT ::= "ROW_COUNT*"
SCALAR ::= "SCALAR*"
SCALE ::= "SCALE*"
SCHEMA ::= "SCHEMA*"
SCHEMA_NAME ::= "SCHEMA_NAME*"
SCOPE_CATALOG ::= "SCOPE_CATALOG*"
SCOPE_NAME ::= "SCOPE_NAME*"
SCOPE_SCHEMA ::= "SCOPE_SCHEMA*"
SECTION ::= "SECTION*"
SECURITY ::= "SECURITY*"
SELF ::= "SELF*"
SEQUENCE ::= "SEQUENCE*"
SERIALIZABLE ::= "SERIALIZABLE*"
SERVER_NAME ::= "SERVER_NAME*"
SESSION ::= "SESSION*"
SETS ::= "SETS*"
SIMPLE ::= "SIMPLE*"
SIZE ::= "SIZE*"
SOURCE ::= "SOURCE*"
SPACE ::= "SPACE*"
SPECIFIC_NAME ::= "SPECIFIC_NAME*"
START_CATALOG ::= "START_CATALOG*"
START_NAME ::= "START_NAME*"
START_PROCEDURE_SPECIFIC_CATALOG ::= "START_PROCEDURE_SPECIFIC_CATALOG*"
START_PROCEDURE_SPECIFIC_NAME ::= "START_PROCEDURE_SPECIFIC_NAME*"
START_PROCEDURE_SPECIFIC_SCHEMA ::= "START_PROCEDURE_SPECIFIC_SCHEMA*"
START_SCHEMA ::= "START_SCHEMA*"
STATE ::= "STATE*"
STATEMENT ::= "STATEMENT*"
STRING ::= "STRING*"
STRUCTURE ::= "STRUCTURE*"
STYLE ::= "STYLE*"
SUBCLASS_ORIGIN ::= "SUBCLASS_ORIGIN*"
T ::= "T*"
TABLE_NAME ::= "TABLE_NAME*"
TABLE_SEMANTICS ::= "TABLE_SEMANTICS*"
TEMPORARY ::= "TEMPORARY*"
THROUGH ::= "THROUGH*"
TIES ::= "TIES*"
TOP_LEVEL_COUNT ::= "TOP_LEVEL_COUNT*"
TRANSACTION ::= "TRANSACTION*"
TRANSACTION_ACTIVE ::= "TRANSACTION_ACTIVE*"
TRANSACTIONS_COMMITTED ::= "TRANSACTIONS_COMMITTED*"
TRANSACTIONS_ROLLED_BACK ::= "TRANSACTIONS_ROLLED_BACK*"
TRANSFORM ::= "TRANSFORM*"
TRANSFORMS ::= "TRANSFORMS*"
TRIGGER_CATALOG ::= "TRIGGER_CATALOG*"
TRIGGER_NAME ::= "TRIGGER_NAME*"
TRIGGER_SCHEMA ::= "TRIGGER_SCHEMA*"
TYPE ::= "TYPE*"
UNBOUNDED ::= "UNBOUNDED*"
UNCOMMITTED ::= "UNCOMMITTED*"
UNCONDITIONAL ::= "UNCONDITIONAL*"
UNDER ::= "UNDER*"
UNNAMED ::= "UNNAMED*"
USAGE ::= "USAGE*"
USER_DEFINED_TYPE_CATALOG ::= "USER_DEFINED_TYPE_CATALOG*"
USER_DEFINED_TYPE_CODE ::= "USER_DEFINED_TYPE_CODE*"
USER_DEFINED_TYPE_NAME ::= "USER_DEFINED_TYPE_NAME*"
USER_DEFINED_TYPE_SCHEMA ::= "USER_DEFINED_TYPE_SCHEMA*"
UTF16 ::= "UTF16*"
UTF32 ::= "UTF32*"
UTF8 ::= "UTF8*"
VIEW ::= "VIEW*"
WORK ::= "WORK*"
WRAPPER ::= "WRAPPER*"
WRITE ::= "WRITE*"
ZONE ::= "ZONE*"

//reserved_word

ABS ::= "ABS"
ACOS ::= "ACOS"
ALL ::= "ALL"
ALLOCATE ::= "ALLOCATE"
ALTER ::= "ALTER"
AND ::= "AND"
ANY ::= "ANY"
ARE ::= "ARE"
ARRAY ::= "ARRAY"
ARRAY_AGG ::= "ARRAY_AGG"
ARRAY_MAX_CARDINALITY ::= "ARRAY_MAX_CARDINALITY"
AS ::= "AS"
ASENSITIVE ::= "ASENSITIVE"
ASIN ::= "ASIN"
ASYMMETRIC ::= "ASYMMETRIC"
AT ::= "AT"
ATAN ::= "ATAN"
ATOMIC ::= "ATOMIC"
AUTHORIZATION ::= "AUTHORIZATION"
AVG ::= "AVG"
BEGIN ::= "BEGIN"
BEGIN_FRAME ::= "BEGIN_FRAME"
BEGIN_PARTITION ::= "BEGIN_PARTITION"
BETWEEN ::= "BETWEEN"
BIGINT ::= "BIGINT"
BINARY ::= "BINARY"
BLOB ::= "BLOB"
BOOLEAN ::= "BOOLEAN"
BOTH ::= "BOTH"
BY ::= "BY"
CALL ::= "CALL"
CALLED ::= "CALLED"
CARDINALITY ::= "CARDINALITY"
CASCADED ::= "CASCADED"
CASE ::= "CASE"
CAST ::= "CAST"
CEIL ::= "CEIL"
CEILING ::= "CEILING"
CHAR ::= "CHAR"
CHAR_LENGTH ::= "CHAR_LENGTH"
CHARACTER ::= "CHARACTER"
CHARACTER_LENGTH ::= "CHARACTER_LENGTH"
CHECK ::= "CHECK"
CLASSIFIER ::= "CLASSIFIER"
CLOB ::= "CLOB"
CLOSE ::= "CLOSE"
COALESCE ::= "COALESCE"
COLLATE ::= "COLLATE"
COLLECT ::= "COLLECT"
COLUMN ::= "COLUMN"
COMMIT ::= "COMMIT"
CONDITION ::= "CONDITION"
CONNECT ::= "CONNECT"
CONSTRAINT ::= "CONSTRAINT"
CONTAINS ::= "CONTAINS"
CONVERT ::= "CONVERT"
COPY ::= "COPY"
CORR ::= "CORR"
CORRESPONDING ::= "CORRESPONDING"
COS ::= "COS"
COSH ::= "COSH"
COUNT ::= "COUNT"
COVAR_POP ::= "COVAR_POP"
COVAR_SAMP ::= "COVAR_SAMP"
CREATE ::= "CREATE"
CROSS ::= "CROSS"
CUBE ::= "CUBE"
CUME_DIST ::= "CUME_DIST"
CURRENT ::= "CURRENT"
CURRENT_CATALOG ::= "CURRENT_CATALOG"
CURRENT_DATE ::= "CURRENT_DATE"
CURRENT_DEFAULT_TRANSFORM_GROUP ::= "CURRENT_DEFAULT_TRANSFORM_GROUP"
CURRENT_PATH ::= "CURRENT_PATH"
CURRENT_ROLE ::= "CURRENT_ROLE"
CURRENT_ROW ::= "CURRENT_ROW"
CURRENT_SCHEMA ::= "CURRENT_SCHEMA"
CURRENT_TIME ::= "CURRENT_TIME"
CURRENT_TIMESTAMP ::= "CURRENT_TIMESTAMP"
CURRENT_PATH ::= "CURRENT_PATH"
CURRENT_ROLE ::= "CURRENT_ROLE"
CURRENT_TRANSFORM_GROUP_FOR_TYPE ::= "CURRENT_TRANSFORM_GROUP_FOR_TYPE"
CURRENT_USER ::= "CURRENT_USER"
CURSOR ::= "CURSOR"
CYCLE ::= "CYCLE"
DATE ::= "DATE"
DAY ::= "DAY"
DEALLOCATE ::= "DEALLOCATE"
DEC ::= "DEC"
DECIMAL ::= "DECIMAL"
DECFLOAT ::= "DECFLOAT"
DECLARE ::= "DECLARE"
DEFAULT ::= "DEFAULT"
DEFINE ::= "DEFINE"
DELETE ::= "DELETE"
DENSE_RANK ::= "DENSE_RANK"
DEREF ::= "DEREF"
DESCRIBE ::= "DESCRIBE"
DETERMINISTIC ::= "DETERMINISTIC"
DISCONNECT ::= "DISCONNECT"
DISTINCT ::= "DISTINCT"
DOUBLE ::= "DOUBLE"
DROP ::= "DROP"
DYNAMIC ::= "DYNAMIC"
EACH ::= "EACH"
ELEMENT ::= "ELEMENT"
ELSE ::= "ELSE"
EMPTY ::= "EMPTY"
END ::= "END"
END_FRAME ::= "END_FRAME"
END_PARTITION ::= "END_PARTITION"
END-EXEC ::= "END-EXEC"
EQUALS ::= "EQUALS"
ESCAPE ::= "ESCAPE"
EVERY ::= "EVERY"
EXCEPT ::= "EXCEPT"
EXEC ::= "EXEC"
EXECUTE ::= "EXECUTE"
EXISTS ::= "EXISTS"
EXP ::= "EXP"
EXTERNAL ::= "EXTERNAL"
EXTRACT ::= "EXTRACT"
FALSE ::= "FALSE"
FETCH ::= "FETCH"
FILTER ::= "FILTER"
FIRST_VALUE ::= "FIRST_VALUE"
FLOAT ::= "FLOAT"
FLOOR ::= "FLOOR"
FOR ::= "FOR"
FOREIGN ::= "FOREIGN"
FRAME_ROW ::= "FRAME_ROW"
FREE ::= "FREE"
FROM ::= "FROM"
FULL ::= "FULL"
FUNCTION ::= "FUNCTION"
FUSION ::= "FUSION"
GET ::= "GET"
GLOBAL ::= "GLOBAL"
GRANT ::= "GRANT"
GROUP ::= "GROUP"
GROUPING ::= "GROUPING"
GROUPS ::= "GROUPS"
HAVING ::= "HAVING"
HOLD ::= "HOLD"
HOUR ::= "HOUR"
IDENTITY ::= "IDENTITY"
IN ::= "IN"
INDICATOR ::= "INDICATOR"
INITIAL ::= "INITIAL"
INNER ::= "INNER"
INOUT ::= "INOUT"
INSENSITIVE ::= "INSENSITIVE"
INSERT ::= "INSERT"
INT ::= "INT"
INTEGER ::= "INTEGER"
INTERSECT ::= "INTERSECT"
INTERSECTION ::= "INTERSECTION"
INTERVAL ::= "INTERVAL"
INTO ::= "INTO"
IS ::= "IS"
JOIN ::= "JOIN"
JSON_ARRAY ::= "JSON_ARRAY"
JSON_ARRAYAGG ::= "JSON_ARRAYAGG"
JSON_EXISTS ::= "JSON_EXISTS"
JSON_OBJECT ::= "JSON_OBJECT"
JSON_OBJECTAGG ::= "JSON_OBJECTAGG"
JSON_QUERY ::= "JSON_QUERY"
JSON_TABLE ::= "JSON_TABLE"
JSON_TABLE_PRIMITIVE ::= "JSON_TABLE_PRIMITIVE"
JSON_VALUE ::= "JSON_VALUE"
LAG ::= "LAG"
LANGUAGE ::= "LANGUAGE"
LARGE ::= "LARGE"
LAST_VALUE ::= "LAST_VALUE"
LATERAL ::= "LATERAL"
LEAD ::= "LEAD"
LEADING ::= "LEADING"
LEFT ::= "LEFT"
LIKE ::= "LIKE"
LIKE_REGEX ::= "LIKE_REGEX"
LISTAGG ::= "LISTAGG"
LN ::= "LN"
LOCAL ::= "LOCAL"
LOCALTIME ::= "LOCALTIME"
LOCALTIMESTAMP ::= "LOCALTIMESTAMP"
LOG ::= "LOG"
LOG10 ::= "LOG10"
LOWER ::= "LOWER"
MATCH ::= "MATCH"
MATCH_NUMBER ::= "MATCH_NUMBER"
MATCH_RECOGNIZE ::= "MATCH_RECOGNIZE"
MATCHES ::= "MATCHES"
MAX ::= "MAX"
MEMBER ::= "MEMBER"
MERGE ::= "MERGE"
METHOD ::= "METHOD"
MIN ::= "MIN"
MINUTE ::= "MINUTE"
MOD ::= "MOD"
MODIFIES ::= "MODIFIES"
MODULE ::= "MODULE"
MONTH ::= "MONTH"
MULTISET ::= "MULTISET"
NATIONAL ::= "NATIONAL"
NATURAL ::= "NATURAL"
NCHAR ::= "NCHAR"
NCLOB ::= "NCLOB"
NEW ::= "NEW"
NO ::= "NO"
NONE ::= "NONE"
NORMALIZE ::= "NORMALIZE"
NOT ::= "NOT"
NTH_VALUE ::= "NTH_VALUE"
NTILE ::= "NTILE"
NULL ::= "NULL"
NULLIF ::= "NULLIF"
NUMERIC ::= "NUMERIC"
OCTET_LENGTH ::= "OCTET_LENGTH"
OCCURRENCES_REGEX ::= "OCCURRENCES_REGEX"
OF ::= "OF"
OFFSET ::= "OFFSET"
OLD ::= "OLD"
OMIT ::= "OMIT"
ON ::= "ON"
ONE ::= "ONE"
ONLY ::= "ONLY"
OPEN ::= "OPEN"
OR ::= "OR"
ORDER ::= "ORDER"
OUT ::= "OUT"
OUTER ::= "OUTER"
OVER ::= "OVER"
OVERLAPS ::= "OVERLAPS"
OVERLAY ::= "OVERLAY"
PARAMETER ::= "PARAMETER"
PARTITION ::= "PARTITION"
PATTERN ::= "PATTERN"
PER ::= "PER"
PERCENT ::= "PERCENT"
PERCENT_RANK ::= "PERCENT_RANK"
PERCENTILE_CONT ::= "PERCENTILE_CONT"
PERCENTILE_DISC ::= "PERCENTILE_DISC"
PERIOD ::= "PERIOD"
PORTION ::= "PORTION"
POSITION ::= "POSITION"
POSITION_REGEX ::= "POSITION_REGEX"
POWER ::= "POWER"
PRECEDES ::= "PRECEDES"
PRECISION ::= "PRECISION"
PREPARE ::= "PREPARE"
PRIMARY ::= "PRIMARY"
PROCEDURE ::= "PROCEDURE"
PTF ::= "PTF"
RANGE ::= "RANGE"
RANK ::= "RANK"
READS ::= "READS"
REAL ::= "REAL"
RECURSIVE ::= "RECURSIVE"
REF ::= "REF"
REFERENCES ::= "REFERENCES"
REFERENCING ::= "REFERENCING"
REGR_AVGX ::= "REGR_AVGX"
REGR_AVGY ::= "REGR_AVGY"
REGR_COUNT ::= "REGR_COUNT"
REGR_INTERCEPT ::= "REGR_INTERCEPT"
REGR_R2 ::= "REGR_R2"
REGR_SLOPE ::= "REGR_SLOPE"
REGR_SXX ::= "REGR_SXX"
REGR_SXY ::= "REGR_SXY"
REGR_SYY ::= "REGR_SYY"
RELEASE ::= "RELEASE"
RESULT ::= "RESULT"
RETURN ::= "RETURN"
RETURNS ::= "RETURNS"
REVOKE ::= "REVOKE"
RIGHT ::= "RIGHT"
ROLLBACK ::= "ROLLBACK"
ROLLUP ::= "ROLLUP"
ROW ::= "ROW"
ROW_NUMBER ::= "ROW_NUMBER"
ROWS ::= "ROWS"
RUNNING ::= "RUNNING"
SAVEPOINT ::= "SAVEPOINT"
SCOPE ::= "SCOPE"
SCROLL ::= "SCROLL"
SEARCH ::= "SEARCH"
SECOND ::= "SECOND"
SEEK ::= "SEEK"
SELECT ::= "SELECT"
SENSITIVE ::= "SENSITIVE"
SESSION_USER ::= "SESSION_USER"
SET ::= "SET"
SHOW ::= "SHOW"
SIMILAR ::= "SIMILAR"
SIN ::= "SIN"
SINH ::= "SINH"
SKIP ::= "SKIP"
SMALLINT ::= "SMALLINT"
SOME ::= "SOME"
SPECIFIC ::= "SPECIFIC"
SPECIFICTYPE ::= "SPECIFICTYPE"
SQL ::= "SQL"
SQLEXCEPTION ::= "SQLEXCEPTION"
SQLSTATE ::= "SQLSTATE"
SQLWARNING ::= "SQLWARNING"
SQRT ::= "SQRT"
START ::= "START"
STATIC ::= "STATIC"
STDDEV_POP ::= "STDDEV_POP"
STDDEV_SAMP ::= "STDDEV_SAMP"
SUBMULTISET ::= "SUBMULTISET"
SUBSET ::= "SUBSET"
SUBSTRING ::= "SUBSTRING"
SUBSTRING_REGEX ::= "SUBSTRING_REGEX"
SUCCEEDS ::= "SUCCEEDS"
SUM ::= "SUM"
SYMMETRIC ::= "SYMMETRIC"
SYSTEM ::= "SYSTEM"
SYSTEM_TIME ::= "SYSTEM_TIME"
SYSTEM_USER ::= "SYSTEM_USER"
TABLE ::= "TABLE"
TABLESAMPLE ::= "TABLESAMPLE"
TAN ::= "TAN"
TANH ::= "TANH"
THEN ::= "THEN"
TIME ::= "TIME"
TIMESTAMP ::= "TIMESTAMP"
TIMEZONE_HOUR ::= "TIMEZONE_HOUR"
TIMEZONE_MINUTE ::= "TIMEZONE_MINUTE"
TO ::= "TO"
TRAILING ::= "TRAILING"
TRANSLATE ::= "TRANSLATE"
TRANSLATE_REGEX ::= "TRANSLATE_REGEX"
TRANSLATION ::= "TRANSLATION"
TREAT ::= "TREAT"
TRIGGER ::= "TRIGGER"
TRIM ::= "TRIM"
TRIM_ARRAY ::= "TRIM_ARRAY"
TRUE ::= "TRUE"
TRUNCATE ::= "TRUNCATE"
UESCAPE ::= "UESCAPE"
UNION ::= "UNION"
UNIQUE ::= "UNIQUE"
UNKNOWN ::= "UNKNOWN"
UNNEST ::= "UNNEST"
UPDATE ::= "UPDATE"
UPPER ::= "UPPER"
USER ::= "USER"
USING ::= "USING"
VALUE ::= "VALUE"
VALUES ::= "VALUES"
VALUE_OF ::= "VALUE_OF"
VAR_POP ::= "VAR_POP"
VAR_SAMP ::= "VAR_SAMP"
VARBINARY ::= "VARBINARY"
VARCHAR ::= "VARCHAR"
VARYING ::= "VARYING"
VERSIONING ::= "VERSIONING"
WHEN ::= "WHEN"
WHENEVER ::= "WHENEVER"
WHERE ::= "WHERE"
WIDTH_BUCKET ::= "WIDTH_BUCKET"
WINDOW ::= "WINDOW"
WITH ::= "WITH"
WITHIN ::= "WITHIN"
WITHOUT ::= "WITHOUT"
YEAR ::= "YEAR"